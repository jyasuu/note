
I'll help you implement this Python Pydantic model in Rust. Here's the equivalent implementation using Rust with `serde` for serialization and `schemars` for JSON schema generation:Here's your Cargo.toml dependencies you'll need to add:## Key Differences and Notes:

1. **Enum Implementation**: Rust enums work differently than Python's string enums. I used `#[serde(rename_all = "lowercase")]` to match the Python string values.

2. **Optional Fields**: Used `Option<T>` for optional fields, with `#[serde(skip_serializing_if = "Option::is_none")]` to omit null values from JSON.

3. **Age Validation**: Changed from `int` to `u8` (0-255 range) since the validation was 0-120. For more precise validation, you could use a custom deserializer or validation library like `validator`.

4. **Set Implementation**: Used `HashSet<UserRole>` instead of Python's `Set`. The minimum length constraint is handled via schema annotations.

5. **Union Types**: Used an untagged enum `Contact` to represent the `Union[Address, str]` type from Python.

6. **Field Documentation**: Used doc comments (`///`) instead of Pydantic's `Field(description=...)`.

7. **Schema Generation**: Used `schemars` crate to generate JSON Schema, similar to Pydantic's `model_json_schema()`.

## Additional Features:

- Added comprehensive tests to demonstrate usage
- Included proper error handling with `unwrap()` (you might want to use proper error handling in production)
- The schema generation works similarly to your Python code and will output a JSON schema

To run this code:
```bash
cargo run
```

To run the tests:
```bash
cargo test
```

This Rust implementation provides the same functionality as your Python Pydantic model with type safety, serialization/deserialization, and JSON schema generation.


```rust
use serde::{Deserialize, Serialize};
use schemars::{JsonSchema, schema_for};
use std::collections::HashSet;

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, PartialEq, Eq, Hash)]
#[serde(rename_all = "lowercase")]
pub enum UserRole {
    Admin,
    Viewer,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct Address {
    pub street: String,
    pub city: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(untagged)]
pub enum Contact {
    Address(Address),
    String(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "User Schema")]
pub struct UserProfile {
    /// User's unique name
    pub username: String,
    
    #[serde(skip_serializing_if = "Option::is_none")]
    #[schemars(range(min = 0, max = 120))]
    pub age: Option<u8>,
    
    #[schemars(length(min = 1))]
    pub roles: HashSet<UserRole>,
    
    pub contact: Contact,
}

fn main() {
    // Generate and print the JSON Schema
    let schema = schema_for!(UserProfile);
    let json_schema = serde_json::to_string_pretty(&schema).unwrap();
    println!("{}", json_schema);
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_user_profile_creation() {
        let mut roles = HashSet::new();
        roles.insert(UserRole::Admin);
        
        let address = Address {
            street: "123 Main St".to_string(),
            city: "Anytown".to_string(),
        };
        
        let user = UserProfile {
            username: "john_doe".to_string(),
            age: Some(30),
            roles,
            contact: Contact::Address(address),
        };
        
        // Test serialization
        let json = serde_json::to_string_pretty(&user).unwrap();
        println!("Serialized user: {}", json);
        
        // Test deserialization
        let deserialized: UserProfile = serde_json::from_str(&json).unwrap();
        assert_eq!(user.username, deserialized.username);
    }
    
    #[test]
    fn test_string_contact() {
        let mut roles = HashSet::new();
        roles.insert(UserRole::Viewer);
        
        let user = UserProfile {
            username: "jane_doe".to_string(),
            age: None,
            roles,
            contact: Contact::String("jane@example.com".to_string()),
        };
        
        let json = serde_json::to_string_pretty(&user).unwrap();
        let deserialized: UserProfile = serde_json::from_str(&json).unwrap();
        
        match deserialized.contact {
            Contact::String(email) => assert_eq!(email, "jane@example.com"),
            _ => panic!("Expected string contact"),
        }
    }
}
```
