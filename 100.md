To design a Firebase Cloud Messaging (FCM)-like system for a pure on-premise intranet environment using Rust, we'll create a lightweight server that handles client registration, message queuing, and delivery via WebSockets. This solution doesn't require external internet access and targets desktop/server clients within an intranet.

### Solution Overview
1. **Client Registration**: Clients register with the server to get a unique token.
2. **Message Sending**: Applications send messages to clients via HTTP API.
3. **Message Delivery**: Server delivers messages to connected clients over WebSockets.
4. **Storage**: In-memory storage for client connections and queued messages.

### Dependencies (`Cargo.toml`)
```toml
[package]
name = "fcm_intranet"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
warp = "0.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
futures = "0.3"
lazy_static = "1.4"
```

### Implementation (`src/main.rs`)
```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock};
use warp::{
    ws::{Message, WebSocket},
    Filter, Rejection, Reply,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use futures::{SinkExt, StreamExt};

// Client state structure
struct Client {
    sender: Option<tokio::sync::mpsc::UnboundedSender<Message>>,
}

// App state shared across routes
#[derive(Default)]
struct AppState {
    clients: RwLock<HashMap<String, Client>>,
    queued_messages: Mutex<HashMap<String, Vec<Message>>>,
}

type SharedState = Arc<AppState>;

#[derive(Deserialize)]
struct SendMessageRequest {
    token: String,
    message: String,
}

#[derive(Serialize)]
struct RegisterResponse {
    token: String,
}

// Register client and return token
async fn register_handler(state: SharedState) -> Result<impl Reply, Rejection> {
    let token = Uuid::new_v4().to_string();
    let mut clients = state.clients.write().await;
    clients.insert(token.clone(), Client { sender: None });
    
    Ok(warp::reply::json(&RegisterResponse { token }))
}

// Handle incoming WebSocket connections
async fn ws_handler(
    token: String,
    ws: WebSocket,
    state: SharedState,
) {
    let (client_ws_sender, mut client_ws_rcv) = ws.split();
    let (client_sender, mut client_receiver) = tokio::sync::mpsc::unbounded_channel();

    // Update client with message sender
    {
        let mut clients = state.clients.write().await;
        if let Some(client) = clients.get_mut(&token) {
            client.sender = Some(client_sender);
        }
    }

    // Deliver queued messages
    {
        let mut queued_messages = state.queued_messages.lock().await;
        if let Some(messages) = queued_messages.remove(&token) {
            for msg in messages {
                if let Some(sender) = &state.clients.read().await.get(&token).and_then(|c| c.sender.as_ref()) {
                    let _ = sender.send(msg);
                }
            }
        }
    }

    // Spawn sender task
    tokio::spawn(async move {
        while let Some(msg) = client_receiver.recv().await {
            if client_ws_sender.send(msg).await.is_err() {
                break;
            }
        }
    });

    // Keep connection open
    while let Some(_) = client_ws_rcv.next().await {}
}

// Send message to client (queue if offline)
async fn send_message_handler(
    req: SendMessageRequest,
    state: SharedState,
) -> Result<impl Reply, Rejection> {
    let clients = state.clients.read().await;
    let msg = Message::text(req.message);

    if let Some(client) = clients.get(&req.token) {
        if let Some(sender) = &client.sender {
            sender.send(msg.clone()).map_err(|_| warp::reject())?;
            return Ok(warp::reply::with_status("Sent", warp::http::StatusCode::OK));
        }
    }

    // Queue message if client offline
    let mut queued_messages = state.queued_messages.lock().await;
    queued_messages.entry(req.token).or_default().push(msg);

    Ok(warp::reply::with_status(
        "Queued (client offline)",
        warp::http::StatusCode::ACCEPTED,
    ))
}

#[tokio::main]
async fn main() {
    let state = Arc::new(AppState::default());

    // REST API routes
    let register_route = warp::path("register")
        .and(warp::get())
        .and(with_state(state.clone()))
        .and_then(register_handler);

    let send_route = warp::path("send")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_state(state.clone()))
        .and_then(send_message_handler);

    // WebSocket route
    let ws_route = warp::path("ws")
        .and(warp::query::<HashMap<String, String>>())
        .and(warp::ws())
        .and(with_state(state.clone()))
        .map(|qs: HashMap<String, String>, ws: warp::ws::Ws, state| {
            if let Some(token) = qs.get("token") {
                ws.on_upgrade(move |socket| ws_handler(token.clone(), socket, state))
            } else {
                warp::reply::with_status("Missing token", warp::http::StatusCode::BAD_REQUEST).into_response()
            }
        });

    // Combine routes
    let routes = register_route
        .or(send_route)
        .or(ws_route)
        .with(warp::cors().allow_any_origin());

    println!("Server running on 0.0.0.0:3030");
    warp::serve(routes).run(([0, 0, 0, 0], 3030)).await;
}

// Helper to inject state
fn with_state(state: SharedState) -> impl Filter<Extract = (SharedState,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || state.clone())
}
```

### Key Features
1. **Client Registration**
   - Endpoint: `GET /register`
   - Returns: `{ "token": "uuid" }`
   - Stores client in memory with no active connection

2. **Message Sending**
   - Endpoint: `POST /send`
   - Body: `{ "token": "uuid", "message": "text" }`
   - Online clients: Immediate delivery
   - Offline clients: Message queued (stored in memory)

3. **Message Delivery**
   - Endpoint: `GET /ws?token=uuid` (WebSocket)
   - On connection: Delivers all queued messages
   - Maintains persistent connection for real-time delivery

4. **Fault Tolerance**
   - Queue messages when clients offline
   - Automatic cleanup of queued messages after delivery
   - Thread-safe state management

### Usage Flow
1. **Client Registration**
```bash
curl http://server:3030/register
# Response: {"token":"7b17fe27-6d6b-4c7e-9b8a-3d3e7e7e7e7e"}
```

2. **Sending Messages**
```bash
curl -X POST http://server:3030/send \
  -H "Content-Type: application/json" \
  -d '{"token": "7b17fe27...", "message": "Hello"}'
```

3. **Client Connection (Rust Client Example)**
```rust
use tokio_tungstenite::connect_async;
use url::Url;

#[tokio::main]
async fn main() {
    let url = Url::parse(
        "ws://server:3030/ws?token=7b17fe27-6d6b-4c7e-9b8a-3d3e7e7e7e7e"
    ).unwrap();
    
    let (ws_stream, _) = connect_async(url).await.unwrap();
    let (_, mut read) = ws_stream.split();
    
    while let Some(msg) = read.next().await {
        println!("Received: {}", msg.unwrap());
    }
}
```

### Advantages
- **No External Dependencies**: Pure Rust implementation
- **Low Latency**: WebSockets for real-time delivery
- **Queueing**: Temporary storage for offline clients
- **Scalability**: Async I/O handles thousands of connections
- **Security**: Token-based authentication (adapt for additional security)

This solution provides a robust foundation for an on-premise messaging system. For production use, consider adding:
1. Message persistence (SQLite/Redis)
2. Token expiration/refresh
3. HTTPS/TLS encryption
4. Rate limiting
5. Client heartbeat/ping mechanism
6. Message acknowledgments

The system efficiently handles message delivery within an intranet environment while maintaining simplicity and performance.
