Here's a structured comparison of Kubernetes tools (kubectl, Terraform, Ansible, Helm) in the context of CI/CD pipelines:

---

### **1. Overview in CI/CD**
| Tool       | Primary Role in CI/CD                                                                 |
|------------|---------------------------------------------------------------------------------------|
| **kubectl** | Directly interacts with Kubernetes clusters to deploy, manage, and debug applications. |
| **Terraform** | Provisions cloud infrastructure (e.g., clusters, networks, storage) using Infrastructure-as-Code (IaC). |
| **Ansible** | Automates configuration management, node setup, and application deployment via playbooks. |
| **Helm**    | Manages Kubernetes applications as reusable, versioned "charts" with templating and lifecycle support. |

---

### **2. Key Comparison Factors**
#### **Purpose**
| Tool       | Key Strengths                                                                         |
|------------|---------------------------------------------------------------------------------------|
| **kubectl** | Raw Kubernetes operations (e.g., `apply`, `rollout`, `logs`). Ideal for simple deployments. |
| **Terraform** | Infrastructure provisioning (e.g., creating EKS/GKE clusters, VPCs, databases).       |
| **Ansible** | Multi-tier automation (e.g., VM configuration, dependency installation, hybrid workflows). |
| **Helm**    | Templating, versioning, and lifecycle management of Kubernetes applications.          |

#### **Kubernetes Integration**
| Tool       | Native K8s Support | Typical Use Case in K8s                                  |
|------------|--------------------|----------------------------------------------------------|
| **kubectl** | âœ…                 | Direct cluster interaction (deployments, scaling, debugging). |
| **Terraform** | Partial (via providers) | Cluster setup + basic resource management (e.g., namespaces). |
| **Ansible** | Partial (via modules) | Mixed workflows (e.g., cluster setup + app deployment).  |
| **Helm**    | âœ…                 | Application packaging, templating, and release tracking. |

#### **Templating & Reusability**
| Tool       | Mechanism                              | Complexity Handling                                   |
|------------|----------------------------------------|-------------------------------------------------------|
| **kubectl** | None (raw YAML/JSON files).            | Limited for large apps; requires manual updates.      |
| **Terraform** | Modules for reusable infrastructure.   | Strong for infrastructure, weak for app templating.   |
| **Ansible** | Roles/templates for configuration.     | Flexible but requires custom playbooks.               |
| **Helm**    | Charts with values.yaml for variables. | Built for complex apps (e.g., microservices, dependencies). |

#### **State Management**
| Tool       | State Handling                                                                 |
|------------|--------------------------------------------------------------------------------|
| **kubectl** | Stateless; relies on Kubernetes API server state.                              |
| **Terraform** | Tracks state via files (local/remote) to manage infrastructure drift.         |
| **Ansible** | Stateless; idempotent playbooks ensure desired state.                          |
| **Helm**    | Tracks releases via Kubernetes Secrets (v3) or ConfigMaps (v2).               |

#### **CI/CD Integration**
| Tool       | Ease of Use in Pipelines                                   | Common CI/CD Steps                               |
|------------|------------------------------------------------------------|-------------------------------------------------|
| **kubectl** | Simple CLI commands (e.g., `apply -f manifest.yaml`).      | Deploy manifests, check pod status, rollbacks.  |
| **Terraform** | Requires state backend (e.g., S3) and credentials.         | `terraform init && plan && apply` for infra.    |
| **Ansible** | Requires inventory files and playbook execution.           | Run playbooks to configure nodes or deploy apps.|
| **Helm**    | CLI-driven (e.g., `helm upgrade --install`). Integrates with artifact repos. | Package charts, deploy releases.                |

---

### **3. When to Use Which Tool**
- **Terraform**: 
  - Use for provisioning cloud resources (clusters, networks, etc.).
  - Avoid for application deployment (use Helm/kubectl instead).
- **Ansible**:
  - Use for hybrid workflows (e.g., VM configuration + K8s app deployment).
  - Avoid if only pure Kubernetes-native tasks are needed.
- **kubectl**:
  - Use for straightforward deployments and debugging.
  - Avoid for complex apps (use Helm instead).
- **Helm**:
  - Use for templating, multi-environment deployments, and managing app lifecycles.
  - Avoid for infrastructure provisioning.

---

### **4. Common Combinations**
1. **Terraform + Helm**:
   - Terraform provisions the cluster and infrastructure.
   - Helm deploys applications using versioned charts.
2. **Ansible + kubectl**:
   - Ansible configures nodes and runs `kubectl` commands for app deployment.
3. **Terraform + kubectl**:
   - Terraform creates the cluster, and `kubectl` applies manifests directly.

---

### **5. Summary Table**
| Factor          | kubectl          | Terraform        | Ansible          | Helm             |
|-----------------|------------------|------------------|------------------|------------------|
| **Scope**       | App Deployment   | Infrastructure   | Config + Apps    | App Deployment   |
| **State**       | Stateless        | Stateful         | Stateless        | Stateful (Releases) |
| **Learning Curve** | Low           | Moderate         | Moderate         | Moderate         |
| **Best For**    | Simple K8s Ops  | Cloud Infra      | Hybrid Workflows | Complex K8s Apps |

---

**Final Notes**: 
- Use **Terraform** for infrastructure, **Helm** for apps, and **kubectl** for debugging. 
- **Ansible** bridges gaps in hybrid environments but adds complexity.
- Combine tools (e.g., Terraform + Helm) for end-to-end CI/CD pipelines.


ä»¥ä¸‹æ˜¯é’ˆå¯¹ Kubernetes å·¥å…·ï¼ˆkubectlã€Terraformã€Ansibleã€Helmï¼‰åœ¨ CI/CD æµæ°´çº¿ä¸­çš„ç»“æž„åŒ–ä¸­æ–‡å¯¹æ¯”ï¼š

---

### **1. CI/CD ä¸­çš„æ ¸å¿ƒè§’è‰²**
| å·¥å…·         | åœ¨ CI/CD ä¸­çš„ä¸»è¦ä½œç”¨                                                                 |
|--------------|---------------------------------------------------------------------------------------|
| **kubectl**  | ç›´æŽ¥ä¸Ž Kubernetes é›†ç¾¤äº¤äº’ï¼Œéƒ¨ç½²ã€ç®¡ç†å’Œè°ƒè¯•åº”ç”¨ã€‚                                      |
| **Terraform**| é€šè¿‡åŸºç¡€è®¾æ–½å³ä»£ç ï¼ˆIaCï¼‰åˆ›å»ºäº‘èµ„æºï¼ˆå¦‚é›†ç¾¤ã€ç½‘ç»œã€å­˜å‚¨ï¼‰ã€‚                              |
| **Ansible**  | é€šè¿‡ Playbook è‡ªåŠ¨åŒ–é…ç½®ç®¡ç†ã€èŠ‚ç‚¹è®¾ç½®å’Œåº”ç”¨éƒ¨ç½²ã€‚                                       |
| **Helm**     | é€šè¿‡å¯å¤ç”¨çš„ç‰ˆæœ¬åŒ– "Chart"ï¼ˆå›¾è¡¨ï¼‰ç®¡ç† Kubernetes åº”ç”¨ï¼Œæ”¯æŒæ¨¡æ¿åŒ–å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚        |

---

### **2. æ ¸å¿ƒå¯¹æ¯”ç»´åº¦**
#### **ä¸»è¦ç”¨é€”**
| å·¥å…·         | æ ¸å¿ƒä¼˜åŠ¿                                                                               |
|--------------|---------------------------------------------------------------------------------------|
| **kubectl**  | ç›´æŽ¥æ“ä½œ Kubernetesï¼ˆå¦‚ `apply`ã€`rollout`ã€`logs`ï¼‰ï¼Œé€‚åˆç®€å•éƒ¨ç½²ã€‚                    |
| **Terraform**| åŸºç¡€è®¾æ–½å³ä»£ç ï¼ˆå¦‚åˆ›å»º EKS/GKE é›†ç¾¤ã€VPCã€æ•°æ®åº“ï¼‰ã€‚                                     |
| **Ansible**  | å¤šå±‚çº§è‡ªåŠ¨åŒ–ï¼ˆå¦‚è™šæ‹Ÿæœºé…ç½®ã€ä¾èµ–å®‰è£…ã€æ··åˆçŽ¯å¢ƒå·¥ä½œæµï¼‰ã€‚                                 |
| **Helm**     | Kubernetes åº”ç”¨çš„æ¨¡æ¿åŒ–ã€ç‰ˆæœ¬åŒ–å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆå¦‚å¾®æœåŠ¡ã€ä¾èµ–é¡¹ï¼‰ã€‚                      |

#### **Kubernetes é›†æˆ**
| å·¥å…·         | åŽŸç”Ÿæ”¯æŒ Kubernetesï¼Ÿ | å…¸åž‹ç”¨ä¾‹                                                                 |
|--------------|-----------------------|--------------------------------------------------------------------------|
| **kubectl**  | âœ…                    | ç›´æŽ¥æ“ä½œé›†ç¾¤ï¼ˆéƒ¨ç½²ã€æ‰©ç¼©å®¹ã€è°ƒè¯•ï¼‰ã€‚                                      |
| **Terraform**| éƒ¨åˆ†ï¼ˆé€šè¿‡ Providerï¼‰ | é›†ç¾¤æ­å»º + åŸºç¡€èµ„æºç®¡ç†ï¼ˆå¦‚å‘½åç©ºé—´ï¼‰ã€‚                                    |
| **Ansible**  | éƒ¨åˆ†ï¼ˆé€šè¿‡æ¨¡å—ï¼‰      | æ··åˆå·¥ä½œæµï¼ˆå¦‚é›†ç¾¤é…ç½® + åº”ç”¨éƒ¨ç½²ï¼‰ã€‚                                      |
| **Helm**     | âœ…                    | åº”ç”¨æ‰“åŒ…ã€æ¨¡æ¿åŒ–ã€ç‰ˆæœ¬è¿½è¸ªã€‚                                              |

#### **æ¨¡æ¿åŒ–ä¸Žå¤ç”¨æ€§**
| å·¥å…·         | æ¨¡æ¿æœºåˆ¶               | å¤æ‚æ€§å¤„ç†èƒ½åŠ›                                                     |
|--------------|------------------------|-------------------------------------------------------------------|
| **kubectl**  | æ— ï¼ˆåŽŸå§‹ YAML/JSONï¼‰   | å¤„ç†å¤§åž‹åº”ç”¨æ—¶éœ€æ‰‹åŠ¨æ›´æ–°ï¼Œçµæ´»æ€§å·®ã€‚                                 |
| **Terraform**| æ¨¡å—åŒ–åŸºç¡€è®¾æ–½ä»£ç       | æ“…é•¿åŸºç¡€è®¾æ–½å¤ç”¨ï¼Œä½†ä¸é€‚åˆåº”ç”¨æ¨¡æ¿ã€‚                                 |
| **Ansible**  | è§’è‰²ï¼ˆRolesï¼‰å’Œæ¨¡æ¿æ–‡ä»¶ | çµæ´»ï¼Œä½†éœ€è‡ªå®šä¹‰ Playbookã€‚                                         |
| **Helm**     | Chart + `values.yaml`  | ä¸“ä¸ºå¤æ‚åº”ç”¨è®¾è®¡ï¼ˆå¦‚å¤šçŽ¯å¢ƒå˜é‡ã€ä¾èµ–é¡¹ï¼‰ã€‚                           |

#### **çŠ¶æ€ç®¡ç†**
| å·¥å…·         | çŠ¶æ€ç®¡ç†æ–¹å¼                                                                 |
|--------------|-----------------------------------------------------------------------------|
| **kubectl**  | æ— çŠ¶æ€ï¼Œä¾èµ– Kubernetes API æœåŠ¡å™¨çš„çŠ¶æ€ã€‚                                   |
| **Terraform**| é€šè¿‡æœ¬åœ°/è¿œç¨‹çŠ¶æ€æ–‡ä»¶è¿½è¸ªåŸºç¡€è®¾æ–½å˜æ›´ï¼ˆå¦‚é˜²æ­¢é…ç½®æ¼‚ç§»ï¼‰ã€‚                      |
| **Ansible**  | æ— çŠ¶æ€ï¼Œé€šè¿‡å¹‚ç­‰æ€§ Playbook ç¡®ä¿ç›®æ ‡çŠ¶æ€ã€‚                                    |
| **Helm**     | é€šè¿‡ Kubernetes Secretï¼ˆv3ï¼‰æˆ– ConfigMapï¼ˆv2ï¼‰è¿½è¸ªå‘å¸ƒç‰ˆæœ¬ã€‚                 |

#### **CI/CD é›†æˆ**
| å·¥å…·         | åœ¨æµæ°´çº¿ä¸­çš„æ˜“ç”¨æ€§                          | å¸¸è§æµæ°´çº¿æ­¥éª¤                                   |
|--------------|---------------------------------------------|-----------------------------------------------|
| **kubectl**  | ç®€å• CLI å‘½ä»¤ï¼ˆå¦‚ `apply -f manifest.yaml`ï¼‰ | éƒ¨ç½²æ¸…å•ã€æ£€æŸ¥ Pod çŠ¶æ€ã€å›žæ»šã€‚                  |
| **Terraform**| éœ€é…ç½®çŠ¶æ€åŽç«¯ï¼ˆå¦‚ S3ï¼‰å’Œäº‘å‡­è¯ã€‚             | `terraform init && plan && apply` åˆ›å»ºåŸºç¡€è®¾æ–½ã€‚|
| **Ansible**  | éœ€é…ç½® Inventory æ–‡ä»¶å’Œæ‰§è¡Œ Playbookã€‚       | é€šè¿‡ Playbook é…ç½®èŠ‚ç‚¹æˆ–éƒ¨ç½²åº”ç”¨ã€‚               |
| **Helm**     | CLI é©±åŠ¨ï¼ˆå¦‚ `helm upgrade --install`ï¼‰ã€‚    | æ‰“åŒ… Chartã€å‘å¸ƒåº”ç”¨ç‰ˆæœ¬ã€‚                       |

---

### **3. ä½¿ç”¨åœºæ™¯æŽ¨è**
- **Terraform**ï¼š  
  - é€‚ç”¨ï¼šåˆ›å»ºäº‘èµ„æºï¼ˆé›†ç¾¤ã€ç½‘ç»œç­‰ï¼‰ã€‚  
  - é¿å…ï¼šç›´æŽ¥éƒ¨ç½²åº”ç”¨ï¼ˆæ”¹ç”¨ Helm/kubectlï¼‰ã€‚  
- **Ansible**ï¼š  
  - é€‚ç”¨ï¼šæ··åˆçŽ¯å¢ƒï¼ˆå¦‚è™šæ‹Ÿæœºé…ç½® + K8s åº”ç”¨éƒ¨ç½²ï¼‰ã€‚  
  - é¿å…ï¼šçº¯ Kubernetes åŽŸç”Ÿä»»åŠ¡ã€‚  
- **kubectl**ï¼š  
  - é€‚ç”¨ï¼šç®€å•éƒ¨ç½²å’Œè°ƒè¯•ã€‚  
  - é¿å…ï¼šå¤æ‚åº”ç”¨ï¼ˆæ”¹ç”¨ Helmï¼‰ã€‚  
- **Helm**ï¼š  
  - é€‚ç”¨ï¼šæ¨¡æ¿åŒ–ã€å¤šçŽ¯å¢ƒéƒ¨ç½²ã€åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚  
  - é¿å…ï¼šåŸºç¡€è®¾æ–½é…ç½®ã€‚  

---

### **4. å¸¸ç”¨ç»„åˆ**
1. **Terraform + Helm**ï¼š  
   - Terraform åˆ›å»ºé›†ç¾¤å’ŒåŸºç¡€è®¾æ–½ï¼ŒHelm éƒ¨ç½²åº”ç”¨ã€‚  
2. **Ansible + kubectl**ï¼š  
   - Ansible é…ç½®èŠ‚ç‚¹ï¼Œå¹¶é€šè¿‡ `kubectl` éƒ¨ç½²åº”ç”¨ã€‚  
3. **Terraform + kubectl**ï¼š  
   - Terraform åˆ›å»ºé›†ç¾¤ï¼Œ`kubectl` ç›´æŽ¥åº”ç”¨æ¸…å•æ–‡ä»¶ã€‚  

---

### **5. å¯¹æ¯”æ€»ç»“è¡¨**
| ç»´åº¦           | kubectl          | Terraform        | Ansible          | Helm             |
|----------------|------------------|------------------|------------------|------------------|
| **ä¸»è¦é¢†åŸŸ**   | åº”ç”¨éƒ¨ç½²         | åŸºç¡€è®¾æ–½         | é…ç½®ç®¡ç† + åº”ç”¨  | åº”ç”¨éƒ¨ç½²         |
| **çŠ¶æ€ç®¡ç†**   | æ— çŠ¶æ€           | æœ‰çŠ¶æ€           | æ— çŠ¶æ€           | æœ‰çŠ¶æ€ï¼ˆç‰ˆæœ¬ï¼‰   |
| **å­¦ä¹ æ›²çº¿**   | ä½Ž               | ä¸­ç­‰             | ä¸­ç­‰             | ä¸­ç­‰             |
| **æœ€ä½³åœºæ™¯**   | ç®€å• K8s æ“ä½œ    | äº‘åŸºç¡€è®¾æ–½       | æ··åˆå·¥ä½œæµ       | å¤æ‚ K8s åº”ç”¨    |

---

**æ€»ç»“**ï¼š  
- **Terraform** è´Ÿè´£åŸºç¡€è®¾æ–½ï¼Œ**Helm** ç®¡ç†åº”ç”¨ï¼Œ**kubectl** ç”¨äºŽè°ƒè¯•ã€‚  
- **Ansible** é€‚åˆæ··åˆçŽ¯å¢ƒï¼Œä½†ä¼šå¼•å…¥é¢å¤–å¤æ‚åº¦ã€‚  
- ç»„åˆå·¥å…·ï¼ˆå¦‚ Terraform + Helmï¼‰å¯å®žçŽ°ç«¯åˆ°ç«¯æµæ°´çº¿ã€‚

Here are example CI/CD scripts for **GitLab CI/CD** and **GitHub Actions** integrating `kubectl`, `Terraform`, `Ansible`, and `Helm`. These pipelines assume you're deploying a Kubernetes application with infrastructure provisioning and configuration management.

---

### **1. GitLab CI/CD Pipeline (`.gitlab-ci.yml`)**
```yaml
stages:
  - validate
  - build
  - deploy_infra
  - deploy_app
  - test

variables:
  CLUSTER_NAME: "my-cluster"
  TF_STATE_BUCKET: "my-terraform-state-bucket"  # Remote state storage (e.g., AWS S3)
  HELM_CHART: "my-app-chart"

# Use Docker image with all tools pre-installed
image: alpine/terragrunt:latest

before_script:
  - apk add --no-cache python3 ansible kubectl helm  # Install tools
  - mkdir -p ~/.kube
  - echo "${KUBECONFIG}" > ~/.kube/config  # Use GitLab CI variable for kubeconfig

validate:
  stage: validate
  script:
    - terraform validate  # Validate Terraform config
    - helm lint ${HELM_CHART}  # Lint Helm chart
    - ansible-lint ansible/playbook.yml  # Lint Ansible playbook

deploy_infra:
  stage: deploy_infra
  script:
    - cd terraform/
    - terraform init -backend-config="bucket=${TF_STATE_BUCKET}"
    - terraform plan -out=tfplan
    - terraform apply -auto-approve tfplan
  artifacts:
    paths:
      - terraform/outputs/  # Export cluster info (e.g., kubeconfig)

deploy_app:
  stage: deploy_app
  script:
    - ansible-playbook ansible/playbook.yml  # Configure nodes (if needed)
    - helm upgrade --install ${CLUSTER_NAME} ${HELM_CHART} --values values/prod.yaml
    - kubectl rollout status deployment/my-app  # Verify deployment

test:
  stage: test
  script:
    - kubectl run test --image=alpine --restart=Never --rm --command -- "curl -sS http://my-app"
```

---

### **2. GitHub Actions Workflow (`.github/workflows/cicd.yml`)**
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main]

env:
  CLUSTER_NAME: my-cluster
  TF_STATE_BUCKET: my-terraform-state-bucket
  HELM_CHART: my-app-chart

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install tools
        run: |
          sudo apt-get install -y ansible
          curl -fsSL https://get.helm.sh | bash
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install kubectl /usr/local/bin/kubectl
      - name: Validate Terraform
        run: terraform validate -chdir=terraform/
      - name: Lint Helm chart
        run: helm lint ${{ env.HELM_CHART }}

  deploy_infra:
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - uses: actions/checkout@v4
      - name: Terraform Apply
        run: |
          cd terraform/
          terraform init -backend-config="bucket=${{ env.TF_STATE_BUCKET }}"
          terraform plan -out=tfplan
          terraform apply -auto-approve tfplan
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}  # Cloud credentials
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  deploy_app:
    runs-on: ubuntu-latest
    needs: deploy_infra
    steps:
      - uses: actions/checkout@v4
      - name: Configure Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config  # Use GitHub secret
      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ env.CLUSTER_NAME }} ${{ env.HELM_CHART }} --values values/prod.yaml
          kubectl rollout status deployment/my-app
```

---

### **3. Key Integration Notes**
#### **Terraform**
- Store state remotely (e.g., AWS S3, GCS) using `backend-config`.
- Use environment variables or secrets for cloud credentials (AWS/GCP/Azure).

#### **Helm**
- Store Helm charts in a registry (e.g., OCI registry, ArtifactHub) or embed them in the repo.
- Use `--values` to switch configurations for different environments (e.g., `values/prod.yaml`).

#### **Ansible**
- Use an `ansible/` directory with:
  - `inventory.ini` (dynamic inventory for cloud resources).
  - `playbook.yml` (e.g., install dependencies, configure nodes).

#### **kubectl**
- Securely pass `kubeconfig` via CI/CD secrets (GitLab variables or GitHub Secrets).
- Use `rollout status` to verify deployments.

---

### **4. Security Best Practices**
1. **Secrets Management**:
   - Use GitLab CI Variables or GitHub Secrets for:
     - `KUBECONFIG`
     - Cloud credentials (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`).
     - Helm chart repository credentials.
2. **Least Privilege IAM**:
   - Restrict Terraform/AWS permissions to only necessary resources.
3. **Pipeline Hardening**:
   - Lock Terraform state with DynamoDB (AWS) or equivalent.
   - Use `terraform plan` before `apply` to review changes.

---

### **5. Hybrid Example (Ansible + Helm)**
For a hybrid workflow (e.g., configuring VMs before deploying K8s apps):
```yaml
# Ansible playbook.yml snippet
- hosts: k8s_nodes
  tasks:
    - name: Install Kubeadm
      apt:
        name: kubeadm
        state: present

    - name: Join cluster
      shell: kubeadm join <command-from-terraform-output>
```

---

### **6. Customization Tips**
- Add **approval gates** for production deployments (GitLab: manual jobs; GitHub: environments).
- Use **parallel jobs** for multi-environment deployments (e.g., staging/prod).
- Add **notifications** (Slack/Email) for pipeline success/failure.

Adjust these templates based on your cloud provider and app architecture!



Here are example CI/CD scripts for **GitLab CI/CD** and **GitHub Actions** pipelines for each tool (`kubectl`, Terraform, Ansible, Helm) in standalone workflows. These pipelines assume a simple use case but can be extended for complex scenarios.

---

## **1. Terraform Standalone Pipeline**
### **GitLab CI/CD (`.gitlab-ci.yml`)**
```yaml
stages:
  - validate
  - plan
  - apply

variables:
  TF_STATE_BUCKET: "your-s3-bucket"  # Remote state backend (e.g., AWS S3)
  AWS_DEFAULT_REGION: "us-east-1"

before_script:
  - terraform --version

validate:
  stage: validate
  script:
    - terraform init -backend-config="bucket=$TF_STATE_BUCKET"
    - terraform validate

plan:
  stage: plan
  script:
    - terraform plan -out=tfplan
  artifacts:
    paths:
      - tfplan
  only:
    - merge_requests

apply:
  stage: apply
  script:
    - terraform apply -auto-approve tfplan
  when: manual  # Require manual approval for production
  only:
    - main
```

### **GitHub Actions (`.github/workflows/terraform.yml`)**
```yaml
name: Terraform Pipeline

on:
  push:
    branches: [main]
  pull_request:

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v2
      - name: Validate
        run: terraform validate

  plan:
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v2
      - name: Plan
        run: terraform plan -out=tfplan
      - uses: actions/upload-artifact@v3
        with:
          name: tfplan
          path: tfplan

  apply:
    runs-on: ubuntu-latest
    needs: plan
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v2
      - uses: actions/download-artifact@v3
        with:
          name: tfplan
      - name: Apply
        run: terraform apply -auto-approve tfplan
    environment: production
```

---

## **2. Ansible Standalone Pipeline**
### **GitLab CI/CD (`.gitlab-ci.yml`)**
```yaml
stages:
  - deploy

deploy:
  stage: deploy
  image: python:3.9  # Ansible requires Python
  before_script:
    - pip install ansible
  script:
    - ansible-playbook -i inventory.ini playbook.yml --ssh-common-args="-o StrictHostKeyChecking=no"
  variables:
    ANSIBLE_HOST_KEY_CHECKING: "False"
  only:
    - main
```

### **GitHub Actions (`.github/workflows/ansible.yml`)**
```yaml
name: Ansible Pipeline

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Ansible
        run: pip install ansible
      - name: Run Playbook
        run: ansible-playbook -i inventory.ini playbook.yml
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}  # For SSH auth
```

---

## **3. kubectl Standalone Pipeline**
### **GitLab CI/CD (`.gitlab-ci.yml`)**
```yaml
stages:
  - deploy

deploy:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl apply -f manifests/ --kubeconfig $KUBECONFIG
  only:
    - main
  variables:
    KUBECONFIG: $CI_PROJECT_DIR/kubeconfig  # Store kubeconfig as CI variable
```

### **GitHub Actions (`.github/workflows/kubectl.yml`)**
```yaml
name: kubectl Pipeline

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-kubectl@v3
      - name: Deploy to Cluster
        run: kubectl apply -f manifests/
        env:
          KUBECONFIG: ${{ secrets.KUBECONFIG }}
```

---

## **4. Helm Standalone Pipeline**
### **GitLab CI/CD (`.gitlab-ci.yml`)**
```yaml
stages:
  - package
  - deploy

package:
  stage: package
  image: alpine/helm:3.12.0
  script:
    - helm package ./chart -d ./artifacts
  artifacts:
    paths:
      - ./artifacts/*.tgz

deploy:
  stage: deploy
  image: alpine/helm:3.12.0
  script:
    - helm upgrade --install my-app ./artifacts/my-app-0.1.0.tgz --values ./chart/values.yaml
  only:
    - main
```

### **GitHub Actions (`.github/workflows/helm.yml`)**
```yaml
name: Helm Pipeline

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-helm@v3
      - name: Deploy Helm Chart
        run: |
          helm upgrade --install my-app ./chart \
            --values ./chart/values.yaml \
            --kubeconfig ${{ secrets.KUBECONFIG }}
```

---

## **Key Notes**
1. **Secrets Management**:
   - Store sensitive data (e.g., `KUBECONFIG`, `SSH_PRIVATE_KEY`) as encrypted secrets:
     - **GitLab**: `Settings > CI/CD > Variables`.
     - **GitHub**: `Settings > Secrets and variables > Actions`.
   - Use tools like `Vault` or cloud KMS for production-grade security.

2. **File Structure**:
   ```
   .
   â”œâ”€â”€ manifests/          # kubectl YAML files
   â”œâ”€â”€ chart/              # Helm chart directory
   â”‚   â”œâ”€â”€ values.yaml
   â”‚   â””â”€â”€ templates/
   â”œâ”€â”€ playbook.yml        # Ansible playbook
   â”œâ”€â”€ inventory.ini       # Ansible inventory
   â””â”€â”€ main.tf             # Terraform configuration
   ```

3. **Best Practices**:
   - Use **protected branches** for production.
   - Add `when: manual` approval gates for critical stages.
   - Run tests (e.g., `kubeval` for Kubernetes manifests) in the pipeline.

Let me know if you need adjustments for specific use cases! ðŸ˜Š
