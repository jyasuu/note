# pg_graphql Best Practices Guide

pg_graphql is a PostgreSQL extension that automatically generates GraphQL APIs from your database schema with zero external servers needed. Here are the best practices for getting the most out of it.

## 1. Schema Design Fundamentals

### Primary Keys Are Essential
Every table must have a primary key to be exposed in the GraphQL schema. Tables without primary keys won't appear in your API.

```sql
-- ✅ Good: Table with primary key is exposed
CREATE TABLE blog (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL
);

-- ❌ Bad: Table without primary key won't appear in GraphQL
CREATE TABLE blog_metadata (
  id INT,  -- No PRIMARY KEY constraint
  name VARCHAR(255) NOT NULL
);
```

### Use Foreign Keys for Relationships
pg_graphql automatically derives relationships from foreign keys, creating navigable connections in your GraphQL schema.

```sql
CREATE TABLE account (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) NOT NULL
);

CREATE TABLE blog (
  id SERIAL PRIMARY KEY,
  owner_id INTEGER NOT NULL REFERENCES account(id),
  name VARCHAR(255) NOT NULL
);

-- Automatically creates:
-- - account.blog() relationship
-- - blog.account relationship
```

### Leverage PostgreSQL Enums
Enums are automatically reflected in GraphQL schema, providing type safety.

```sql
CREATE TYPE blog_post_status AS ENUM ('PENDING', 'RELEASED', 'ARCHIVED');

CREATE TABLE blog_post (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  status blog_post_status NOT NULL,
  title VARCHAR(255) NOT NULL
);

-- GraphQL will have proper enum values instead of strings
```

## 2. Naming and Inflection

### Enable Inflection for JavaScript Conventions
By default, pg_graphql uses exact SQL names. Enable inflection to convert snake_case to camelCase for fields and PascalCase for types.

```sql
-- Enable inflection at schema level
COMMENT ON SCHEMA public IS
  E'@graphql({"inflect_names": true})';

-- Now: created_at → createdAt, blog_post → BlogPost
```

### Customize Names with Comments
Override auto-generated names for clarity using GraphQL directives.

```sql
CREATE TABLE account (id SERIAL PRIMARY KEY);
CREATE TABLE post (
  id SERIAL PRIMARY KEY,
  account_id INTEGER NOT NULL REFERENCES account(id)
);

-- Rename relationships
COMMENT ON CONSTRAINT post_account_id_fkey ON post IS
  E'@graphql({"foreign_name": "author", "local_name": "posts"})';

-- Results in: post.author instead of post.account
-- And: account.posts instead of account.postCollection
```

### Add Descriptions for Documentation
Use descriptions to auto-generate API documentation that appears in GraphQL introspection.

```sql
COMMENT ON TABLE account IS
  E'@graphql({"description": "User account information"})';

COMMENT ON COLUMN account.email IS
  E'@graphql({"description": "Unique email address for authentication"})';
```

## 3. Authorization and Security

### Use Row-Level Security (RLS)
pg_graphql respects PostgreSQL's permissions and RLS policies. This is the recommended approach for authorization.

```sql
-- Create RLS policy: users can only see their own data
ALTER TABLE account ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_auth ON account
  FOR SELECT USING (id = auth.uid());

-- pg_graphql automatically enforces this in GraphQL queries
```

### Control Exposure with Permissions
Use PostgreSQL's GRANT/REVOKE to control which tables appear in the GraphQL schema.

```sql
-- Hide a table from anonymous users
REVOKE SELECT ON blog FROM anon;

-- Hide specific operations
REVOKE UPDATE ON blog FROM anon;  -- Removes updateBlog from mutations
REVOKE DELETE ON blog FROM anon;  -- Removes deleteBlog from mutations

-- Allow specific schema for authenticated users
GRANT SELECT ON schema_name.* TO authenticated;
```

### Exclude Internal Tables
Keep migration tables and internal schemas out of the GraphQL API.

```sql
-- Hide schema_migrations table created by db tools
REVOKE SELECT ON schema_migrations FROM anon, authenticated;
```

## 4. Performance Optimization

### Set Appropriate Page Sizes
Configure max_rows to balance between API responsiveness and data transfer.

```sql
-- Set default page size to 20 for all tables in public schema
COMMENT ON SCHEMA public IS
  E'@graphql({"max_rows": 20})';

-- Override per table (useful for large datasets)
COMMENT ON TABLE large_dataset IS
  E'@graphql({"max_rows": 10})';
```

The cascade behavior: table setting → schema setting → default (30).

### Leverage Single SQL Generation
pg_graphql compiles queries into single SQL statements. Write efficient queries by using filters, pagination, and specific field selection.

```graphql
# Efficient: Only request needed fields with pagination
{
  blogCollection(first: 10, filter: {status: {eq: "PUBLISHED"}}) {
    edges {
      node {
        id
        title
        createdAt
      }
    }
  }
}

# Less efficient: Fetching all fields and relationships
{
  blogCollection {
    edges {
      node {
        id
        title
        createdAt
        updatedAt
        body
        account { id email posts { id } }
      }
    }
  }
}
```

### Use Filters and Ordering
Push filtering to the database for better performance.

```sql
-- Configure order by options on tables
CREATE TABLE blog_post (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255),
  published_at TIMESTAMP
);

-- Clients can then efficiently query:
-- { postCollection(orderBy: [{publishedAt: AscNullsFirst}]) { ... } }
```

## 5. API Constraints

### Implement Query Depth Limits
GraphQL allows deeply nested queries. Implement depth limits at your API gateway to prevent N+1 problems and performance issues.

### Use atMost for Mutations
When deleting or updating, use `atMost` to prevent accidental mass operations.

```graphql
mutation {
  deleteFromBlogCollection(
    filter: { id: { eq: 999 } }
    atMost: 1  # Prevents accidentally deleting multiple records
  ) {
    affectedCount
  }
}
```

### Consider totalCount Selectively
The `totalCount` field counts all matching records, ignoring pagination. Use it sparingly as it requires a full table scan.

```sql
-- Enable only for tables that need it
COMMENT ON TABLE blog IS
  E'@graphql({"totalCount": true})';
```

## 6. Data Type Handling

### Be Aware of Type Limitations
Some PostgreSQL types need special handling:

**BigInt and Bigserial**: Represented as strings in GraphQL to preserve 64-bit precision.

**Numeric**: Arbitrary-precision numbers are serialized as strings (BigFloat).

**JSON/JSONB**: Serialized as string type. Filter with string operations; JSON filtering not directly supported.

**Opaque Types**: Custom or unsupported types use PostgreSQL's `to_json` method.

```sql
-- When using JSON, pass serialized strings:
UPDATE config SET data = '{"setting": "value"}' WHERE id = 1;
-- Don't try to update with structured JSON in GraphQL
```

### Use nodeId for Caching
Every record has a nodeId field (ID!) that's stable and can be used for caching.

```graphql
{
  blogCollection(first: 1) {
    edges {
      node {
        nodeId  # Stable identifier for caching
        id
        title
      }
    }
  }
}
```

## 7. Testing and Monitoring

### Use GraphiQL for Development
Test queries visually using the built-in GraphiQL interface (on Supabase) or GraphQL IDEs like Altair or Apollo Sandbox.

### Monitor Query Patterns
Watch for queries that:
- Request deeply nested relationships
- Have large result sets without pagination
- Use expensive filters on non-indexed columns

### Upgrade Carefully
Always test pg_graphql upgrades on a staging environment first.

```sql
-- Check versions
SELECT installed_version, default_version FROM graphql_public.graphql_versions();

-- Upgrade when ready
SELECT graphql_public.graphql_upgrade();
```

## 8. Common Patterns

### Paginated Collections
```graphql
{
  blogCollection(
    first: 10
    after: "cursor_from_previous_query"
    filter: { status: { eq: "PUBLISHED" } }
    orderBy: [{ createdAt: DescNullsLast }]
  ) {
    pageInfo {
      hasNextPage
      endCursor
    }
    edges {
      node { id title }
    }
  }
}
```

### Complex Filtering
```graphql
{
  postCollection(
    filter: {
      and: [
        { title: { ilike: "%tutorial%" } }
        { createdAt: { gte: "2024-01-01" } }
      ]
    }
  ) {
    edges { node { id title } }
  }
}
```

### Related Data Traversal
```graphql
{
  accountCollection {
    edges {
      node {
        id
        email
        blogs {  # Auto-generated from foreign key
          id
          name
          posts {  # Nested relationship
            id
            title
          }
        }
      }
    }
  }
}
```

## Summary

The key to pg_graphql success is leveraging PostgreSQL's built-in features: proper schema design with primary keys and foreign keys, permissions-based authorization, and comments for configuration. This results in a powerful, performant GraphQL API with minimal configuration overhead.
