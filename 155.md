# pg_graphql Best Practices Guide

pg_graphql is a PostgreSQL extension that automatically generates GraphQL APIs from your database schema with zero external servers needed. Here are the best practices for getting the most out of it.

## 1. Schema Design Fundamentals

### Primary Keys Are Essential
Every table must have a primary key to be exposed in the GraphQL schema. Tables without primary keys won't appear in your API.

```sql
-- ✅ Good: Table with primary key is exposed
CREATE TABLE blog (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL
);

-- ❌ Bad: Table without primary key won't appear in GraphQL
CREATE TABLE blog_metadata (
  id INT,  -- No PRIMARY KEY constraint
  name VARCHAR(255) NOT NULL
);
```

### Use Foreign Keys for Relationships
pg_graphql automatically derives relationships from foreign keys, creating navigable connections in your GraphQL schema.

```sql
CREATE TABLE account (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) NOT NULL
);

CREATE TABLE blog (
  id SERIAL PRIMARY KEY,
  owner_id INTEGER NOT NULL REFERENCES account(id),
  name VARCHAR(255) NOT NULL
);

-- Automatically creates:
-- - account.blog() relationship
-- - blog.account relationship
```

### Leverage PostgreSQL Enums
Enums are automatically reflected in GraphQL schema, providing type safety.

```sql
CREATE TYPE blog_post_status AS ENUM ('PENDING', 'RELEASED', 'ARCHIVED');

CREATE TABLE blog_post (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  status blog_post_status NOT NULL,
  title VARCHAR(255) NOT NULL
);

-- GraphQL will have proper enum values instead of strings
```

## 2. Naming and Inflection

### Enable Inflection for JavaScript Conventions
By default, pg_graphql uses exact SQL names. Enable inflection to convert snake_case to camelCase for fields and PascalCase for types.

```sql
-- Enable inflection at schema level
COMMENT ON SCHEMA public IS
  E'@graphql({"inflect_names": true})';

-- Now: created_at → createdAt, blog_post → BlogPost
```

### Customize Names with Comments
Override auto-generated names for clarity using GraphQL directives.

```sql
CREATE TABLE account (id SERIAL PRIMARY KEY);
CREATE TABLE post (
  id SERIAL PRIMARY KEY,
  account_id INTEGER NOT NULL REFERENCES account(id)
);

-- Rename relationships
COMMENT ON CONSTRAINT post_account_id_fkey ON post IS
  E'@graphql({"foreign_name": "author", "local_name": "posts"})';

-- Results in: post.author instead of post.account
-- And: account.posts instead of account.postCollection
```

### Add Descriptions for Documentation
Use descriptions to auto-generate API documentation that appears in GraphQL introspection.

```sql
COMMENT ON TABLE account IS
  E'@graphql({"description": "User account information"})';

COMMENT ON COLUMN account.email IS
  E'@graphql({"description": "Unique email address for authentication"})';
```

## 3. Authorization and Security

### Use Row-Level Security (RLS)
pg_graphql respects PostgreSQL's permissions and RLS policies. This is the recommended approach for authorization.

```sql
-- Create RLS policy: users can only see their own data
ALTER TABLE account ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_auth ON account
  FOR SELECT USING (id = auth.uid());

-- pg_graphql automatically enforces this in GraphQL queries
```

### Control Exposure with Permissions
Use PostgreSQL's GRANT/REVOKE to control which tables appear in the GraphQL schema.

```sql
-- Hide a table from anonymous users
REVOKE SELECT ON blog FROM anon;

-- Hide specific operations
REVOKE UPDATE ON blog FROM anon;  -- Removes updateBlog from mutations
REVOKE DELETE ON blog FROM anon;  -- Removes deleteBlog from mutations

-- Allow specific schema for authenticated users
GRANT SELECT ON schema_name.* TO authenticated;
```

### Exclude Internal Tables
Keep migration tables and internal schemas out of the GraphQL API.

```sql
-- Hide schema_migrations table created by db tools
REVOKE SELECT ON schema_migrations FROM anon, authenticated;
```

## 4. Performance Optimization

### Set Appropriate Page Sizes
Configure max_rows to balance between API responsiveness and data transfer.

```sql
-- Set default page size to 20 for all tables in public schema
COMMENT ON SCHEMA public IS
  E'@graphql({"max_rows": 20})';

-- Override per table (useful for large datasets)
COMMENT ON TABLE large_dataset IS
  E'@graphql({"max_rows": 10})';
```

The cascade behavior: table setting → schema setting → default (30).

### Leverage Single SQL Generation
pg_graphql compiles queries into single SQL statements. Write efficient queries by using filters, pagination, and specific field selection.

```graphql
# Efficient: Only request needed fields with pagination
{
  blogCollection(first: 10, filter: {status: {eq: "PUBLISHED"}}) {
    edges {
      node {
        id
        title
        createdAt
      }
    }
  }
}

# Less efficient: Fetching all fields and relationships
{
  blogCollection {
    edges {
      node {
        id
        title
        createdAt
        updatedAt
        body
        account { id email posts { id } }
      }
    }
  }
}
```

### Use Filters and Ordering
Push filtering to the database for better performance.

```sql
-- Configure order by options on tables
CREATE TABLE blog_post (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255),
  published_at TIMESTAMP
);

-- Clients can then efficiently query:
-- { postCollection(orderBy: [{publishedAt: AscNullsFirst}]) { ... } }
```

## 5. API Constraints

### Implement Query Depth Limits
GraphQL allows deeply nested queries. Implement depth limits at your API gateway to prevent N+1 problems and performance issues.

### Use atMost for Mutations
When deleting or updating, use `atMost` to prevent accidental mass operations.

```graphql
mutation {
  deleteFromBlogCollection(
    filter: { id: { eq: 999 } }
    atMost: 1  # Prevents accidentally deleting multiple records
  ) {
    affectedCount
  }
}
```

### Consider totalCount Selectively
The `totalCount` field counts all matching records, ignoring pagination. Use it sparingly as it requires a full table scan.

```sql
-- Enable only for tables that need it
COMMENT ON TABLE blog IS
  E'@graphql({"totalCount": true})';
```

## 6. Data Type Handling

### Be Aware of Type Limitations
Some PostgreSQL types need special handling:

**BigInt and Bigserial**: Represented as strings in GraphQL to preserve 64-bit precision.

**Numeric**: Arbitrary-precision numbers are serialized as strings (BigFloat).

**JSON/JSONB**: Serialized as string type. Filter with string operations; JSON filtering not directly supported.

**Opaque Types**: Custom or unsupported types use PostgreSQL's `to_json` method.

```sql
-- When using JSON, pass serialized strings:
UPDATE config SET data = '{"setting": "value"}' WHERE id = 1;
-- Don't try to update with structured JSON in GraphQL
```

### Use nodeId for Caching
Every record has a nodeId field (ID!) that's stable and can be used for caching.

```graphql
{
  blogCollection(first: 1) {
    edges {
      node {
        nodeId  # Stable identifier for caching
        id
        title
      }
    }
  }
}
```

## 7. Testing and Monitoring

### Use GraphiQL for Development
Test queries visually using the built-in GraphiQL interface (on Supabase) or GraphQL IDEs like Altair or Apollo Sandbox.

### Monitor Query Patterns
Watch for queries that:
- Request deeply nested relationships
- Have large result sets without pagination
- Use expensive filters on non-indexed columns

### Upgrade Carefully
Always test pg_graphql upgrades on a staging environment first.

```sql
-- Check versions
SELECT installed_version, default_version FROM graphql_public.graphql_versions();

-- Upgrade when ready
SELECT graphql_public.graphql_upgrade();
```

## 8. Common Patterns

### Paginated Collections
```graphql
{
  blogCollection(
    first: 10
    after: "cursor_from_previous_query"
    filter: { status: { eq: "PUBLISHED" } }
    orderBy: [{ createdAt: DescNullsLast }]
  ) {
    pageInfo {
      hasNextPage
      endCursor
    }
    edges {
      node { id title }
    }
  }
}
```

### Complex Filtering
```graphql
{
  postCollection(
    filter: {
      and: [
        { title: { ilike: "%tutorial%" } }
        { createdAt: { gte: "2024-01-01" } }
      ]
    }
  ) {
    edges { node { id title } }
  }
}
```

### Related Data Traversal
```graphql
{
  accountCollection {
    edges {
      node {
        id
        email
        blogs {  # Auto-generated from foreign key
          id
          name
          posts {  # Nested relationship
            id
            title
          }
        }
      }
    }
  }
}
```

## Summary

The key to pg_graphql success is leveraging PostgreSQL's built-in features: proper schema design with primary keys and foreign keys, permissions-based authorization, and comments for configuration. This results in a powerful, performant GraphQL API with minimal configuration overhead.




# pg_graphql with curl - Complete Guide

Using curl to query pg_graphql is useful for testing, automation, and debugging from the command line.

## Basic Setup

### Required Headers
Every request needs two headers:
- `Content-Type: application/json` - Tells server to expect JSON
- `apiKey` header (for Supabase) or `Authorization` header (for custom setups)

### Endpoint URL
For Supabase, use: `https://<PROJECT_REF>.supabase.co/graphql/v1`

Note: No trailing slash allowed.

## Simple Query Example

### Basic Structure
```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: your_api_key_here" \
  -d '{"query": "{ blogCollection { edges { node { id title } } } }"}' \
  https://your-project.supabase.co/graphql/v1
```

### With Authentication (JWT Token)
```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: your_api_key_here" \
  -H "Authorization: Bearer your_jwt_token_here" \
  -d '{"query": "{ accountCollection { edges { node { id email } } } }"}' \
  https://your-project.supabase.co/graphql/v1
```

## Real-World Examples

### 1. Query with Filtering

Get published blog posts with pagination:

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{
    "query": "query { blogCollection(first: 10, filter: {status: {eq: \"PUBLISHED\"}}) { edges { node { id title createdAt } } pageInfo { hasNextPage endCursor } } }"
  }' \
  https://your-project.supabase.co/graphql/v1
```

### 2. Query with Nested Relationships

Get users and their posts:

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{
    "query": "query { accountCollection { edges { node { id email blogs { id name posts { id title } } } } } }"
  }' \
  https://your-project.supabase.co/graphql/v1
```

### 3. Mutation - Insert Data

Create a new blog post:

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{
    "query": "mutation { insertIntoBlogCollection(objects: {title: \"My First Post\", content: \"Hello World\"}) { affectedCount records { id title } } }"
  }' \
  https://your-project.supabase.co/graphql/v1
```

### 4. Mutation - Update Data

Update an existing record:

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{
    "query": "mutation { updateBlogCollection(set: {status: \"PUBLISHED\"}, filter: {id: {eq: 123}}) { affectedCount } }"
  }' \
  https://your-project.supabase.co/graphql/v1
```

### 5. Mutation - Delete Data

Delete with safety check (atMost):

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{
    "query": "mutation { deleteFromBlogCollection(filter: {id: {eq: 123}}, atMost: 1) { affectedCount } }"
  }' \
  https://your-project.supabase.co/graphql/v1
```

## Making It Easier - Tips & Tricks

### 1. Save Your Credentials

Create a `.env` file to store credentials:

```bash
export API_KEY="eyJhbGc..."
export JWT_TOKEN="eyJhbGci..."
export ENDPOINT="https://your-project.supabase.co/graphql/v1"
```

Then source it:
```bash
source .env
```

### 2. Pretty-Print JSON Response

Use `jq` to format the output:

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{"query": "{ blogCollection { edges { node { id title } } } }"}' \
  ${ENDPOINT} | jq .
```

### 3. Save Query to a File

For complex queries, keep them readable by saving to a separate file:

**query.graphql:**
```graphql
query {
  blogCollection(first: 10) {
    edges {
      node {
        id
        title
        createdAt
        account {
          id
          email
        }
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```

**query.sh:**
```bash
#!/bin/bash
source .env

# Read query file and escape for JSON
QUERY=$(cat query.graphql | tr '\n' ' ')

curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d "$(jq -n --arg query "$QUERY" '{query: $query}')" \
  ${ENDPOINT} | jq .
```

Run with: `bash query.sh`

### 4. Use Variables (Recommended for Complex Queries)

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{
    "query": "query GetBlog($id: BigInt!) { blogCollection(filter: {id: {eq: $id}}) { edges { node { id title } } } }",
    "variables": {"id": 123}
  }' \
  ${ENDPOINT}
```

### 5. Debug - View Headers

Add `-i` flag to see response headers:

```bash
curl -i -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{"query": "{ blogCollection { edges { node { id } } } }"}' \
  ${ENDPOINT}
```

### 6. Debug - Verbose Output

Use `-v` for detailed connection info:

```bash
curl -v -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{"query": "{ blogCollection { edges { node { id } } } }"}' \
  ${ENDPOINT}
```

## Common Errors & Solutions

### Missing Content-Type Header
**Error:** `Content-Type: text/plain`

**Fix:** Add `-H "Content-Type: application/json"`

### Escaping Quotes in JSON

When embedding GraphQL in curl, escape inner quotes:

```bash
# ❌ Wrong - breaks JSON parsing
curl -d '{"query": "query { field }"}' ...

# ✅ Correct - uses double backslash
curl -d "{\"query\": \"query { field }\"}" ...

# ✅ Better - use jq to build JSON
curl -d "$(jq -n '{query: "query { field }"}')" ...
```

### Authorization Rejected
- Check API key format
- Verify JWT token hasn't expired
- Ensure `Authorization: Bearer` format (with space)
- Check if endpoints match (Supabase vs custom)

### 401 Unauthorized
Usually means invalid API key or expired JWT. Try:

```bash
# Test with apiKey only (no auth)
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{"query": "{ __typename }"}' \
  ${ENDPOINT}
```

## Full Script Example

**graphql_query.sh:**
```bash
#!/bin/bash

set -e  # Exit on error

API_KEY="${API_KEY:?API_KEY not set}"
ENDPOINT="${ENDPOINT:?ENDPOINT not set}"

# Accept query as first argument
QUERY="$1"

if [ -z "$QUERY" ]; then
  echo "Usage: $0 'GraphQL query'"
  exit 1
fi

echo "Executing query..."

curl -s -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d "$(jq -n --arg query "$QUERY" '{query: $query}')" \
  "${ENDPOINT}" | jq .

echo ""
```

Usage:
```bash
export API_KEY="your_key"
export ENDPOINT="https://your-project.supabase.co/graphql/v1"

bash graphql_query.sh '{ blogCollection { edges { node { id title } } } }'
```

## Introspection

Get the complete schema to understand available queries:

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: ${API_KEY}" \
  -d '{"query": "{ __schema { types { name } } }"}' \
  ${ENDPOINT} | jq .
```

## Useful Tools

For a better curl-like experience with GraphQL, consider:

- **graphqurl** (gq): `gq https://endpoint -H 'apiKey: xyz' -q 'query { ... }'`
- **Postman**: GUI for testing with GraphQL mode
- **GraphiQL**: Built-in IDE (available on Supabase Studio)
- **Altair**: Desktop/browser GraphQL client


Good question! Let me clarify what the `Authorization` header means and how it differs from the `apiKey` header.

## The Two Authentication Methods

**apiKey Header:**
- Used by Supabase's hosted GraphQL endpoint
- It's a simple API key that grants access to your endpoint
- Everyone using your Supabase project uses the same key (or different keys with different permissions)

**Authorization Header:**
- The standard HTTP authentication method used across the web
- Typically contains a JWT (JSON Web Token) that identifies *who* the user is
- Format: `Authorization: Bearer <token>`
- Used when you have user-specific authentication

## Real Example

Imagine you're building a blogging app:

```bash
# Anonymous user - just needs apiKey to access public data
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: anon_key_xyz" \
  -d '{"query": "{ blogCollection { edges { node { id title } } } }"}' \
  https://your-project.supabase.co/graphql/v1

# Logged-in user - needs both apiKey AND their JWT token
curl -X POST \
  -H "Content-Type: application/json" \
  -H "apiKey: anon_key_xyz" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{"query": "{ accountCollection { edges { node { id email } } } }"}' \
  https://your-project.supabase.co/graphql/v1
```

## How Authorization Works with Row-Level Security (RLS)

When you use `Authorization` with a JWT token, PostgreSQL's RLS policies can identify *which user* is making the request:

```sql
-- In your database, you can check who the user is
ALTER TABLE account ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see their own account" ON account
  FOR SELECT USING (id = auth.uid());
```

The JWT token contains the user's ID, so when the user queries:

```bash
curl -X POST \
  -H "Authorization: Bearer jwt_token_for_user_123" \
  -d '{"query": "{ accountCollection { edges { node { id email } } } }"}' \
  https://your-project.supabase.co/graphql/v1
```

The database automatically filters results to only show user 123's account (even if they try to query other users' data).

## Why "For Custom Setups"?

If you're building pg_graphql into:
- **Your own server** (not Supabase)
- **A self-hosted PostgreSQL instance**
- **A custom authentication system**

Then you might generate and pass JWT tokens directly via the `Authorization` header instead of relying on Supabase's `apiKey` system.

## Summary

| Aspect | apiKey | Authorization (JWT) |
|--------|--------|---------------------|
| Purpose | Identify *which project/app* | Identify *which user* |
| Format | Simple string | `Bearer <token>` |
| Use case | Any request that needs access | Requests from specific users |
| With RLS | Can use role-based policies | Can identify exact user (auth.uid()) |
| Example | `anon_key_xyz` | `eyJhbGciOiJIUzI1NiIs...` |

Does that clarify the difference? Would you like to know how to generate JWT tokens or set up custom authorization?
