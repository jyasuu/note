Here are the best practices for using Spring Boot WebFlux with Reactor Test:

## Project Setup

**Dependencies in your `pom.xml`:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>
```

## Controller Best Practices

**Use proper reactive types:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    // Return Mono for single items
    @GetMapping("/{id}")
    public Mono<User> getUser(@PathVariable String id) {
        return userService.findById(id);
    }
    
    // Return Flux for collections
    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll();
    }
    
    // Handle backpressure with proper error handling
    @PostMapping
    public Mono<User> createUser(@RequestBody User user) {
        return userService.save(user)
            .onErrorMap(DataIntegrityException.class, 
                ex -> new BadRequestException("Invalid user data"));
    }
}
```

## Service Layer Best Practices

**Compose reactive streams properly:**
```java
@Service
public class UserService {
    
    private final UserRepository repository;
    private final NotificationService notificationService;
    
    public Mono<User> createUser(User user) {
        return repository.save(user)
            .flatMap(savedUser -> 
                notificationService.sendWelcomeEmail(savedUser)
                    .then(Mono.just(savedUser)) // Return the user after email
            )
            .doOnSuccess(user -> log.info("User created: {}", user.getId()))
            .doOnError(error -> log.error("Failed to create user", error));
    }
    
    // Use switchIfEmpty for default values
    public Mono<User> findByIdWithDefault(String id) {
        return repository.findById(id)
            .switchIfEmpty(Mono.just(User.defaultUser()));
    }
}
```

## Testing Best Practices with Reactor Test

**Use StepVerifier for testing reactive streams:**## Configuration Best Practices

**WebFlux Configuration:**
```java
@Configuration
@EnableWebFlux
public class WebFluxConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().maxInMemorySize(1024 * 1024); // 1MB
    }

    @Bean
    public RouterFunction<ServerResponse> routes(UserHandler userHandler) {
        return RouterFunctions
            .route(GET("/api/users/{id}"), userHandler::getUser)
            .andRoute(GET("/api/users"), userHandler::getAllUsers)
            .andRoute(POST("/api/users"), userHandler::createUser);
    }
}
```

## Error Handling Best Practices

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BadRequestException.class)
    public Mono<ResponseEntity<ErrorResponse>> handleBadRequest(BadRequestException ex) {
        return Mono.just(ResponseEntity.badRequest()
            .body(new ErrorResponse("BAD_REQUEST", ex.getMessage())));
    }

    @ExceptionHandler(Exception.class)
    public Mono<ResponseEntity<ErrorResponse>> handleGeneral(Exception ex) {
        return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(new ErrorResponse("INTERNAL_ERROR", "Something went wrong")));
    }
}
```

## Key Testing Principles

1. **Use StepVerifier** for all reactive stream testing
2. **Test both happy path and error scenarios**
3. **Use WebTestClient** for integration testing
4. **Test backpressure handling** with controlled demand
5. **Use virtual time** for time-based operations
6. **Test timeout scenarios** explicitly
7. **Verify subscription and cancellation** behavior
8. **Use TestPublisher** for controlled upstream behavior

## Performance Considerations

- Set appropriate buffer sizes and backpressure strategies
- Use `publishOn()` and `subscribeOn()` judiciously
- Configure proper thread pools for blocking operations
- Monitor reactive stream metrics
- Use connection pooling for database operations

These practices will help you build robust, testable reactive applications with Spring WebFlux and ensure your reactive streams behave correctly under various conditions.



```java
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.web.reactive.server.WebTestClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;
import reactor.test.publisher.TestPublisher;

import java.time.Duration;

@WebFluxTest(UserController.class)
class UserControllerTest {

    @MockBean
    private UserService userService;
    
    private WebTestClient webTestClient;

    // 1. Testing Controllers with WebTestClient
    @Test
    void shouldGetUser() {
        User expectedUser = new User("1", "John", "john@example.com");
        when(userService.findById("1")).thenReturn(Mono.just(expectedUser));

        webTestClient.get()
            .uri("/api/users/1")
            .exchange()
            .expectStatus().isOk()
            .expectBody(User.class)
            .isEqualTo(expectedUser);
    }

    @Test
    void shouldHandleNotFound() {
        when(userService.findById("999")).thenReturn(Mono.empty());

        webTestClient.get()
            .uri("/api/users/999")
            .exchange()
            .expectStatus().isNotFound();
    }

    // 2. Testing Services with StepVerifier
    @Test
    void shouldCreateUserSuccessfully() {
        User inputUser = new User(null, "Jane", "jane@example.com");
        User savedUser = new User("2", "Jane", "jane@example.com");
        
        when(userRepository.save(inputUser)).thenReturn(Mono.just(savedUser));
        when(notificationService.sendWelcomeEmail(savedUser)).thenReturn(Mono.empty());

        Mono<User> result = userService.createUser(inputUser);

        StepVerifier.create(result)
            .expectNext(savedUser)
            .verifyComplete();
    }

    // 3. Testing Error Scenarios
    @Test
    void shouldHandleServiceError() {
        User inputUser = new User(null, "Invalid", "invalid-email");
        
        when(userRepository.save(inputUser))
            .thenReturn(Mono.error(new DataIntegrityException("Email format invalid")));

        Mono<User> result = userService.createUser(inputUser);

        StepVerifier.create(result)
            .expectError(BadRequestException.class)
            .verify();
    }

    // 4. Testing Flux streams
    @Test
    void shouldStreamAllUsers() {
        Flux<User> userFlux = Flux.just(
            new User("1", "John", "john@example.com"),
            new User("2", "Jane", "jane@example.com"),
            new User("3", "Bob", "bob@example.com")
        );

        when(userService.findAll()).thenReturn(userFlux);

        StepVerifier.create(userService.findAll())
            .expectNextCount(3)
            .verifyComplete();
    }

    // 5. Testing with delays and timeouts
    @Test
    void shouldHandleTimeout() {
        when(userService.findById("slow"))
            .thenReturn(Mono.just(new User("slow", "Slow User", "slow@example.com"))
                .delayElement(Duration.ofSeconds(2)));

        StepVerifier.create(userService.findById("slow").timeout(Duration.ofSeconds(1)))
            .expectError(TimeoutException.class)
            .verify();
    }

    // 6. Testing backpressure
    @Test
    void shouldHandleBackpressure() {
        Flux<User> manyUsers = Flux.range(1, 1000)
            .map(i -> new User(String.valueOf(i), "User" + i, "user" + i + "@example.com"));

        StepVerifier.create(manyUsers, 10) // Request only 10 items initially
            .expectNextCount(10)
            .thenRequest(990) // Request the remaining
            .expectNextCount(990)
            .verifyComplete();
    }

    // 7. Using TestPublisher for controlled testing
    @Test
    void shouldHandleUpstreamErrors() {
        TestPublisher<User> testPublisher = TestPublisher.create();
        
        Flux<String> userNames = testPublisher.flux()
            .map(User::getName)
            .onErrorReturn("Unknown");

        StepVerifier.create(userNames)
            .then(() -> testPublisher.next(new User("1", "John", "john@example.com")))
            .expectNext("John")
            .then(() -> testPublisher.error(new RuntimeException("Database error")))
            .expectNext("Unknown")
            .verifyComplete();
    }

    // 8. Testing with virtual time
    @Test
    void shouldTestPeriodicEmissions() {
        StepVerifier.withVirtualTime(() -> 
            Flux.interval(Duration.ofHours(1))
                .take(3)
        )
        .expectSubscription()
        .expectNoEvent(Duration.ofHours(1))
        .expectNext(0L)
        .thenAwait(Duration.ofHours(1))
        .expectNext(1L)
        .thenAwait(Duration.ofHours(1))
        .expectNext(2L)
        .verifyComplete();
    }
}

// Additional Service Testing Examples
class UserServiceTest {

    @Test
    void shouldCombineMultipleStreams() {
        Flux<User> users = Flux.just(
            new User("1", "John", "john@example.com"),
            new User("2", "Jane", "jane@example.com")
        );
        
        Flux<Profile> profiles = Flux.just(
            new Profile("1", "Developer"),
            new Profile("2", "Designer")
        );

        Flux<UserWithProfile> combined = Flux.zip(users, profiles, UserWithProfile::new);

        StepVerifier.create(combined)
            .assertNext(uwp -> {
                assertThat(uwp.getUser().getName()).isEqualTo("John");
                assertThat(uwp.getProfile().getRole()).isEqualTo("Developer");
            })
            .assertNext(uwp -> {
                assertThat(uwp.getUser().getName()).isEqualTo("Jane");
                assertThat(uwp.getProfile().getRole()).isEqualTo("Designer");
            })
            .verifyComplete();
    }

    @Test
    void shouldTestRetryMechanism() {
        AtomicInteger attempts = new AtomicInteger(0);
        
        Mono<String> flakyOperation = Mono.fromCallable(() -> {
            if (attempts.incrementAndGet() < 3) {
                throw new RuntimeException("Temporary failure");
            }
            return "Success";
        });

        Mono<String> withRetry = flakyOperation.retry(3);

        StepVerifier.create(withRetry)
            .expectNext("Success")
            .verifyComplete();
            
        assertThat(attempts.get()).isEqualTo(3);
    }

    @Test
    void shouldTestCircuitBreakerPattern() {
        CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("test");
        
        Mono<String> protectedCall = Mono.fromCallable(() -> "Success")
            .transformDeferred(CircuitBreakerOperator.of(circuitBreaker));

        StepVerifier.create(protectedCall)
            .expectNext("Success")
            .verifyComplete();
    }
}
```
