Here are the best practices for using Spring Boot WebFlux with Reactor Test:

## Project Setup

**Dependencies in your `pom.xml`:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>
```

## Controller Best Practices

**Use proper reactive types:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    // Return Mono for single items
    @GetMapping("/{id}")
    public Mono<User> getUser(@PathVariable String id) {
        return userService.findById(id);
    }
    
    // Return Flux for collections
    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll();
    }
    
    // Handle backpressure with proper error handling
    @PostMapping
    public Mono<User> createUser(@RequestBody User user) {
        return userService.save(user)
            .onErrorMap(DataIntegrityException.class, 
                ex -> new BadRequestException("Invalid user data"));
    }
}
```

## Service Layer Best Practices

**Compose reactive streams properly:**
```java
@Service
public class UserService {
    
    private final UserRepository repository;
    private final NotificationService notificationService;
    
    public Mono<User> createUser(User user) {
        return repository.save(user)
            .flatMap(savedUser -> 
                notificationService.sendWelcomeEmail(savedUser)
                    .then(Mono.just(savedUser)) // Return the user after email
            )
            .doOnSuccess(user -> log.info("User created: {}", user.getId()))
            .doOnError(error -> log.error("Failed to create user", error));
    }
    
    // Use switchIfEmpty for default values
    public Mono<User> findByIdWithDefault(String id) {
        return repository.findById(id)
            .switchIfEmpty(Mono.just(User.defaultUser()));
    }
}
```

## Testing Best Practices with Reactor Test

**Use StepVerifier for testing reactive streams:**## Configuration Best Practices

**WebFlux Configuration:**
```java
@Configuration
@EnableWebFlux
public class WebFluxConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().maxInMemorySize(1024 * 1024); // 1MB
    }

    @Bean
    public RouterFunction<ServerResponse> routes(UserHandler userHandler) {
        return RouterFunctions
            .route(GET("/api/users/{id}"), userHandler::getUser)
            .andRoute(GET("/api/users"), userHandler::getAllUsers)
            .andRoute(POST("/api/users"), userHandler::createUser);
    }
}
```

## Error Handling Best Practices

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BadRequestException.class)
    public Mono<ResponseEntity<ErrorResponse>> handleBadRequest(BadRequestException ex) {
        return Mono.just(ResponseEntity.badRequest()
            .body(new ErrorResponse("BAD_REQUEST", ex.getMessage())));
    }

    @ExceptionHandler(Exception.class)
    public Mono<ResponseEntity<ErrorResponse>> handleGeneral(Exception ex) {
        return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(new ErrorResponse("INTERNAL_ERROR", "Something went wrong")));
    }
}
```

## Key Testing Principles

1. **Use StepVerifier** for all reactive stream testing
2. **Test both happy path and error scenarios**
3. **Use WebTestClient** for integration testing
4. **Test backpressure handling** with controlled demand
5. **Use virtual time** for time-based operations
6. **Test timeout scenarios** explicitly
7. **Verify subscription and cancellation** behavior
8. **Use TestPublisher** for controlled upstream behavior

## Performance Considerations

- Set appropriate buffer sizes and backpressure strategies
- Use `publishOn()` and `subscribeOn()` judiciously
- Configure proper thread pools for blocking operations
- Monitor reactive stream metrics
- Use connection pooling for database operations

These practices will help you build robust, testable reactive applications with Spring WebFlux and ensure your reactive streams behave correctly under various conditions.



```java
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.web.reactive.server.WebTestClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;
import reactor.test.publisher.TestPublisher;

import java.time.Duration;

@WebFluxTest(UserController.class)
class UserControllerTest {

    @MockBean
    private UserService userService;
    
    private WebTestClient webTestClient;

    // 1. Testing Controllers with WebTestClient
    @Test
    void shouldGetUser() {
        User expectedUser = new User("1", "John", "john@example.com");
        when(userService.findById("1")).thenReturn(Mono.just(expectedUser));

        webTestClient.get()
            .uri("/api/users/1")
            .exchange()
            .expectStatus().isOk()
            .expectBody(User.class)
            .isEqualTo(expectedUser);
    }

    @Test
    void shouldHandleNotFound() {
        when(userService.findById("999")).thenReturn(Mono.empty());

        webTestClient.get()
            .uri("/api/users/999")
            .exchange()
            .expectStatus().isNotFound();
    }

    // 2. Testing Services with StepVerifier
    @Test
    void shouldCreateUserSuccessfully() {
        User inputUser = new User(null, "Jane", "jane@example.com");
        User savedUser = new User("2", "Jane", "jane@example.com");
        
        when(userRepository.save(inputUser)).thenReturn(Mono.just(savedUser));
        when(notificationService.sendWelcomeEmail(savedUser)).thenReturn(Mono.empty());

        Mono<User> result = userService.createUser(inputUser);

        StepVerifier.create(result)
            .expectNext(savedUser)
            .verifyComplete();
    }

    // 3. Testing Error Scenarios
    @Test
    void shouldHandleServiceError() {
        User inputUser = new User(null, "Invalid", "invalid-email");
        
        when(userRepository.save(inputUser))
            .thenReturn(Mono.error(new DataIntegrityException("Email format invalid")));

        Mono<User> result = userService.createUser(inputUser);

        StepVerifier.create(result)
            .expectError(BadRequestException.class)
            .verify();
    }

    // 4. Testing Flux streams
    @Test
    void shouldStreamAllUsers() {
        Flux<User> userFlux = Flux.just(
            new User("1", "John", "john@example.com"),
            new User("2", "Jane", "jane@example.com"),
            new User("3", "Bob", "bob@example.com")
        );

        when(userService.findAll()).thenReturn(userFlux);

        StepVerifier.create(userService.findAll())
            .expectNextCount(3)
            .verifyComplete();
    }

    // 5. Testing with delays and timeouts
    @Test
    void shouldHandleTimeout() {
        when(userService.findById("slow"))
            .thenReturn(Mono.just(new User("slow", "Slow User", "slow@example.com"))
                .delayElement(Duration.ofSeconds(2)));

        StepVerifier.create(userService.findById("slow").timeout(Duration.ofSeconds(1)))
            .expectError(TimeoutException.class)
            .verify();
    }

    // 6. Testing backpressure
    @Test
    void shouldHandleBackpressure() {
        Flux<User> manyUsers = Flux.range(1, 1000)
            .map(i -> new User(String.valueOf(i), "User" + i, "user" + i + "@example.com"));

        StepVerifier.create(manyUsers, 10) // Request only 10 items initially
            .expectNextCount(10)
            .thenRequest(990) // Request the remaining
            .expectNextCount(990)
            .verifyComplete();
    }

    // 7. Using TestPublisher for controlled testing
    @Test
    void shouldHandleUpstreamErrors() {
        TestPublisher<User> testPublisher = TestPublisher.create();
        
        Flux<String> userNames = testPublisher.flux()
            .map(User::getName)
            .onErrorReturn("Unknown");

        StepVerifier.create(userNames)
            .then(() -> testPublisher.next(new User("1", "John", "john@example.com")))
            .expectNext("John")
            .then(() -> testPublisher.error(new RuntimeException("Database error")))
            .expectNext("Unknown")
            .verifyComplete();
    }

    // 8. Testing with virtual time
    @Test
    void shouldTestPeriodicEmissions() {
        StepVerifier.withVirtualTime(() -> 
            Flux.interval(Duration.ofHours(1))
                .take(3)
        )
        .expectSubscription()
        .expectNoEvent(Duration.ofHours(1))
        .expectNext(0L)
        .thenAwait(Duration.ofHours(1))
        .expectNext(1L)
        .thenAwait(Duration.ofHours(1))
        .expectNext(2L)
        .verifyComplete();
    }
}

// Additional Service Testing Examples
class UserServiceTest {

    @Test
    void shouldCombineMultipleStreams() {
        Flux<User> users = Flux.just(
            new User("1", "John", "john@example.com"),
            new User("2", "Jane", "jane@example.com")
        );
        
        Flux<Profile> profiles = Flux.just(
            new Profile("1", "Developer"),
            new Profile("2", "Designer")
        );

        Flux<UserWithProfile> combined = Flux.zip(users, profiles, UserWithProfile::new);

        StepVerifier.create(combined)
            .assertNext(uwp -> {
                assertThat(uwp.getUser().getName()).isEqualTo("John");
                assertThat(uwp.getProfile().getRole()).isEqualTo("Developer");
            })
            .assertNext(uwp -> {
                assertThat(uwp.getUser().getName()).isEqualTo("Jane");
                assertThat(uwp.getProfile().getRole()).isEqualTo("Designer");
            })
            .verifyComplete();
    }

    @Test
    void shouldTestRetryMechanism() {
        AtomicInteger attempts = new AtomicInteger(0);
        
        Mono<String> flakyOperation = Mono.fromCallable(() -> {
            if (attempts.incrementAndGet() < 3) {
                throw new RuntimeException("Temporary failure");
            }
            return "Success";
        });

        Mono<String> withRetry = flakyOperation.retry(3);

        StepVerifier.create(withRetry)
            .expectNext("Success")
            .verifyComplete();
            
        assertThat(attempts.get()).isEqualTo(3);
    }

    @Test
    void shouldTestCircuitBreakerPattern() {
        CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("test");
        
        Mono<String> protectedCall = Mono.fromCallable(() -> "Success")
            .transformDeferred(CircuitBreakerOperator.of(circuitBreaker));

        StepVerifier.create(protectedCall)
            .expectNext("Success")
            .verifyComplete();
    }
}
```



I'll help you with Spring WebFlux best practices. Here are the key areas to focus on for building reactive applications with Spring Boot WebFlux:

## Project Setup and Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-r2dbc</artifactId>
</dependency>
```

## Controller Best Practices

**Use reactive return types consistently:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public Mono<ResponseEntity<User>> getUser(@PathVariable String id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }
    
    @GetMapping
    public Flux<User> getAllUsers(@RequestParam(defaultValue = "0") int page) {
        return userService.findAll(PageRequest.of(page, 20));
    }
    
    @PostMapping
    public Mono<ResponseEntity<User>> createUser(@Valid @RequestBody User user) {
        return userService.save(user)
            .map(savedUser -> ResponseEntity.status(HttpStatus.CREATED).body(savedUser))
            .onErrorMap(ValidationException.class, 
                ex -> new ResponseStatusException(HttpStatus.BAD_REQUEST, ex.getMessage()));
    }
}
```

## Service Layer Patterns

**Reactive service with proper error handling:**
```java
@Service
@Transactional
public class UserService {
    
    private final UserRepository userRepository;
    private final WebClient webClient;
    
    public Mono<User> findById(String id) {
        return userRepository.findById(id)
            .switchIfEmpty(Mono.error(new UserNotFoundException("User not found: " + id)))
            .doOnSuccess(user -> log.info("Found user: {}", user.getId()))
            .doOnError(ex -> log.error("Error finding user: {}", id, ex));
    }
    
    public Mono<User> enrichUserWithExternalData(User user) {
        return webClient.get()
            .uri("/external/user/{id}", user.getId())
            .retrieve()
            .bodyToMono(ExternalUserData.class)
            .map(externalData -> user.withExternalData(externalData))
            .timeout(Duration.ofSeconds(5))
            .retry(3)
            .onErrorReturn(user); // Fallback to original user
    }
}
```

## WebClient Configuration

**Proper WebClient setup:**
```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder()
            .baseUrl("https://api.external-service.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .clientConnector(new ReactorClientHttpConnector(
                HttpClient.create()
                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
                    .responseTimeout(Duration.ofSeconds(10))
                    .keepAlive(true)
            ))
            .filter(ExchangeFilterFunction.ofRequestProcessor(
                clientRequest -> {
                    log.info("Request: {} {}", clientRequest.method(), clientRequest.url());
                    return Mono.just(clientRequest);
                }
            ))
            .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(1024 * 1024))
            .build();
    }
}
```

## Error Handling

**Global error handler:**
```java
@Component
@Order(-2)
public class GlobalErrorHandler implements WebExceptionHandler {
    
    @Override
    public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
        ServerHttpResponse response = exchange.getResponse();
        response.getHeaders().add("Content-Type", "application/json");
        
        String body;
        if (ex instanceof UserNotFoundException) {
            response.setStatusCode(HttpStatus.NOT_FOUND);
            body = """
                {"error": "User not found", "message": "%s"}
                """.formatted(ex.getMessage());
        } else if (ex instanceof ValidationException) {
            response.setStatusCode(HttpStatus.BAD_REQUEST);
            body = """
                {"error": "Validation failed", "message": "%s"}
                """.formatted(ex.getMessage());
        } else {
            response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);
            body = """
                {"error": "Internal server error"}
                """;
        }
        
        DataBuffer buffer = response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));
        return response.writeWith(Mono.just(buffer));
    }
}
```

## Key Best Practices

**1. Never Block in Reactive Streams**
```java
// ❌ Don't do this
public Mono<User> badExample(String id) {
    User user = userRepository.findById(id).block(); // Blocking!
    return Mono.just(user);
}

// ✅ Do this instead
public Mono<User> goodExample(String id) {
    return userRepository.findById(id)
        .map(this::enrichUser);
}
```

**2. Use Proper Backpressure Handling**
```java
public Flux<ProcessedData> processLargeDataset() {
    return dataRepository.findAll()
        .buffer(100) // Process in batches
        .flatMap(batch -> processDataBatch(batch), 2) // Limit concurrency
        .onBackpressureBuffer(1000); // Handle backpressure
}
```

**3. Resource Management**
```java
@Configuration
public class ReactorConfig {
    
    @PostConstruct
    public void configureReactor() {
        // Configure schedulers
        Schedulers.enableMetrics();
        
        // Set up proper thread pools
        System.setProperty("reactor.netty.ioWorkerCount", "4");
        System.setProperty("reactor.netty.ioSelectCount", "2");
    }
}
```

**4. Testing Reactive Code**
```java
@WebFluxTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @MockBean
    private UserService userService;
    
    @Test
    void shouldReturnUser() {
        User user = new User("1", "John");
        when(userService.findById("1")).thenReturn(Mono.just(user));
        
        webTestClient.get()
            .uri("/api/users/1")
            .exchange()
            .expectStatus().isOk()
            .expectBody(User.class)
            .isEqualTo(user);
    }
    
    @Test
    void shouldHandleUserNotFound() {
        when(userService.findById("999"))
            .thenReturn(Mono.error(new UserNotFoundException("User not found")));
        
        webTestClient.get()
            .uri("/api/users/999")
            .exchange()
            .expectStatus().isNotFound();
    }
}
```

**5. Monitoring and Observability**
```java
@Configuration
public class MetricsConfig {
    
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags("application", "webflux-service");
    }
}
```

## Performance Considerations

- Use appropriate reactive repositories (R2DBC, Reactive MongoDB)
- Configure connection pooling properly
- Implement proper timeout strategies
- Use reactive caching when appropriate
- Monitor memory usage and avoid memory leaks in long-running streams

These practices will help you build robust, performant, and maintainable reactive applications with Spring WebFlux. The key is embracing the reactive paradigm throughout your entire application stack.



I'll show you different authentication strategies for WebClient configuration in Spring WebFlux. Here are the most common approaches:

## 1. Basic Authentication

```java
@Configuration
public class BasicAuthWebClientConfig {
    
    @Bean
    @Qualifier("basicAuthWebClient")
    public WebClient basicAuthWebClient() {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .defaultHeaders(headers -> headers.setBasicAuth("username", "password"))
            .build();
    }
    
    // Alternative: Dynamic basic auth
    @Bean
    @Qualifier("dynamicBasicAuthWebClient") 
    public WebClient dynamicBasicAuthWebClient() {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .filter(ExchangeFilterFunction.ofRequestProcessor(request -> {
                String credentials = Base64.getEncoder()
                    .encodeToString("username:password".getBytes(StandardCharsets.UTF_8));
                return Mono.just(ClientRequest.from(request)
                    .header("Authorization", "Basic " + credentials)
                    .build());
            }))
            .build();
    }
}
```

## 2. Bearer Token Authentication

```java
@Configuration
public class BearerTokenWebClientConfig {
    
    @Value("${api.token}")
    private String apiToken;
    
    @Bean
    @Qualifier("bearerTokenWebClient")
    public WebClient bearerTokenWebClient() {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + apiToken)
            .build();
    }
    
    // Dynamic bearer token with refresh capability
    @Bean
    @Qualifier("dynamicBearerWebClient")
    public WebClient dynamicBearerWebClient(TokenService tokenService) {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .filter(bearerTokenFilter(tokenService))
            .build();
    }
    
    private ExchangeFilterFunction bearerTokenFilter(TokenService tokenService) {
        return ExchangeFilterFunction.ofRequestProcessor(request -> 
            tokenService.getValidToken()
                .map(token -> ClientRequest.from(request)
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                    .build())
        );
    }
}
```

## 3. OAuth2 Client Credentials Flow

```java
@Configuration
@EnableWebFluxSecurity
public class OAuth2WebClientConfig {
    
    @Bean
    @Qualifier("oauth2WebClient")
    public WebClient oauth2WebClient(ReactiveClientRegistrationRepository clientRegistrations,
                                   ServerOAuth2AuthorizedClientRepository authorizedClients) {
        
        ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Filter = 
            new ServerOAuth2AuthorizedClientExchangeFilterFunction(
                clientRegistrations, authorizedClients);
        
        oauth2Filter.setDefaultClientRegistrationId("my-client");
        
        return WebClient.builder()
            .baseUrl("https://api.protected-service.com")
            .filter(oauth2Filter)
            .build();
    }
    
    @Bean
    public ReactiveClientRegistrationRepository clientRegistrations() {
        ClientRegistration registration = ClientRegistration
            .withRegistrationId("my-client")
            .tokenUri("https://oauth-provider.com/token")
            .clientId("your-client-id")
            .clientSecret("your-client-secret")
            .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
            .scope("read", "write")
            .build();
            
        return new InMemoryReactiveClientRegistrationRepository(registration);
    }
}
```

## 4. JWT Token with Auto-Refresh

```java
@Component
public class JwtTokenService {
    
    private final WebClient authWebClient;
    private volatile String cachedToken;
    private volatile Instant tokenExpiry;
    
    public JwtTokenService() {
        this.authWebClient = WebClient.builder()
            .baseUrl("https://auth.service.com")
            .build();
    }
    
    public Mono<String> getValidToken() {
        if (isTokenValid()) {
            return Mono.just(cachedToken);
        }
        return refreshToken();
    }
    
    private Mono<String> refreshToken() {
        return authWebClient.post()
            .uri("/oauth/token")
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .body(BodyInserters.fromFormData("grant_type", "client_credentials")
                .with("client_id", "your-client-id")
                .with("client_secret", "your-client-secret"))
            .retrieve()
            .bodyToMono(TokenResponse.class)
            .doOnNext(this::cacheToken)
            .map(TokenResponse::getAccessToken)
            .cache(Duration.ofMinutes(50)); // Cache for slightly less than token expiry
    }
    
    private boolean isTokenValid() {
        return cachedToken != null && 
               tokenExpiry != null && 
               Instant.now().isBefore(tokenExpiry.minusSeconds(60)); // 1 minute buffer
    }
    
    private void cacheToken(TokenResponse response) {
        this.cachedToken = response.getAccessToken();
        this.tokenExpiry = Instant.now().plusSeconds(response.getExpiresIn());
    }
}

@Configuration
public class JwtWebClientConfig {
    
    @Bean
    @Qualifier("jwtWebClient")
    public WebClient jwtWebClient(JwtTokenService tokenService) {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .filter(jwtTokenFilter(tokenService))
            .build();
    }
    
    private ExchangeFilterFunction jwtTokenFilter(JwtTokenService tokenService) {
        return ExchangeFilterFunction.ofRequestProcessor(request ->
            tokenService.getValidToken()
                .map(token -> ClientRequest.from(request)
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                    .build())
                .onErrorMap(ex -> new RuntimeException("Failed to obtain JWT token", ex))
        );
    }
}
```

## 5. API Key Authentication

```java
@Configuration
public class ApiKeyWebClientConfig {
    
    @Value("${api.key}")
    private String apiKey;
    
    @Bean
    @Qualifier("apiKeyWebClient")
    public WebClient apiKeyWebClient() {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .defaultHeader("X-API-Key", apiKey)
            .build();
    }
    
    // Multiple API key strategies
    @Bean
    @Qualifier("multiApiKeyWebClient")
    public WebClient multiApiKeyWebClient() {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .filter(ExchangeFilterFunction.ofRequestProcessor(request -> {
                String path = request.url().getPath();
                String apiKey = getApiKeyForPath(path);
                
                return Mono.just(ClientRequest.from(request)
                    .header("X-API-Key", apiKey)
                    .build());
            }))
            .build();
    }
    
    private String getApiKeyForPath(String path) {
        // Logic to determine API key based on path
        if (path.startsWith("/v1/")) {
            return "api-key-v1";
        } else if (path.startsWith("/v2/")) {
            return "api-key-v2";
        }
        return "default-api-key";
    }
}
```

## 6. Mutual TLS (mTLS) Authentication

```java
@Configuration
public class MutualTlsWebClientConfig {
    
    @Bean
    @Qualifier("mtlsWebClient")
    public WebClient mtlsWebClient() throws Exception {
        
        // Load client certificate and private key
        KeyStore keyStore = loadKeyStore("client-keystore.p12", "keystore-password");
        KeyStore trustStore = loadKeyStore("truststore.p12", "truststore-password");
        
        SslContext sslContext = SslContextBuilder.forClient()
            .keyManager(getKeyManagerFactory(keyStore, "keystore-password"))
            .trustManager(getTrustManagerFactory(trustStore))
            .build();
        
        HttpClient httpClient = HttpClient.create()
            .secure(spec -> spec.sslContext(sslContext));
        
        return WebClient.builder()
            .baseUrl("https://secure-api.service.com")
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .build();
    }
    
    private KeyStore loadKeyStore(String path, String password) throws Exception {
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        try (InputStream inputStream = getClass().getClassLoader().getResourceAsStream(path)) {
            keyStore.load(inputStream, password.toCharArray());
        }
        return keyStore;
    }
    
    private KeyManagerFactory getKeyManagerFactory(KeyStore keyStore, String password) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm());
        keyManagerFactory.init(keyStore, password.toCharArray());
        return keyManagerFactory;
    }
    
    private TrustManagerFactory getTrustManagerFactory(KeyStore trustStore) throws Exception {
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(trustStore);
        return trustManagerFactory;
    }
}
```

## 7. Custom Authentication Header

```java
@Configuration
public class CustomAuthWebClientConfig {
    
    @Bean
    @Qualifier("customAuthWebClient")
    public WebClient customAuthWebClient(CustomAuthService authService) {
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .filter(customAuthFilter(authService))
            .build();
    }
    
    private ExchangeFilterFunction customAuthFilter(CustomAuthService authService) {
        return ExchangeFilterFunction.ofRequestProcessor(request -> 
            authService.generateAuthSignature(request)
                .map(signature -> ClientRequest.from(request)
                    .header("X-Custom-Auth", signature)
                    .header("X-Timestamp", String.valueOf(System.currentTimeMillis()))
                    .build())
        );
    }
}

@Service
public class CustomAuthService {
    
    @Value("${api.secret}")
    private String apiSecret;
    
    public Mono<String> generateAuthSignature(ClientRequest request) {
        return Mono.fromCallable(() -> {
            String method = request.method().name();
            String path = request.url().getPath();
            String timestamp = String.valueOf(System.currentTimeMillis());
            String payload = method + path + timestamp;
            
            return hmacSha256(payload, apiSecret);
        });
    }
    
    private String hmacSha256(String data, String key) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), "HmacSHA256");
            mac.init(secretKeySpec);
            byte[] hash = mac.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate HMAC signature", e);
        }
    }
}
```

## 8. Conditional Authentication

```java
@Configuration
public class ConditionalAuthWebClientConfig {
    
    @Bean
    @Qualifier("conditionalAuthWebClient")
    public WebClient conditionalAuthWebClient(
            @Qualifier("basicAuthWebClient") WebClient basicAuthWebClient,
            @Qualifier("bearerTokenWebClient") WebClient bearerTokenWebClient,
            @Qualifier("apiKeyWebClient") WebClient apiKeyWebClient) {
        
        return WebClient.builder()
            .baseUrl("https://api.service.com")
            .filter(conditionalAuthFilter())
            .build();
    }
    
    private ExchangeFilterFunction conditionalAuthFilter() {
        return ExchangeFilterFunction.ofRequestProcessor(request -> {
            String path = request.url().getPath();
            
            if (path.startsWith("/public/")) {
                return Mono.just(request); // No auth needed
            } else if (path.startsWith("/basic/")) {
                return Mono.just(ClientRequest.from(request)
                    .header(HttpHeaders.AUTHORIZATION, "Basic " + getBasicAuthToken())
                    .build());
            } else if (path.startsWith("/oauth/")) {
                return getOAuthToken()
                    .map(token -> ClientRequest.from(request)
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                        .build());
            } else {
                return Mono.just(ClientRequest.from(request)
                    .header("X-API-Key", getApiKey())
                    .build());
            }
        });
    }
    
    // Helper methods
    private String getBasicAuthToken() { /* implementation */ return ""; }
    private Mono<String> getOAuthToken() { /* implementation */ return Mono.just(""); }
    private String getApiKey() { /* implementation */ return ""; }
}
```

## Usage Examples

```java
@Service
public class ExternalApiService {
    
    private final WebClient basicAuthWebClient;
    private final WebClient bearerTokenWebClient;
    private final WebClient oauth2WebClient;
    
    public ExternalApiService(
            @Qualifier("basicAuthWebClient") WebClient basicAuthWebClient,
            @Qualifier("bearerTokenWebClient") WebClient bearerTokenWebClient,
            @Qualifier("oauth2WebClient") WebClient oauth2WebClient) {
        this.basicAuthWebClient = basicAuthWebClient;
        this.bearerTokenWebClient = bearerTokenWebClient;
        this.oauth2WebClient = oauth2WebClient;
    }
    
    public Mono<String> callBasicAuthEndpoint() {
        return basicAuthWebClient.get()
            .uri("/secure-data")
            .retrieve()
            .bodyToMono(String.class);
    }
    
    public Mono<UserData> callOAuthEndpoint() {
        return oauth2WebClient.get()
            .uri("/user-profile")
            .retrieve()
            .bodyToMono(UserData.class)
            .timeout(Duration.ofSeconds(10))
            .retry(2);
    }
}
```

## Configuration Properties

```yaml
# application.yml
api:
  token: ${API_TOKEN:default-token}
  key: ${API_KEY:default-key}
  secret: ${API_SECRET:default-secret}

spring:
  security:
    oauth2:
      client:
        registration:
          my-client:
            client-id: ${OAUTH_CLIENT_ID}
            client-secret: ${OAUTH_CLIENT_SECRET}
            authorization-grant-type: client_credentials
            scope: read,write
        provider:
          my-client:
            token-uri: https://oauth-provider.com/token
```

These configurations provide flexibility for different authentication scenarios in reactive Spring applications. Choose the appropriate method based on your API requirements and security constraints.
