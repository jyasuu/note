I'll help you implement circuit breaker best practices for Rust applications running on Kubernetes. This involves both application-level patterns and Kubernetes configuration.Here's a comprehensive guide to implementing circuit breaker best practices in Rust applications running on Kubernetes:

## Key Best Practices

### 1. **Application-Level Circuit Breaker**
The Rust implementation I provided includes:
- **State Management**: Closed → Open → Half-Open transitions
- **Configurable Thresholds**: Failure counts, timeouts, and recovery periods
- **Async/Await Support**: Works with Tokio runtime
- **Thread Safety**: Uses `Arc<RwLock>` for concurrent access
- **Timeout Handling**: Built-in request timeouts

### 2. **Kubernetes Integration**
The K8s configuration provides:
- **Health Checks**: Readiness and liveness probes that respect circuit breaker state
- **Auto Scaling**: HPA configuration to handle traffic spikes during failures
- **Resource Limits**: Proper CPU/memory limits to prevent cascade failures
- **Pod Disruption Budgets**: Maintains minimum availability during updates

### 3. **Monitoring and Observability**
The metrics implementation includes:
- **Prometheus Integration**: Custom metrics for circuit breaker states
- **Health Endpoints**: `/health/ready` and `/health/live` for K8s probes
- **Service Discovery**: ServiceMonitor for Prometheus scraping

## Implementation Tips

### Configuration Best Practices:
```rust
// Different services need different thresholds
let db_config = CircuitBreakerConfig {
    failure_threshold: 5,        // Database can handle more failures
    recovery_timeout: Duration::from_secs(30),
    timeout: Duration::from_secs(10),
    success_threshold: 3,
};

let external_api_config = CircuitBreakerConfig {
    failure_threshold: 3,        // External APIs fail faster
    recovery_timeout: Duration
```





```rust
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use thiserror::Error;

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

#[derive(Debug, Error)]
pub enum CircuitBreakerError {
    #[error("Circuit breaker is open")]
    Open,
    #[error("Service error: {0}")]
    ServiceError(String),
    #[error("Timeout")]
    Timeout,
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: u32,
    pub recovery_timeout: Duration,
    pub timeout: Duration,
    pub success_threshold: u32, // for half-open state
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            recovery_timeout: Duration::from_secs(30),
            timeout: Duration::from_secs(10),
            success_threshold: 3,
        }
    }
}

#[derive(Debug)]
struct CircuitBreakerState {
    state: CircuitState,
    failure_count: u32,
    success_count: u32,
    last_failure_time: Option<Instant>,
    next_attempt_time: Option<Instant>,
}

impl Default for CircuitBreakerState {
    fn default() -> Self {
        Self {
            state: CircuitState::Closed,
            failure_count: 0,
            success_count: 0,
            last_failure_time: None,
            next_attempt_time: None,
        }
    }
}

pub struct CircuitBreaker {
    config: CircuitBreakerConfig,
    state: Arc<RwLock<CircuitBreakerState>>,
}

impl CircuitBreaker {
    pub fn new(config: CircuitBreakerConfig) -> Self {
        Self {
            config,
            state: Arc::new(RwLock::new(CircuitBreakerState::default())),
        }
    }

    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError>
    where
        F: std::future::Future<Output = Result<T, E>>,
        E: std::fmt::Display,
    {
        // Check if we can make the call
        {
            let state = self.state.read().await;
            match state.state {
                CircuitState::Open => {
                    if let Some(next_attempt) = state.next_attempt_time {
                        if Instant::now() < next_attempt {
                            return Err(CircuitBreakerError::Open);
                        }
                    }
                }
                CircuitState::Closed | CircuitState::HalfOpen => {}
            }
        }

        // Transition to half-open if needed
        {
            let mut state = self.state.write().await;
            if matches!(state.state, CircuitState::Open) {
                if let Some(next_attempt) = state.next_attempt_time {
                    if Instant::now() >= next_attempt {
                        state.state = CircuitState::HalfOpen;
                        state.success_count = 0;
                    }
                }
            }
        }

        // Execute the call with timeout
        let result = tokio::time::timeout(self.config.timeout, f).await;

        match result {
            Ok(Ok(value)) => {
                self.on_success().await;
                Ok(value)
            }
            Ok(Err(e)) => {
                self.on_failure().await;
                Err(CircuitBreakerError::ServiceError(e.to_string()))
            }
            Err(_) => {
                self.on_failure().await;
                Err(CircuitBreakerError::Timeout)
            }
        }
    }

    async fn on_success(&self) {
        let mut state = self.state.write().await;
        
        match state.state {
            CircuitState::Closed => {
                // Reset failure count on success
                state.failure_count = 0;
            }
            CircuitState::HalfOpen => {
                state.success_count += 1;
                if state.success_count >= self.config.success_threshold {
                    // Transition back to closed
                    state.state = CircuitState::Closed;
                    state.failure_count = 0;
                    state.success_count = 0;
                    state.next_attempt_time = None;
                }
            }
            CircuitState::Open => {
                // Should not happen, but reset to closed if it does
                state.state = CircuitState::Closed;
                state.failure_count = 0;
                state.success_count = 0;
                state.next_attempt_time = None;
            }
        }
    }

    async fn on_failure(&self) {
        let mut state = self.state.write().await;
        
        state.failure_count += 1;
        state.last_failure_time = Some(Instant::now());

        match state.state {
            CircuitState::Closed => {
                if state.failure_count >= self.config.failure_threshold {
                    state.state = CircuitState::Open;
                    state.next_attempt_time = Some(Instant::now() + self.config.recovery_timeout);
                }
            }
            CircuitState::HalfOpen => {
                // Any failure in half-open state should open the circuit
                state.state = CircuitState::Open;
                state.next_attempt_time = Some(Instant::now() + self.config.recovery_timeout);
                state.success_count = 0;
            }
            CircuitState::Open => {
                // Update next attempt time
                state.next_attempt_time = Some(Instant::now() + self.config.recovery_timeout);
            }
        }
    }

    pub async fn get_state(&self) -> CircuitState {
        self.state.read().await.state.clone()
    }

    pub async fn get_metrics(&self) -> CircuitBreakerMetrics {
        let state = self.state.read().await;
        CircuitBreakerMetrics {
            state: state.state.clone(),
            failure_count: state.failure_count,
            success_count: state.success_count,
            last_failure_time: state.last_failure_time,
        }
    }
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerMetrics {
    pub state: CircuitState,
    pub failure_count: u32,
    pub success_count: u32,
    pub last_failure_time: Option<Instant>,
}

// Example usage with HTTP client
pub struct HttpService {
    client: reqwest::Client,
    circuit_breaker: CircuitBreaker,
}

impl HttpService {
    pub fn new() -> Self {
        let config = CircuitBreakerConfig {
            failure_threshold: 3,
            recovery_timeout: Duration::from_secs(60),
            timeout: Duration::from_secs(5),
            success_threshold: 2,
        };

        Self {
            client: reqwest::Client::new(),
            circuit_breaker: CircuitBreaker::new(config),
        }
    }

    pub async fn get(&self, url: &str) -> Result<String, CircuitBreakerError> {
        self.circuit_breaker
            .call(async {
                self.client
                    .get(url)
                    .send()
                    .await
                    .map_err(|e| format!("HTTP error: {}", e))?
                    .text()
                    .await
                    .map_err(|e| format!("Response error: {}", e))
            })
            .await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;

    #[tokio::test]
    async fn test_circuit_breaker_closed_state() {
        let config = CircuitBreakerConfig {
            failure_threshold: 2,
            recovery_timeout: Duration::from_millis(100),
            timeout: Duration::from_millis(50),
            success_threshold: 1,
        };
        
        let cb = CircuitBreaker::new(config);
        
        // Successful call should keep circuit closed
        let result = cb.call(async { Ok::<(), &str>(()) }).await;
        assert!(result.is_ok());
        assert!(matches!(cb.get_state().await, CircuitState::Closed));
    }

    #[tokio::test]
    async fn test_circuit_breaker_opens_on_failures() {
        let config = CircuitBreakerConfig {
            failure_threshold: 2,
            recovery_timeout: Duration::from_millis(100),
            timeout: Duration::from_millis(50),
            success_threshold: 1,
        };
        
        let cb = CircuitBreaker::new(config);
        
        // First failure
        let _ = cb.call(async { Err::<(), _>("error") }).await;
        assert!(matches!(cb.get_state().await, CircuitState::Closed));
        
        // Second failure should open circuit
        let _ = cb.call(async { Err::<(), _>("error") }).await;
        assert!(matches!(cb.get_state().await, CircuitState::Open));
        
        // Third call should be rejected
        let result = cb.call(async { Ok::<(), &str>(()) }).await;
        assert!(matches!(result, Err(CircuitBreakerError::Open)));
    }

    #[tokio::test]
    async fn test_circuit_breaker_half_open_transition() {
        let config = CircuitBreakerConfig {
            failure_threshold: 1,
            recovery_timeout: Duration::from_millis(50),
            timeout: Duration::from_millis(100),
            success_threshold: 1,
        };
        
        let cb = CircuitBreaker::new(config);
        
        // Fail to open circuit
        let _ = cb.call(async { Err::<(), _>("error") }).await;
        assert!(matches!(cb.get_state().await, CircuitState::Open));
        
        // Wait for recovery timeout
        sleep(Duration::from_millis(60)).await;
        
        // Next call should transition to half-open and succeed
        let result = cb.call(async { Ok::<(), &str>(()) }).await;
        assert!(result.is_ok());
        assert!(matches!(cb.get_state().await, CircuitState::Closed));
    }
}
```

```rust
# Deployment with circuit breaker configuration
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-app-with-circuit-breaker
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rust-app
  template:
    metadata:
      labels:
        app: rust-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/path: "/metrics"
        prometheus.io/port: "8080"
    spec:
      containers:
      - name: rust-app
        image: rust-app:latest
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 8081
          name: metrics
        env:
        # Circuit breaker configuration via environment variables
        - name: CIRCUIT_BREAKER_FAILURE_THRESHOLD
          value: "5"
        - name: CIRCUIT_BREAKER_RECOVERY_TIMEOUT_SECONDS
          value: "30"
        - name: CIRCUIT_BREAKER_TIMEOUT_SECONDS
          value: "10"
        - name: CIRCUIT_BREAKER_SUCCESS_THRESHOLD
          value: "3"
        # Database connection settings
        - name: DB_HOST
          value: "postgres-service"
        - name: DB_PORT
          value: "5432"
        - name: DB_MAX_CONNECTIONS
          value: "10"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3

---
# Service
apiVersion: v1
kind: Service
metadata:
  name: rust-app-service
spec:
  selector:
    app: rust-app
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: metrics
    port: 8081
    targetPort: 8081

---
# ConfigMap for circuit breaker policies
apiVersion: v1
kind: ConfigMap
metadata:
  name: circuit-breaker-config
data:
  circuit-breaker.yaml: |
    services:
      database:
        failure_threshold: 5
        recovery_timeout_seconds: 30
        timeout_seconds: 10
        success_threshold: 3
      external_api:
        failure_threshold: 3
        recovery_timeout_seconds: 60
        timeout_seconds: 5
        success_threshold: 2
      redis:
        failure_threshold: 10
        recovery_timeout_seconds: 15
        timeout_seconds: 2
        success_threshold: 5

---
# HorizontalPodAutoscaler for handling circuit breaker scenarios
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: rust-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rust-app-with-circuit-breaker
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

---
# PodDisruptionBudget to maintain availability during circuit breaker events
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: rust-app-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: rust-app

---
# NetworkPolicy for controlled access
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: rust-app-netpol
spec:
  podSelector:
    matchLabels:
      app: rust-app
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  # Allow external API calls
  - to: []
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80

---
# ServiceMonitor for Prometheus monitoring
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: rust-app-circuit-breaker-metrics
spec:
  selector:
    matchLabels:
      app: rust-app
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s
```


```rust
use prometheus::{Counter, Gauge, Histogram, Registry, Encoder, TextEncoder};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::get,
    Router,
};
use serde_json::json;

// Metrics collection for circuit breakers
#[derive(Clone)]
pub struct CircuitBreakerMetrics {
    pub state_gauge: Gauge,
    pub requests_total: Counter,
    pub failures_total: Counter,
    pub successes_total: Counter,
    pub timeouts_total: Counter,
    pub open_duration: Histogram,
    pub response_time: Histogram,
}

impl CircuitBreakerMetrics {
    pub fn new(service_name: &str, registry: &Registry) -> prometheus::Result<Self> {
        let state_gauge = Gauge::new(
            format!("circuit_breaker_state_{}", service_name),
            format!("Current state of circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(state_gauge.clone()))?;

        let requests_total = Counter::new(
            format!("circuit_breaker_requests_total_{}", service_name),
            format!("Total requests through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(requests_total.clone()))?;

        let failures_total = Counter::new(
            format!("circuit_breaker_failures_total_{}", service_name),
            format!("Total failures through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(failures_total.clone()))?;

        let successes_total = Counter::new(
            format!("circuit_breaker_successes_total_{}", service_name),
            format!("Total successes through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(successes_total.clone()))?;

        let timeouts_total = Counter::new(
            format!("circuit_breaker_timeouts_total_{}", service_name),
            format!("Total timeouts through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(timeouts_total.clone()))?;

        let open_duration = Histogram::with_opts(
            prometheus::HistogramOpts::new(
                format!("circuit_breaker_open_duration_seconds_{}", service_name),
                format!("Duration circuit breaker was open for {}", service_name),
            ).buckets(vec![1.0, 5.0, 15.0, 30.0, 60.0, 300.0, 600.0]),
        )?;
        registry.register(Box::new(open_duration.clone()))?;

        let response_time = Histogram::with_opts(
            prometheus::HistogramOpts::new(
                format!("circuit_breaker_response_duration_seconds_{}", service_name),
                format!("Response time through circuit breaker for {}", service_name),
            ).buckets(prometheus::DEFAULT_BUCKETS.to_vec()),
        )?;
        registry.register(Box::new(response_time.clone()))?;

        Ok(Self {
            state_gauge,
            requests_total,
            failures_total,
            successes_total,
            timeouts_total,
            open_duration,
            response_time,
        })
    }

    pub fn record_request(&self) {
        self.requests_total.inc();
    }

    pub fn record_success(&self, duration: f64) {
        self.successes_total.inc();
        self.response_time.observe(duration);
    }

    pub fn record_failure(&self, duration: f64) {
        self.failures_total.inc();
        self.response_time.observe(duration);
    }

    pub fn record_timeout(&self) {
        self.timeouts_total.inc();
    }

    pub fn update_state(&self, state: &crate::CircuitState) {
        let state_value = match state {
            crate::CircuitState::Closed => 0.0,
            crate::CircuitState::HalfOpen => 1.0,
            crate::CircuitState::Open => 2.0,
        };
        self.state_gauge.set(state_value);
    }
}

// Health check implementation
#[derive(Clone)]
pub struct HealthChecker {
    circuit_breakers: Arc<RwLock<HashMap<String, Arc<crate::CircuitBreaker>>>>,
    metrics_registry: Arc<Registry>,
}

#[derive(serde::Serialize)]
pub struct HealthResponse {
    status: String,
    timestamp: i64,
    services: HashMap<String, ServiceHealth>,
}

#[derive(serde::Serialize)]
pub struct ServiceHealth {
    status: String,
    circuit_state: String,
    failure_count: u32,
    last_failure: Option<i64>,
}

impl HealthChecker {
    pub fn new() -> Self {
        Self {
            circuit_breakers: Arc::new(RwLock::new(HashMap::new())),
            metrics_registry: Arc::new(Registry::new()),
        }
    }

    pub async fn add_circuit_breaker(&self, name: String, circuit_breaker: Arc<crate::CircuitBreaker>) {
        let mut breakers = self.circuit_breakers.write().await;
        breakers.insert(name, circuit_breaker);
    }

    pub async fn health_check(&self) -> (StatusCode, Json<HealthResponse>) {
        let breakers = self.circuit_breakers.read().await;
        let mut services = HashMap::new();
        let mut overall_healthy = true;

        for (name, breaker) in breakers.iter() {
            let metrics = breaker.get_metrics().await;
            let status = match metrics.state {
                crate::CircuitState::Closed => "healthy",
                crate::CircuitState::HalfOpen => "degraded",
                crate::CircuitState::Open => {
                    overall_healthy = false;
                    "unhealthy"
                }
            };

            services.insert(name.clone(), ServiceHealth {
                status: status.to_string(),
                circuit_state: format!("{:?}", metrics.state),
                failure_count: metrics.failure_count,
                last_failure: metrics.last_failure_time.map(|t| {
                    t.elapsed().as_secs() as i64
                }),
            });
        }

        let status_code = if overall_healthy {
            StatusCode::OK
        } else {
            StatusCode::SERVICE_UNAVAILABLE
        };

        let response = HealthResponse {
            status: if overall_healthy { "healthy" } else { "unhealthy" }.to_string(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs() as i64,
            services,
        };

        (status_code, Json(response))
    }

    pub async fn readiness_check(&self) -> (StatusCode, Json<serde_json::Value>) {
        let breakers = self.circuit_breakers.read().await;
        let mut ready = true;

        // Consider the service ready if not all circuit breakers are open
        let mut open_count = 0;
        let total_count = breakers.len();

        for breaker in breakers.values() {
            let state = breaker.get_state().await;
            if matches!(state, crate::CircuitState::Open) {
                open_count += 1;
            }
        }

        // Service is ready if less than 50% of circuit breakers are open
        ready = total_count == 0 || (open_count as f64 / total_count as f64) < 0.5;

        let status_code = if ready {
            StatusCode::OK
        } else {
            StatusCode::SERVICE_UNAVAILABLE
        };

        (status_code, Json(json!({
            "ready": ready,
            "circuit_breakers": {
                "total": total_count,
                "open": open_count,
                "open_percentage": if total_count > 0 { 
                    (open_count as f64 / total_count as f64) * 100.0 
                } else { 
                    0.0 
                }
            }
        })))
    }

    pub async fn metrics(&self) -> String {
        let encoder = TextEncoder::new();
        let metric_families = self.metrics_registry.gather();
        encoder.encode_to_string(&metric_families).unwrap()
    }
}

// Axum router setup for health endpoints
pub fn create_health_router(health_checker: Arc<HealthChecker>) -> Router {
    Router::new()
        .route("/health/live", get(liveness_handler))
        .route("/health/ready", get(readiness_handler))
        .route("/metrics", get(metrics_handler))
        .with_state(health_checker)
}

async fn liveness_handler(State(health_checker): State<Arc<HealthChecker>>) -> impl axum::response::IntoResponse {
    health_checker.health_check().await
}

async fn readiness_handler(State(health_checker): State<Arc<HealthChecker>>) -> impl axum::response::IntoResponse {
    health_checker.readiness_check().await
}

async fn metrics_handler(State(health_checker): State<Arc<HealthChecker>>) -> impl axum::response::IntoResponse {
    (
        StatusCode::OK,
        [("Content-Type", "text/plain; charset=utf-8")],
        health_checker.metrics().await,
    )
}

// Example integration with the circuit breaker
pub struct MonitoredCircuitBreaker {
    circuit_breaker: Arc<crate::CircuitBreaker>,
    metrics: CircuitBreakerMetrics,
}

impl MonitoredCircuitBreaker {
    pub fn new(
        service_name: &str,
        config: crate::CircuitBreakerConfig,
        registry: &Registry,
    ) -> prometheus::Result<Self> {
        let circuit_breaker = Arc::new(crate::CircuitBreaker::new(config));
        let metrics = CircuitBreakerMetrics::new(service_name, registry)?;

        Ok(Self {
            circuit_breaker,
            metrics,
        })
    }

    pub async fn call<F, T, E>(&self, f: F) -> Result<T, crate::CircuitBreakerError>
    where
        F: std::future::Future<Output = Result<T, E>>,
        E: std::fmt::Display,
    {
        use std::time::Instant;
        
        self.metrics.record_request();
        let start = Instant::now();

        // Update state metric before call
        let state = self.circuit_breaker.get_state().await;
        self.metrics.update_state(&state);

        let result = self.circuit_breaker.call(f).await;
        let duration = start.elapsed().as_secs_f64();

        match &result {
            Ok(_) => self.metrics.record_success(duration),
            Err(crate::CircuitBreakerError::ServiceError(_)) => {
                self.metrics.record_failure(duration);
            }
            Err(crate::CircuitBreakerError::Timeout) => {
                self.metrics.record_timeout();
            }
            Err(crate::CircuitBreakerError::Open) => {
                // No additional metrics for open circuit
            }
        }

        // Update state metric after call
        let new_state = self.circuit_breaker.get_state().await;
        self.metrics.update_state(&new_state);

        result
    }

    pub fn get_circuit_breaker(&self) -> Arc<crate::CircuitBreaker> {
        Arc::clone(&self.circuit_breaker)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_health_checker() {
        let health_checker = HealthChecker::new();
        let config = crate::CircuitBreakerConfig::default();
        let cb = Arc::new(crate::CircuitBreaker::new(config));
        
        health_checker.add_circuit_breaker("test_service".to_string(), cb).await;
        
        let (status, response) = health_checker.health_check().await;
        assert_eq!(status, StatusCode::OK);
        assert!(response.services.contains_key("test_service"));
    }
}
```
