I'll help you implement circuit breaker best practices for Rust applications running on Kubernetes. This involves both application-level patterns and Kubernetes configuration.Here's a comprehensive guide to implementing circuit breaker best practices in Rust applications running on Kubernetes:

## Key Best Practices

### 1. **Application-Level Circuit Breaker**
The Rust implementation I provided includes:
- **State Management**: Closed → Open → Half-Open transitions
- **Configurable Thresholds**: Failure counts, timeouts, and recovery periods
- **Async/Await Support**: Works with Tokio runtime
- **Thread Safety**: Uses `Arc<RwLock>` for concurrent access
- **Timeout Handling**: Built-in request timeouts

### 2. **Kubernetes Integration**
The K8s configuration provides:
- **Health Checks**: Readiness and liveness probes that respect circuit breaker state
- **Auto Scaling**: HPA configuration to handle traffic spikes during failures
- **Resource Limits**: Proper CPU/memory limits to prevent cascade failures
- **Pod Disruption Budgets**: Maintains minimum availability during updates

### 3. **Monitoring and Observability**
The metrics implementation includes:
- **Prometheus Integration**: Custom metrics for circuit breaker states
- **Health Endpoints**: `/health/ready` and `/health/live` for K8s probes
- **Service Discovery**: ServiceMonitor for Prometheus scraping

## Implementation Tips

### Configuration Best Practices:
```rust
// Different services need different thresholds
let db_config = CircuitBreakerConfig {
    failure_threshold: 5,        // Database can handle more failures
    recovery_timeout: Duration::from_secs(30),
    timeout: Duration::from_secs(10),
    success_threshold: 3,
};

let external_api_config = CircuitBreakerConfig {
    failure_threshold: 3,        // External APIs fail faster
    recovery_timeout: Duration
```





```rust
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use thiserror::Error;

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

#[derive(Debug, Error)]
pub enum CircuitBreakerError {
    #[error("Circuit breaker is open")]
    Open,
    #[error("Service error: {0}")]
    ServiceError(String),
    #[error("Timeout")]
    Timeout,
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: u32,
    pub recovery_timeout: Duration,
    pub timeout: Duration,
    pub success_threshold: u32, // for half-open state
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            recovery_timeout: Duration::from_secs(30),
            timeout: Duration::from_secs(10),
            success_threshold: 3,
        }
    }
}

#[derive(Debug)]
struct CircuitBreakerState {
    state: CircuitState,
    failure_count: u32,
    success_count: u32,
    last_failure_time: Option<Instant>,
    next_attempt_time: Option<Instant>,
}

impl Default for CircuitBreakerState {
    fn default() -> Self {
        Self {
            state: CircuitState::Closed,
            failure_count: 0,
            success_count: 0,
            last_failure_time: None,
            next_attempt_time: None,
        }
    }
}

pub struct CircuitBreaker {
    config: CircuitBreakerConfig,
    state: Arc<RwLock<CircuitBreakerState>>,
}

impl CircuitBreaker {
    pub fn new(config: CircuitBreakerConfig) -> Self {
        Self {
            config,
            state: Arc::new(RwLock::new(CircuitBreakerState::default())),
        }
    }

    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError>
    where
        F: std::future::Future<Output = Result<T, E>>,
        E: std::fmt::Display,
    {
        // Check if we can make the call
        {
            let state = self.state.read().await;
            match state.state {
                CircuitState::Open => {
                    if let Some(next_attempt) = state.next_attempt_time {
                        if Instant::now() < next_attempt {
                            return Err(CircuitBreakerError::Open);
                        }
                    }
                }
                CircuitState::Closed | CircuitState::HalfOpen => {}
            }
        }

        // Transition to half-open if needed
        {
            let mut state = self.state.write().await;
            if matches!(state.state, CircuitState::Open) {
                if let Some(next_attempt) = state.next_attempt_time {
                    if Instant::now() >= next_attempt {
                        state.state = CircuitState::HalfOpen;
                        state.success_count = 0;
                    }
                }
            }
        }

        // Execute the call with timeout
        let result = tokio::time::timeout(self.config.timeout, f).await;

        match result {
            Ok(Ok(value)) => {
                self.on_success().await;
                Ok(value)
            }
            Ok(Err(e)) => {
                self.on_failure().await;
                Err(CircuitBreakerError::ServiceError(e.to_string()))
            }
            Err(_) => {
                self.on_failure().await;
                Err(CircuitBreakerError::Timeout)
            }
        }
    }

    async fn on_success(&self) {
        let mut state = self.state.write().await;
        
        match state.state {
            CircuitState::Closed => {
                // Reset failure count on success
                state.failure_count = 0;
            }
            CircuitState::HalfOpen => {
                state.success_count += 1;
                if state.success_count >= self.config.success_threshold {
                    // Transition back to closed
                    state.state = CircuitState::Closed;
                    state.failure_count = 0;
                    state.success_count = 0;
                    state.next_attempt_time = None;
                }
            }
            CircuitState::Open => {
                // Should not happen, but reset to closed if it does
                state.state = CircuitState::Closed;
                state.failure_count = 0;
                state.success_count = 0;
                state.next_attempt_time = None;
            }
        }
    }

    async fn on_failure(&self) {
        let mut state = self.state.write().await;
        
        state.failure_count += 1;
        state.last_failure_time = Some(Instant::now());

        match state.state {
            CircuitState::Closed => {
                if state.failure_count >= self.config.failure_threshold {
                    state.state = CircuitState::Open;
                    state.next_attempt_time = Some(Instant::now() + self.config.recovery_timeout);
                }
            }
            CircuitState::HalfOpen => {
                // Any failure in half-open state should open the circuit
                state.state = CircuitState::Open;
                state.next_attempt_time = Some(Instant::now() + self.config.recovery_timeout);
                state.success_count = 0;
            }
            CircuitState::Open => {
                // Update next attempt time
                state.next_attempt_time = Some(Instant::now() + self.config.recovery_timeout);
            }
        }
    }

    pub async fn get_state(&self) -> CircuitState {
        self.state.read().await.state.clone()
    }

    pub async fn get_metrics(&self) -> CircuitBreakerMetrics {
        let state = self.state.read().await;
        CircuitBreakerMetrics {
            state: state.state.clone(),
            failure_count: state.failure_count,
            success_count: state.success_count,
            last_failure_time: state.last_failure_time,
        }
    }
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerMetrics {
    pub state: CircuitState,
    pub failure_count: u32,
    pub success_count: u32,
    pub last_failure_time: Option<Instant>,
}

// Example usage with HTTP client
pub struct HttpService {
    client: reqwest::Client,
    circuit_breaker: CircuitBreaker,
}

impl HttpService {
    pub fn new() -> Self {
        let config = CircuitBreakerConfig {
            failure_threshold: 3,
            recovery_timeout: Duration::from_secs(60),
            timeout: Duration::from_secs(5),
            success_threshold: 2,
        };

        Self {
            client: reqwest::Client::new(),
            circuit_breaker: CircuitBreaker::new(config),
        }
    }

    pub async fn get(&self, url: &str) -> Result<String, CircuitBreakerError> {
        self.circuit_breaker
            .call(async {
                self.client
                    .get(url)
                    .send()
                    .await
                    .map_err(|e| format!("HTTP error: {}", e))?
                    .text()
                    .await
                    .map_err(|e| format!("Response error: {}", e))
            })
            .await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;

    #[tokio::test]
    async fn test_circuit_breaker_closed_state() {
        let config = CircuitBreakerConfig {
            failure_threshold: 2,
            recovery_timeout: Duration::from_millis(100),
            timeout: Duration::from_millis(50),
            success_threshold: 1,
        };
        
        let cb = CircuitBreaker::new(config);
        
        // Successful call should keep circuit closed
        let result = cb.call(async { Ok::<(), &str>(()) }).await;
        assert!(result.is_ok());
        assert!(matches!(cb.get_state().await, CircuitState::Closed));
    }

    #[tokio::test]
    async fn test_circuit_breaker_opens_on_failures() {
        let config = CircuitBreakerConfig {
            failure_threshold: 2,
            recovery_timeout: Duration::from_millis(100),
            timeout: Duration::from_millis(50),
            success_threshold: 1,
        };
        
        let cb = CircuitBreaker::new(config);
        
        // First failure
        let _ = cb.call(async { Err::<(), _>("error") }).await;
        assert!(matches!(cb.get_state().await, CircuitState::Closed));
        
        // Second failure should open circuit
        let _ = cb.call(async { Err::<(), _>("error") }).await;
        assert!(matches!(cb.get_state().await, CircuitState::Open));
        
        // Third call should be rejected
        let result = cb.call(async { Ok::<(), &str>(()) }).await;
        assert!(matches!(result, Err(CircuitBreakerError::Open)));
    }

    #[tokio::test]
    async fn test_circuit_breaker_half_open_transition() {
        let config = CircuitBreakerConfig {
            failure_threshold: 1,
            recovery_timeout: Duration::from_millis(50),
            timeout: Duration::from_millis(100),
            success_threshold: 1,
        };
        
        let cb = CircuitBreaker::new(config);
        
        // Fail to open circuit
        let _ = cb.call(async { Err::<(), _>("error") }).await;
        assert!(matches!(cb.get_state().await, CircuitState::Open));
        
        // Wait for recovery timeout
        sleep(Duration::from_millis(60)).await;
        
        // Next call should transition to half-open and succeed
        let result = cb.call(async { Ok::<(), &str>(()) }).await;
        assert!(result.is_ok());
        assert!(matches!(cb.get_state().await, CircuitState::Closed));
    }
}
```

```rust
# Deployment with circuit breaker configuration
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-app-with-circuit-breaker
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rust-app
  template:
    metadata:
      labels:
        app: rust-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/path: "/metrics"
        prometheus.io/port: "8080"
    spec:
      containers:
      - name: rust-app
        image: rust-app:latest
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 8081
          name: metrics
        env:
        # Circuit breaker configuration via environment variables
        - name: CIRCUIT_BREAKER_FAILURE_THRESHOLD
          value: "5"
        - name: CIRCUIT_BREAKER_RECOVERY_TIMEOUT_SECONDS
          value: "30"
        - name: CIRCUIT_BREAKER_TIMEOUT_SECONDS
          value: "10"
        - name: CIRCUIT_BREAKER_SUCCESS_THRESHOLD
          value: "3"
        # Database connection settings
        - name: DB_HOST
          value: "postgres-service"
        - name: DB_PORT
          value: "5432"
        - name: DB_MAX_CONNECTIONS
          value: "10"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3

---
# Service
apiVersion: v1
kind: Service
metadata:
  name: rust-app-service
spec:
  selector:
    app: rust-app
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: metrics
    port: 8081
    targetPort: 8081

---
# ConfigMap for circuit breaker policies
apiVersion: v1
kind: ConfigMap
metadata:
  name: circuit-breaker-config
data:
  circuit-breaker.yaml: |
    services:
      database:
        failure_threshold: 5
        recovery_timeout_seconds: 30
        timeout_seconds: 10
        success_threshold: 3
      external_api:
        failure_threshold: 3
        recovery_timeout_seconds: 60
        timeout_seconds: 5
        success_threshold: 2
      redis:
        failure_threshold: 10
        recovery_timeout_seconds: 15
        timeout_seconds: 2
        success_threshold: 5

---
# HorizontalPodAutoscaler for handling circuit breaker scenarios
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: rust-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rust-app-with-circuit-breaker
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

---
# PodDisruptionBudget to maintain availability during circuit breaker events
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: rust-app-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: rust-app

---
# NetworkPolicy for controlled access
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: rust-app-netpol
spec:
  podSelector:
    matchLabels:
      app: rust-app
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  # Allow external API calls
  - to: []
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80

---
# ServiceMonitor for Prometheus monitoring
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: rust-app-circuit-breaker-metrics
spec:
  selector:
    matchLabels:
      app: rust-app
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s
```


```rust
use prometheus::{Counter, Gauge, Histogram, Registry, Encoder, TextEncoder};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::get,
    Router,
};
use serde_json::json;

// Metrics collection for circuit breakers
#[derive(Clone)]
pub struct CircuitBreakerMetrics {
    pub state_gauge: Gauge,
    pub requests_total: Counter,
    pub failures_total: Counter,
    pub successes_total: Counter,
    pub timeouts_total: Counter,
    pub open_duration: Histogram,
    pub response_time: Histogram,
}

impl CircuitBreakerMetrics {
    pub fn new(service_name: &str, registry: &Registry) -> prometheus::Result<Self> {
        let state_gauge = Gauge::new(
            format!("circuit_breaker_state_{}", service_name),
            format!("Current state of circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(state_gauge.clone()))?;

        let requests_total = Counter::new(
            format!("circuit_breaker_requests_total_{}", service_name),
            format!("Total requests through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(requests_total.clone()))?;

        let failures_total = Counter::new(
            format!("circuit_breaker_failures_total_{}", service_name),
            format!("Total failures through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(failures_total.clone()))?;

        let successes_total = Counter::new(
            format!("circuit_breaker_successes_total_{}", service_name),
            format!("Total successes through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(successes_total.clone()))?;

        let timeouts_total = Counter::new(
            format!("circuit_breaker_timeouts_total_{}", service_name),
            format!("Total timeouts through circuit breaker for {}", service_name),
        )?;
        registry.register(Box::new(timeouts_total.clone()))?;

        let open_duration = Histogram::with_opts(
            prometheus::HistogramOpts::new(
                format!("circuit_breaker_open_duration_seconds_{}", service_name),
                format!("Duration circuit breaker was open for {}", service_name),
            ).buckets(vec![1.0, 5.0, 15.0, 30.0, 60.0, 300.0, 600.0]),
        )?;
        registry.register(Box::new(open_duration.clone()))?;

        let response_time = Histogram::with_opts(
            prometheus::HistogramOpts::new(
                format!("circuit_breaker_response_duration_seconds_{}", service_name),
                format!("Response time through circuit breaker for {}", service_name),
            ).buckets(prometheus::DEFAULT_BUCKETS.to_vec()),
        )?;
        registry.register(Box::new(response_time.clone()))?;

        Ok(Self {
            state_gauge,
            requests_total,
            failures_total,
            successes_total,
            timeouts_total,
            open_duration,
            response_time,
        })
    }

    pub fn record_request(&self) {
        self.requests_total.inc();
    }

    pub fn record_success(&self, duration: f64) {
        self.successes_total.inc();
        self.response_time.observe(duration);
    }

    pub fn record_failure(&self, duration: f64) {
        self.failures_total.inc();
        self.response_time.observe(duration);
    }

    pub fn record_timeout(&self) {
        self.timeouts_total.inc();
    }

    pub fn update_state(&self, state: &crate::CircuitState) {
        let state_value = match state {
            crate::CircuitState::Closed => 0.0,
            crate::CircuitState::HalfOpen => 1.0,
            crate::CircuitState::Open => 2.0,
        };
        self.state_gauge.set(state_value);
    }
}

// Health check implementation
#[derive(Clone)]
pub struct HealthChecker {
    circuit_breakers: Arc<RwLock<HashMap<String, Arc<crate::CircuitBreaker>>>>,
    metrics_registry: Arc<Registry>,
}

#[derive(serde::Serialize)]
pub struct HealthResponse {
    status: String,
    timestamp: i64,
    services: HashMap<String, ServiceHealth>,
}

#[derive(serde::Serialize)]
pub struct ServiceHealth {
    status: String,
    circuit_state: String,
    failure_count: u32,
    last_failure: Option<i64>,
}

impl HealthChecker {
    pub fn new() -> Self {
        Self {
            circuit_breakers: Arc::new(RwLock::new(HashMap::new())),
            metrics_registry: Arc::new(Registry::new()),
        }
    }

    pub async fn add_circuit_breaker(&self, name: String, circuit_breaker: Arc<crate::CircuitBreaker>) {
        let mut breakers = self.circuit_breakers.write().await;
        breakers.insert(name, circuit_breaker);
    }

    pub async fn health_check(&self) -> (StatusCode, Json<HealthResponse>) {
        let breakers = self.circuit_breakers.read().await;
        let mut services = HashMap::new();
        let mut overall_healthy = true;

        for (name, breaker) in breakers.iter() {
            let metrics = breaker.get_metrics().await;
            let status = match metrics.state {
                crate::CircuitState::Closed => "healthy",
                crate::CircuitState::HalfOpen => "degraded",
                crate::CircuitState::Open => {
                    overall_healthy = false;
                    "unhealthy"
                }
            };

            services.insert(name.clone(), ServiceHealth {
                status: status.to_string(),
                circuit_state: format!("{:?}", metrics.state),
                failure_count: metrics.failure_count,
                last_failure: metrics.last_failure_time.map(|t| {
                    t.elapsed().as_secs() as i64
                }),
            });
        }

        let status_code = if overall_healthy {
            StatusCode::OK
        } else {
            StatusCode::SERVICE_UNAVAILABLE
        };

        let response = HealthResponse {
            status: if overall_healthy { "healthy" } else { "unhealthy" }.to_string(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs() as i64,
            services,
        };

        (status_code, Json(response))
    }

    pub async fn readiness_check(&self) -> (StatusCode, Json<serde_json::Value>) {
        let breakers = self.circuit_breakers.read().await;
        let mut ready = true;

        // Consider the service ready if not all circuit breakers are open
        let mut open_count = 0;
        let total_count = breakers.len();

        for breaker in breakers.values() {
            let state = breaker.get_state().await;
            if matches!(state, crate::CircuitState::Open) {
                open_count += 1;
            }
        }

        // Service is ready if less than 50% of circuit breakers are open
        ready = total_count == 0 || (open_count as f64 / total_count as f64) < 0.5;

        let status_code = if ready {
            StatusCode::OK
        } else {
            StatusCode::SERVICE_UNAVAILABLE
        };

        (status_code, Json(json!({
            "ready": ready,
            "circuit_breakers": {
                "total": total_count,
                "open": open_count,
                "open_percentage": if total_count > 0 { 
                    (open_count as f64 / total_count as f64) * 100.0 
                } else { 
                    0.0 
                }
            }
        })))
    }

    pub async fn metrics(&self) -> String {
        let encoder = TextEncoder::new();
        let metric_families = self.metrics_registry.gather();
        encoder.encode_to_string(&metric_families).unwrap()
    }
}

// Axum router setup for health endpoints
pub fn create_health_router(health_checker: Arc<HealthChecker>) -> Router {
    Router::new()
        .route("/health/live", get(liveness_handler))
        .route("/health/ready", get(readiness_handler))
        .route("/metrics", get(metrics_handler))
        .with_state(health_checker)
}

async fn liveness_handler(State(health_checker): State<Arc<HealthChecker>>) -> impl axum::response::IntoResponse {
    health_checker.health_check().await
}

async fn readiness_handler(State(health_checker): State<Arc<HealthChecker>>) -> impl axum::response::IntoResponse {
    health_checker.readiness_check().await
}

async fn metrics_handler(State(health_checker): State<Arc<HealthChecker>>) -> impl axum::response::IntoResponse {
    (
        StatusCode::OK,
        [("Content-Type", "text/plain; charset=utf-8")],
        health_checker.metrics().await,
    )
}

// Example integration with the circuit breaker
pub struct MonitoredCircuitBreaker {
    circuit_breaker: Arc<crate::CircuitBreaker>,
    metrics: CircuitBreakerMetrics,
}

impl MonitoredCircuitBreaker {
    pub fn new(
        service_name: &str,
        config: crate::CircuitBreakerConfig,
        registry: &Registry,
    ) -> prometheus::Result<Self> {
        let circuit_breaker = Arc::new(crate::CircuitBreaker::new(config));
        let metrics = CircuitBreakerMetrics::new(service_name, registry)?;

        Ok(Self {
            circuit_breaker,
            metrics,
        })
    }

    pub async fn call<F, T, E>(&self, f: F) -> Result<T, crate::CircuitBreakerError>
    where
        F: std::future::Future<Output = Result<T, E>>,
        E: std::fmt::Display,
    {
        use std::time::Instant;
        
        self.metrics.record_request();
        let start = Instant::now();

        // Update state metric before call
        let state = self.circuit_breaker.get_state().await;
        self.metrics.update_state(&state);

        let result = self.circuit_breaker.call(f).await;
        let duration = start.elapsed().as_secs_f64();

        match &result {
            Ok(_) => self.metrics.record_success(duration),
            Err(crate::CircuitBreakerError::ServiceError(_)) => {
                self.metrics.record_failure(duration);
            }
            Err(crate::CircuitBreakerError::Timeout) => {
                self.metrics.record_timeout();
            }
            Err(crate::CircuitBreakerError::Open) => {
                // No additional metrics for open circuit
            }
        }

        // Update state metric after call
        let new_state = self.circuit_breaker.get_state().await;
        self.metrics.update_state(&new_state);

        result
    }

    pub fn get_circuit_breaker(&self) -> Arc<crate::CircuitBreaker> {
        Arc::clone(&self.circuit_breaker)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_health_checker() {
        let health_checker = HealthChecker::new();
        let config = crate::CircuitBreakerConfig::default();
        let cb = Arc::new(crate::CircuitBreaker::new(config));
        
        health_checker.add_circuit_breaker("test_service".to_string(), cb).await;
        
        let (status, response) = health_checker.health_check().await;
        assert_eq!(status, StatusCode::OK);
        assert!(response.services.contains_key("test_service"));
    }
}
```





Continuing with the implementation tips:

## Implementation Tips (continued)

### Configuration Best Practices:
```rust
let external_api_config = CircuitBreakerConfig {
    failure_threshold: 3,        // External APIs fail faster
    recovery_timeout: Duration::from_secs(60), // Longer recovery for external deps
    timeout: Duration::from_secs(5),           // Shorter timeout for APIs
    success_threshold: 2,                      // Quicker recovery verification
};
```

### 4. **Service Integration Patterns**## Additional Best Practices

### 5. **Graceful Degradation Strategies**

1. **Cache-First Pattern**: Always check cache before hitting primary services
2. **Fallback Logic**: Provide alternative responses when services are unavailable
3. **Critical vs Non-Critical**: Distinguish between must-have and nice-to-have features
4. **Bulkhead Pattern**: Isolate different service calls with separate circuit breakers

### 6. **Kubernetes Deployment Best Practices**

```bash
# Apply circuit breaker configuration
kubectl apply -f circuit-breaker-config.yaml

# Monitor circuit breaker metrics
kubectl port-forward svc/rust-app-service 8080:80
curl http://localhost:8080/metrics | grep circuit_breaker

# Check health status
curl http://localhost:8080/health/ready
curl http://localhost:8080/health/live
```

### 7. **Configuration Management**

Use environment variables or ConfigMaps for different environments:

```rust
// Load configuration from environment
pub fn load_circuit_breaker_config() -> CircuitBreakerConfig {
    CircuitBreakerConfig {
        failure_threshold: std::env::var("CIRCUIT_BREAKER_FAILURE_THRESHOLD")
            .unwrap_or_else(|_| "5".to_string())
            .parse()
            .unwrap_or(5),
        recovery_timeout: Duration::from_secs(
            std::env::var("CIRCUIT_BREAKER_RECOVERY_TIMEOUT_SECONDS")
                .unwrap_or_else(|_| "30".to_string())
                .parse()
                .unwrap_or(30)
        ),
        // ... other fields
    }
}
```

### 8. **Monitoring and Alerting**

Set up Prometheus alerts for circuit breaker state changes:

```yaml
groups:
- name: circuit_breaker_alerts
  rules:
  - alert: CircuitBreakerOpen
    expr: circuit_breaker_state > 1.5  # State = 2 (Open)
    for: 1m
    labels:
      severity: warning
    annotations:
      summary: "Circuit breaker is open for {{ $labels.service }}"

  - alert: HighFailureRate
    expr: rate(circuit_breaker_failures_total[5m]) > 0.1
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "High failure rate detected for {{ $labels.service }}"
```

### Key Benefits of This Implementation:

1. **Resilience**: Prevents cascade failures across your microservices
2. **Observability**: Comprehensive metrics and health checks for monitoring
3. **Kubernetes Native**: Integrates seamlessly with K8s health checks and scaling
4. **Graceful Degradation**: Services can continue operating with reduced functionality
5. **Production Ready**: Includes proper error handling, timeouts, and resource management

This setup provides a robust foundation for building resilient Rust applications in Kubernetes with proper circuit breaker patterns.





```rust
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Service registry pattern for managing multiple circuit breakers
#[derive(Clone)]
pub struct ServiceRegistry {
    circuit_breakers: Arc<RwLock<HashMap<String, Arc<MonitoredCircuitBreaker>>>>,
    registry: Arc<prometheus::Registry>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            circuit_breakers: Arc::new(RwLock::new(HashMap::new())),
            registry: Arc::new(prometheus::Registry::new()),
        }
    }

    pub async fn register_service(
        &self,
        name: &str,
        config: crate::CircuitBreakerConfig,
    ) -> Result<(), prometheus::Error> {
        let monitored_cb = crate::MonitoredCircuitBreaker::new(name, config, &self.registry)?;
        let mut breakers = self.circuit_breakers.write().await;
        breakers.insert(name.to_string(), Arc::new(monitored_cb));
        Ok(())
    }

    pub async fn get_service(&self, name: &str) -> Option<Arc<MonitoredCircuitBreaker>> {
        let breakers = self.circuit_breakers.read().await;
        breakers.get(name).cloned()
    }

    pub fn get_registry(&self) -> Arc<prometheus::Registry> {
        Arc::clone(&self.registry)
    }
}

// Database service with connection pooling and circuit breaker
pub struct DatabaseService {
    pool: sqlx::PgPool,
    circuit_breaker: Arc<MonitoredCircuitBreaker>,
}

impl DatabaseService {
    pub async fn new(database_url: &str, registry: &prometheus::Registry) -> Result<Self, Box<dyn std::error::Error>> {
        let pool = sqlx::PgPool::connect(database_url).await?;
        
        let config = crate::CircuitBreakerConfig {
            failure_threshold: 5,
            recovery_timeout: Duration::from_secs(30),
            timeout: Duration::from_secs(10),
            success_threshold: 3,
        };

        let circuit_breaker = Arc::new(
            crate::MonitoredCircuitBreaker::new("database", config, registry)?
        );

        Ok(Self {
            pool,
            circuit_breaker,
        })
    }

    pub async fn get_user(&self, user_id: i32) -> Result<Option<User>, DatabaseError> {
        self.circuit_breaker
            .call(async {
                sqlx::query_as!(
                    User,
                    "SELECT id, name, email FROM users WHERE id = $1",
                    user_id
                )
                .fetch_optional(&self.pool)
                .await
                .map_err(|e| DatabaseError::QueryError(e.to_string()))
            })
            .await
            .map_err(|e| match e {
                crate::CircuitBreakerError::Open => DatabaseError::ServiceUnavailable,
                crate::CircuitBreakerError::Timeout => DatabaseError::Timeout,
                crate::CircuitBreakerError::ServiceError(msg) => DatabaseError::QueryError(msg),
            })
    }

    pub async fn create_user(&self, user: CreateUser) -> Result<User, DatabaseError> {
        self.circuit_breaker
            .call(async {
                sqlx::query_as!(
                    User,
                    "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email",
                    user.name,
                    user.email
                )
                .fetch_one(&self.pool)
                .await
                .map_err(|e| DatabaseError::QueryError(e.to_string()))
            })
            .await
            .map_err(|e| match e {
                crate::CircuitBreakerError::Open => DatabaseError::ServiceUnavailable,
                crate::CircuitBreakerError::Timeout => DatabaseError::Timeout,
                crate::CircuitBreakerError::ServiceError(msg) => DatabaseError::QueryError(msg),
            })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateUser {
    pub name: String,
    pub email: String,
}

#[derive(Debug, thiserror::Error)]
pub enum DatabaseError {
    #[error("Database service unavailable")]
    ServiceUnavailable,
    #[error("Query timeout")]
    Timeout,
    #[error("Query error: {0}")]
    QueryError(String),
}

// External API service with retry logic
pub struct ExternalApiService {
    client: reqwest::Client,
    circuit_breaker: Arc<MonitoredCircuitBreaker>,
    base_url: String,
}

impl ExternalApiService {
    pub fn new(base_url: String, registry: &prometheus::Registry) -> Result<Self, prometheus::Error> {
        let config = crate::CircuitBreakerConfig {
            failure_threshold: 3,
            recovery_timeout: Duration::from_secs(60),
            timeout: Duration::from_secs(5),
            success_threshold: 2,
        };

        let circuit_breaker = Arc::new(
            crate::MonitoredCircuitBreaker::new("external_api", config, registry)?
        );

        Ok(Self {
            client: reqwest::Client::builder()
                .timeout(Duration::from_secs(5))
                .build()
                .unwrap(),
            circuit_breaker,
            base_url,
        })
    }

    pub async fn fetch_data(&self, endpoint: &str) -> Result<serde_json::Value, ApiError> {
        self.circuit_breaker
            .call(async {
                let url = format!("{}/{}", self.base_url, endpoint);
                self.client
                    .get(&url)
                    .send()
                    .await
                    .map_err(|e| ApiError::RequestError(e.to_string()))?
                    .json::<serde_json::Value>()
                    .await
                    .map_err(|e| ApiError::ParseError(e.to_string()))
            })
            .await
            .map_err(|e| match e {
                crate::CircuitBreakerError::Open => ApiError::ServiceUnavailable,
                crate::CircuitBreakerError::Timeout => ApiError::Timeout,
                crate::CircuitBreakerError::ServiceError(msg) => ApiError::RequestError(msg),
            })
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("External API service unavailable")]
    ServiceUnavailable,
    #[error("Request timeout")]
    Timeout,
    #[error("Request error: {0}")]
    RequestError(String),
    #[error("Parse error: {0}")]
    ParseError(String),
}

// Cache service with fallback logic
pub struct CacheService {
    redis: redis::aio::ConnectionManager,
    circuit_breaker: Arc<MonitoredCircuitBreaker>,
}

impl CacheService {
    pub async fn new(redis_url: &str, registry: &prometheus::Registry) -> Result<Self, Box<dyn std::error::Error>> {
        let client = redis::Client::open(redis_url)?;
        let redis = redis::aio::ConnectionManager::new(client).await?;
        
        let config = crate::CircuitBreakerConfig {
            failure_threshold: 10, // Redis can handle more failures
            recovery_timeout: Duration::from_secs(15),
            timeout: Duration::from_secs(2),
            success_threshold: 5,
        };

        let circuit_breaker = Arc::new(
            crate::MonitoredCircuitBreaker::new("redis", config, registry)?
        );

        Ok(Self {
            redis,
            circuit_breaker,
        })
    }

    pub async fn get<T>(&self, key: &str) -> Result<Option<T>, CacheError>
    where
        T: serde::de::DeserializeOwned,
    {
        use redis::AsyncCommands;
        
        self.circuit_breaker
            .call(async {
                let mut conn = self.redis.clone();
                let result: Option<String> = conn.get(key).await
                    .map_err(|e| CacheError::RedisError(e.to_string()))?;
                
                match result {
                    Some(data) => {
                        let parsed = serde_json::from_str(&data)
                            .map_err(|e| CacheError::SerializationError(e.to_string()))?;
                        Ok(Some(parsed))
                    }
                    None => Ok(None),
                }
            })
            .await
            .map_err(|e| match e {
                crate::CircuitBreakerError::Open => CacheError::ServiceUnavailable,
                crate::CircuitBreakerError::Timeout => CacheError::Timeout,
                crate::CircuitBreakerError::ServiceError(msg) => CacheError::RedisError(msg),
            })
    }

    pub async fn set<T>(&self, key: &str, value: &T, ttl: u64) -> Result<(), CacheError>
    where
        T: serde::Serialize,
    {
        use redis::AsyncCommands;
        
        self.circuit_breaker
            .call(async {
                let data = serde_json::to_string(value)
                    .map_err(|e| CacheError::SerializationError(e.to_string()))?;
                
                let mut conn = self.redis.clone();
                conn.set_ex(key, data, ttl).await
                    .map_err(|e| CacheError::RedisError(e.to_string()))
            })
            .await
            .map_err(|e| match e {
                crate::CircuitBreakerError::Open => CacheError::ServiceUnavailable,
                crate::CircuitBreakerError::Timeout => CacheError::Timeout,
                crate::CircuitBreakerError::ServiceError(msg) => CacheError::RedisError(msg),
            })
    }
}

#[derive(Debug, thiserror::Error)]
pub enum CacheError {
    #[error("Cache service unavailable")]
    ServiceUnavailable,
    #[error("Cache timeout")]
    Timeout,
    #[error("Redis error: {0}")]
    RedisError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
}

// Application service that combines all services with graceful degradation
pub struct ApplicationService {
    database: DatabaseService,
    external_api: ExternalApiService,
    cache: CacheService,
}

impl ApplicationService {
    pub fn new(
        database: DatabaseService,
        external_api: ExternalApiService,
        cache: CacheService,
    ) -> Self {
        Self {
            database,
            external_api,
            cache,
        }
    }

    // Example of graceful degradation with fallback logic
    pub async fn get_user_with_enrichment(&self, user_id: i32) -> Result<EnrichedUser, ApplicationError> {
        // Try to get from cache first
        let cache_key = format!("enriched_user:{}", user_id);
        if let Ok(Some(cached_user)) = self.cache.get::<EnrichedUser>(&cache_key).await {
            return Ok(cached_user);
        }

        // Get user from database (critical path - fail if not available)
        let user = self.database.get_user(user_id).await
            .map_err(ApplicationError::DatabaseError)?
            .ok_or(ApplicationError::UserNotFound)?;

        // Try to enrich with external data (non-critical - degrade gracefully)
        let external_data = match self.external_api.fetch_data(&format!("users/{}", user_id)).await {
            Ok(data) => Some(data),
            Err(ApiError::ServiceUnavailable) => {
                // Log degradation but continue
                tracing::warn!("External API unavailable, serving user without enrichment");
                None
            }
            Err(e) => {
                tracing::error!("External API error: {}", e);
                None
            }
        };

        let enriched_user = EnrichedUser {
            id: user.id,
            name: user.name,
            email: user.email,
            external_data,
        };

        // Try to cache the result (non-critical)
        if let Err(e) = self.cache.set(&cache_key, &enriched_user, 300).await {
            tracing::warn!("Failed to cache user data: {}", e);
        }

        Ok(enriched_user)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EnrichedUser {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub external_data: Option<serde_json::Value>,
}

#[derive(Debug, thiserror::Error)]
pub enum ApplicationError {
    #[error("User not found")]
    UserNotFound,
    #[error("Database error: {0}")]
    DatabaseError(#[from] DatabaseError),
}
```
