I'll help you implement Spring Boot caching best practices. Let me create a comprehensive guide with examples covering the most important aspects.I've created a comprehensive guide covering Spring Boot cache best practices. Here are the key highlights:

**Essential Setup:**
- Enable caching with `@EnableCaching`
- Configure cache managers (Caffeine recommended for performance)
- Set appropriate TTL and size limits

**Core Patterns:**
- `@Cacheable` for read operations
- `@CacheEvict` for invalidation
- `@CachePut` for updates
- `@Caching` for complex scenarios

**Key Best Practices:**
1. **Smart Key Generation** - Use SpEL expressions or custom key generators
2. **Conditional Caching** - Only cache when beneficial
3. **Error Handling** - Implement graceful fallbacks
4. **Monitoring** - Track hit rates and performance
5. **Testing** - Verify cache behavior in tests

**Common Pitfalls to Avoid:**
- Caching frequently changing data
- Using complex objects as keys without proper hashCode/equals
- Ignoring memory constraints
- Over-caching everything

Would you like me to elaborate on any specific aspect, such as setting up Redis for distributed caching, implementing cache warming strategies, or handling specific use cases like pagination or search results?


# Spring Boot Cache Best Practices Guide

## 1. Basic Setup and Configuration

### Enable Caching
```java
@SpringBootApplication
@EnableCaching
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Cache Configuration
```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(caffeineCacheBuilder());
        return cacheManager;
    }

    @Bean
    public Caffeine<Object, Object> caffeineCacheBuilder() {
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(1000)
                .expireAfterAccess(Duration.ofMinutes(10))
                .expireAfterWrite(Duration.ofMinutes(30))
                .recordStats();
    }
}
```

## 2. Core Cache Annotations

### @Cacheable - Cache Method Results
```java
@Service
public class UserService {

    @Cacheable(value = "users", key = "#id")
    public User findById(Long id) {
        // Expensive database operation
        return userRepository.findById(id).orElse(null);
    }

    @Cacheable(value = "users", key = "#email", condition = "#email != null")
    public User findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    // Complex key generation
    @Cacheable(value = "userSearch", key = "#root.methodName + '_' + #criteria.toString()")
    public List<User> searchUsers(SearchCriteria criteria) {
        return userRepository.findByCriteria(criteria);
    }
}
```

### @CacheEvict - Remove Cache Entries
```java
@Service
public class UserService {

    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }

    @CacheEvict(value = "users", allEntries = true)
    public void refreshAllUsers() {
        // Clear all user cache entries
    }

    @CacheEvict(value = {"users", "userSearch"}, allEntries = true)
    public void clearAllUserCaches() {
        // Clear multiple caches
    }
}
```

### @CachePut - Always Execute and Cache
```java
@Service
public class UserService {

    @CachePut(value = "users", key = "#user.id")
    public User saveUser(User user) {
        User savedUser = userRepository.save(user);
        // Always executes and updates cache
        return savedUser;
    }
}
```

### @Caching - Multiple Cache Operations
```java
@Service
public class UserService {

    @Caching(
        cacheable = @Cacheable(value = "users", key = "#id"),
        evict = @CacheEvict(value = "userSearch", allEntries = true)
    )
    public User findByIdAndClearSearch(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
```

## 3. Advanced Key Generation

### Custom Key Generator
```java
@Component
public class CustomKeyGenerator implements KeyGenerator {
    
    @Override
    public Object generate(Object target, Method method, Object... params) {
        StringBuilder key = new StringBuilder();
        key.append(target.getClass().getSimpleName());
        key.append("_").append(method.getName());
        
        for (Object param : params) {
            if (param != null) {
                key.append("_").append(param.toString());
            }
        }
        
        return key.toString();
    }
}

// Usage
@Cacheable(value = "customCache", keyGenerator = "customKeyGenerator")
public User findUser(String name, String department) {
    return userRepository.findByNameAndDepartment(name, department);
}
```

### SpEL Key Expressions
```java
@Service
public class ProductService {

    // Simple property access
    @Cacheable(value = "products", key = "#product.id")
    public Product saveProduct(Product product) {
        return productRepository.save(product);
    }

    // Method parameter with property
    @Cacheable(value = "products", key = "#user.id + '_' + #category")
    public List<Product> getProductsByUserAndCategory(User user, String category) {
        return productRepository.findByUserAndCategory(user.getId(), category);
    }

    // Conditional caching
    @Cacheable(value = "products", 
               key = "#id", 
               condition = "#id > 0",
               unless = "#result == null")
    public Product findById(Long id) {
        return productRepository.findById(id).orElse(null);
    }
}
```

## 4. Cache Configuration Properties

### application.yml
```yaml
spring:
  cache:
    type: caffeine
    caffeine:
      spec: initialCapacity=100,maximumSize=1000,expireAfterAccess=600s,recordStats
    cache-names:
      - users
      - products
      - orders

logging:
  level:
    org.springframework.cache: DEBUG
```

### Multiple Cache Configurations
```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean("shortTermCache")
    public CacheManager shortTermCacheManager() {
        CaffeineCacheManager manager = new CaffeineCacheManager("users", "sessions");
        manager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(500)
                .expireAfterWrite(Duration.ofMinutes(5)));
        return manager;
    }

    @Bean("longTermCache")
    public CacheManager longTermCacheManager() {
        CaffeineCacheManager manager = new CaffeineCacheManager("products", "categories");
        manager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(Duration.ofHours(1)));
        return manager;
    }
}

// Usage with specific cache manager
@Cacheable(value = "users", cacheManager = "shortTermCache")
public User findUser(Long id) {
    return userRepository.findById(id).orElse(null);
}
```

## 5. Error Handling and Resilience

### Cache Error Handling
```java
@Configuration
public class CacheConfig {

    @Bean
    public CacheErrorHandler errorHandler() {
        return new CacheErrorHandler() {
            @Override
            public void handleCacheGetError(RuntimeException exception, Cache cache, Object key) {
                log.warn("Cache get error for key: {} in cache: {}", key, cache.getName(), exception);
                // Don't throw - allow method to execute normally
            }

            @Override
            public void handleCachePutError(RuntimeException exception, Cache cache, Object key, Object value) {
                log.error("Cache put error for key: {} in cache: {}", key, cache.getName(), exception);
            }

            @Override
            public void handleCacheEvictError(RuntimeException exception, Cache cache, Object key) {
                log.error("Cache evict error for key: {} in cache: {}", key, cache.getName(), exception);
            }

            @Override
            public void handleCacheClearError(RuntimeException exception, Cache cache) {
                log.error("Cache clear error in cache: {}", cache.getName(), exception);
            }
        };
    }
}
```

## 6. Testing Cache Behavior

### Cache Test Configuration
```java
@TestConfiguration
@EnableCaching
public class TestCacheConfig {

    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("users", "products");
    }
}

@SpringBootTest
@Import(TestCacheConfig.class)
class UserServiceCacheTest {

    @Autowired
    private UserService userService;

    @Autowired
    private CacheManager cacheManager;

    @Test
    void shouldCacheUserById() {
        // First call - should hit database
        User user1 = userService.findById(1L);
        
        // Second call - should hit cache
        User user2 = userService.findById(1L);
        
        // Verify cache hit
        Cache userCache = cacheManager.getCache("users");
        assertThat(userCache.get(1L)).isNotNull();
        assertThat(user1).isSameAs(user2);
    }

    @Test
    void shouldEvictCacheOnUpdate() {
        User user = userService.findById(1L);
        
        // Update should evict cache
        user.setName("Updated Name");
        userService.updateUser(user);
        
        // Cache should be empty
        Cache userCache = cacheManager.getCache("users");
        assertThat(userCache.get(1L)).isNull();
    }
}
```

## 7. Monitoring and Metrics

### Cache Statistics
```java
@Component
public class CacheMetrics {

    private final MeterRegistry meterRegistry;
    private final CacheManager cacheManager;

    public CacheMetrics(MeterRegistry meterRegistry, CacheManager cacheManager) {
        this.meterRegistry = meterRegistry;
        this.cacheManager = cacheManager;
    }

    @EventListener
    public void onApplicationReady(ApplicationReadyEvent event) {
        cacheManager.getCacheNames().forEach(this::bindCacheMetrics);
    }

    private void bindCacheMetrics(String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache instanceof CaffeineCache) {
            CaffeineCache caffeineCache = (CaffeineCache) cache;
            CacheMetricsCollector.monitor(meterRegistry, caffeineCache.getNativeCache(), cacheName);
        }
    }
}
```

### Health Check
```java
@Component
public class CacheHealthIndicator implements HealthIndicator {

    private final CacheManager cacheManager;

    public CacheHealthIndicator(CacheManager cacheManager) {
        this.cacheManager = cacheManager;
    }

    @Override
    public Health health() {
        try {
            Health.Builder builder = Health.up();
            
            cacheManager.getCacheNames().forEach(cacheName -> {
                Cache cache = cacheManager.getCache(cacheName);
                builder.withDetail(cacheName, "UP");
            });
            
            return builder.build();
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
}
```

## 8. Best Practices Summary

### DO's
- Use meaningful cache names that reflect the data type
- Implement proper key generation strategies
- Set appropriate TTL and size limits
- Handle cache errors gracefully
- Monitor cache hit rates and performance
- Use conditional caching when appropriate
- Test cache behavior in your unit tests
- Consider cache warming for critical data

### DON'Ts
- Don't cache everything - be selective
- Don't use complex objects as keys without proper toString/hashCode
- Don't ignore memory constraints
- Don't cache data that changes frequently
- Don't forget to handle null values appropriately
- Don't use caching for security-sensitive data without proper consideration
- Don't cache large objects that could cause memory issues

### Performance Tips
```java
// Good: Cache expensive database queries
@Cacheable("userProfiles")
public UserProfile getFullUserProfile(Long userId) {
    return buildComplexUserProfile(userId);
}

// Good: Use conditional caching
@Cacheable(value = "searchResults", 
           condition = "#query.length() > 3",
           unless = "#result.isEmpty()")
public List<Product> search(String query) {
    return searchService.performComplexSearch(query);
}

// Good: Cache method-level, not class-level
@Service
public class ProductService {
    
    @Cacheable("products")
    public Product findById(Long id) { ... }
    
    // Don't cache this - it changes frequently
    public Product updateStock(Long id, int quantity) { ... }
}
```

This guide covers the essential patterns and best practices for implementing robust caching in Spring Boot applications.
