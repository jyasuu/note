以下針對 **分布式事務（2PC/3PC）**、**TCC 模式**、**事件溯源** 和 **Saga 模式** 的深度解析，涵蓋原理、流程、優缺點與適用場景：

---

### 一、分布式事務：2PC 與 3PC
#### **2PC（Two-Phase Commit，兩階段提交）**
- **核心思想**：通過協調者（Coordinator）管理多個參與者（Participants），分兩階段確保所有節點達成一致。
- **流程**：
1. **準備階段（Prepare Phase）**
- 協調者向所有參與者發送事務內容，詢問是否可提交。
- 參與者執行本地事務（但不提交），鎖定資源，返回「就緒」（Yes）或「中止」（No）。
2. **提交階段（Commit Phase）**
- 若所有參與者回覆 Yes，協調者發送 Commit 指令，參與者提交事務並釋放鎖。
- 若有任一參與者回覆 No，協調者發送 Rollback 指令，參與者回滾事務。
- **優點**：強一致性，邏輯簡單。
- **缺點**：
- **同步阻塞**：參與者在準備階段鎖定資源，其他操作需等待。
- **單點故障**：協調者宕機可能導致事務懸掛。
- **資料不一致風險**：Commit 階段若協調者與部分參與者故障，可能導致部分提交。
- **適用場景**：短事務、低併發的內部系統（如傳統銀行核心系統）。

#### **3PC（Three-Phase Commit，三階段提交）**
- **改進點**：引入超時機制與 **Pre-Commit 階段**，降低阻塞風險。
- **流程**：
1. **CanCommit 階段**：協調者詢問參與者是否「有能力」提交（不鎖資源）。
2. **Pre-Commit 階段**：若所有參與者同意，協調者通知參與者預提交（鎖資源，執行本地事務）。
3. **DoCommit 階段**：協調者發送最終 Commit 指令。
- **優點**：
- 參與者在 Pre-Commit 後若未收到指令，會自動提交，減少阻塞時間。
- 協調者故障時，參與者可根據超時自動決策。
- **缺點**：
- 實現更複雜，仍可能因網路分區導致不一致。
- 未完全解決資料不一致問題。
- **適用場景**：對可用性要求略高於 2PC 的場景，但實務中較少使用。

---

### 二、TCC 模式（Try-Confirm-Cancel）
#### **核心思想**：將事務拆分為 **Try（嘗試）**、**Confirm（確認）**、**Cancel（取消）** 三階段，通過業務層補償實現最終一致性。
- **流程**：
1. **Try 階段**：
- 預留資源（如凍結庫存、預扣金額）。
- 檢查業務約束（如帳戶餘額是否足夠）。
2. **Confirm 階段**：
- 若所有 Try 成功，執行實際提交（如扣款、出庫）。
3. **Cancel 階段**：
- 若任一 Try 失敗，執行補償操作（如解凍庫存、退回預扣金額）。
- **優點**：
- 高靈活性：補償邏輯由業務自定義，可處理複雜場景。
- 無需全局鎖：資源預留代替鎖定，提升併發能力。
- **缺點**：
- 業務侵入性高：需為每個操作實現 Try/Confirm/Cancel 接口。
- 補償邏輯複雜：需處理冪等性、懸掛事務（如 Confirm/Cancel 丟失）。
- **適用場景**：
- 高一致性要求的長事務（如電商訂單、跨境支付）。
- 需自定義補償邏輯的業務（如庫存預佔、優惠券核銷）。

#### **TCC 實例：電商下單**
1. **Try**：
- 訂單服務：生成預訂單（狀態為「處理中」）。
- 庫存服務：凍結商品數量。
- 支付服務：預扣用戶帳戶金額。
2. **Confirm**：
- 訂單狀態改為「已付款」，庫存扣減，實際扣款。
3. **Cancel**：
- 訂單狀態改為「已取消」，庫存解凍，金額退回。

---

### 三、事件溯源（Event Sourcing）
#### **核心思想**：不直接存儲系統狀態，而是記錄所有狀態變化的事件（Event），通過重放事件重建當前狀態。
- **關鍵組件**：
- **事件存儲（Event Store）**：持久化事件的不可變日誌（如 Kafka、專用數據庫）。
- **聚合根（Aggregate Root）**：負責生成與應用事件（如訂單對象觸發「訂單已創建」事件）。
- **投影（Projection）**：從事件流生成查詢所需的讀模型（如生成訂單報表）。
- **流程**：
1. 系統接收命令（Command），由聚合根驗證並生成事件。
2. 事件存入 Event Store，並發布到消息隊列。
3. 訂閱者（如讀模型、其他服務）消費事件並更新狀態。
- **優點**：
- 完整審計追溯：可重現任意時間點的狀態。
- 解耦寫入與查詢：支持 CQRS（命令查詢職責分離）。
- 靈活的業務邏輯：可通過新增投影支持新報表，無需修改寫入邏輯。
- **缺點**：
- 事件版本遷移複雜：舊事件需兼容新業務邏輯。
- 查詢性能問題：重建狀態需重放大量事件（可通過快照緩解）。
- **適用場景**：
- 審計與合規要求高的系統（如金融交易、醫療記錄）。
- 需要靈活擴展查詢的場景（如分析型應用）。

#### **事件溯源實例：銀行轉帳**
- **事件流**：
1. `AccountCreated(accountId: A, balance: 100)`
2. `MoneyDeposited(accountId: A, amount: 50)`
3. `MoneyWithdrawn(accountId: A, amount: 30)`
- 當前餘額：通過重放事件計算 `100 + 50 - 30 = 120`。

---

### 四、Saga 模式
#### **核心思想**：將長事務拆分為多個本地事務，通過補償操作（Compensation）回滾已完成的步驟。
- **實現方式**：
- **協同式 Saga（Choreography）**：
- 各服務自行監聽事件並觸發後續操作，無中央協調者。
- 例：訂單服務創建訂單後發布 `OrderCreated` 事件，支付服務監聽並扣款。
- **編排式 Saga（Orchestration）**：
- 由中央協調器（如狀態機）依序調用服務，並管理補償邏輯。
- 例：協調器依次調用「創建訂單」→「扣款」→「出庫」，失敗時觸發反向操作。
- **流程**（以電商下單為例）：
1. 正向操作：
- 訂單服務創建訂單 → 支付服務扣款 → 庫存服務扣減庫存。
2. 若支付失敗：
- 觸發補償：刪除訂單 → 退款（若已扣款）→ 恢復庫存。
- **優點**：
- 適用於長週期、跨多服務的事務（如旅遊訂單涉及機票、酒店、租車）。
- 避免長期資源鎖定，提升系統吞吐量。
- **缺點**：
- 補償邏輯需保障冪等性（如多次退款僅執行一次）。
- 業務侵入性高（需定義正向與反向操作）。
- **適用場景**：
- 跨多服務的業務流程（如供應鏈管理、跨境支付）。
- 無法使用分布式事務的場景（如微服務架構）。

#### **Saga 實例：機票預訂流程（編排式）**
1. 協調器調用「預訂航班」→ 成功。
2. 調用「預訂酒店」→ 失敗。
3. 觸發補償：「取消航班預訂」。

---

### 五、四種模式對比
| 模式          | 一致性強度 | 性能 | 複雜度 | 適用場景                     |
|---------------|------------|------|--------|-----------------------------|
| **2PC/3PC**   | 強一致     | 低   | 低     | 短事務、內部系統            |
| **TCC**       | 最終一致   | 中   | 高     | 需自定義補償的業務長事務    |
| **事件溯源**  | 最終一致   | 中   | 高     | 審計追溯、靈活查詢          |
| **Saga**      | 最終一致   | 高   | 中     | 跨服務長流程、高併發        |

---

### 六、總結
- **2PC/3PC**：簡單強一致，但犧牲可用性，適用封閉環境。
- **TCC**：通過業務補償實現高靈活性，適合複雜業務邏輯。
- **事件溯源**：以事件日誌驅動狀態，強於審計與歷史追溯。
- **Saga**：分散式流程管理，適合跨服務長事務，需謹慎設計補償。

在實際架構中，常組合使用這些模式（如 Saga + 事件溯源記錄操作日誌），並搭配冪等性、重試機制、對帳系統，構建高可靠的分散式系統。
