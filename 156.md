If the issue is related to `HashMap.getEntry` causing high CPU usage, it usually happens when:

*   The `HashMap` has a very large number of entries.
*   There is **hash collision**, causing long linked lists or tree traversal in buckets.
*   The `hashCode()` implementation of keys is poor or returns the same value often.
*   Concurrent access without proper synchronization (if using `HashMap` in multi-threaded code instead of `ConcurrentHashMap`).

To reproduce this in a **unit test**, we can simulate a scenario with **many collisions** and repeatedly call `get()` on the map.

Hereâ€™s an example in **JUnit**:

```java
import org.junit.jupiter.api.Test;
import java.util.HashMap;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class HashMapHighCpuTest {

    static class BadKey {
        private final int id;

        BadKey(int id) {
            this.id = id;
        }

        @Override
        public int hashCode() {
            return 1; // Force all keys into the same bucket
        }

        @Override
        public boolean equals(Object obj) {
            return obj instanceof BadKey && ((BadKey) obj).id == this.id;
        }
    }

    @Test
    public void testHashMapGetEntryHighCpu() {
        HashMap<BadKey, String> map = new HashMap<>();

        // Insert many entries with same hash code
        for (int i = 0; i < 100_000; i++) {
            map.put(new BadKey(i), "Value" + i);
        }

        // Repeatedly access keys to simulate high CPU usage
        for (int i = 0; i < 1_000_000; i++) {
            String value = map.get(new BadKey(i % 100_000));
            assertEquals("Value" + (i % 100_000), value);
        }
    }
}
```

### Why this reproduces the issue:

*   All keys have the same `hashCode()`, so they end up in one bucket.
*   `HashMap.get()` must traverse a long linked list (or tree after threshold), causing CPU spikes.

***

Do you want me to **also create a version that measures execution time and CPU usage**, or **simulate multi-threaded access to show even worse performance**?
