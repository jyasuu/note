è³‡æ–™åº«é·ç§»ï¼ˆDatabase Migrationï¼‰æ˜¯ä¸€é …é«˜é¢¨éšªä½†å¸¸è¦‹çš„ä»»å‹™ï¼Œç„¡è«–æ˜¯**ç·šä¸ŠæŠ„å¯«ï¼ˆonline migrationï¼‰**æˆ–**åœæ©ŸæŠ„å¯«ï¼ˆoffline migrationï¼‰**ï¼Œç¢ºä¿è³‡æ–™æ­£ç¢ºæ€§éƒ½æ˜¯é—œéµã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è¦‹ä¸”æœ‰æ•ˆçš„åšæ³•ï¼š

---

### âœ… è³‡æ–™æ­£ç¢ºæ€§çš„ä¿éšœæªæ–½

#### 1. **å‰æœŸæº–å‚™**
- **è³‡æ–™æ¯”å°å·¥å…·é¸æ“‡**ï¼šé¸æ“‡æ”¯æ´ checksumã€row countã€hash æ¯”å°çš„å·¥å…·ï¼ˆå¦‚ AWS DMSã€Databricksã€SCTã€è‡ªè£½ scriptï¼‰ã€‚
- **Schema æ¯”å°**ï¼šç¢ºèª source å’Œ target è³‡æ–™åº«çš„ schema å®Œå…¨ä¸€è‡´ï¼ŒåŒ…æ‹¬æ¬„ä½å‹åˆ¥ã€ç´¢å¼•ã€constraint ç­‰ã€‚
- **è³‡æ–™é©—è­‰è¨ˆç•«**ï¼šåˆ¶å®šé©—è­‰ç­–ç•¥ï¼Œä¾‹å¦‚æŠ½æ¨£é©—è­‰ã€å…¨é‡æ¯”å°ã€é—œéµæ¬„ä½æ¯”å°ç­‰ã€‚

---

#### 2. **ç·šä¸ŠæŠ„å¯«ï¼ˆOnline Migrationï¼‰**
- **é›™å¯«ï¼ˆDual Writeï¼‰æ©Ÿåˆ¶**ï¼šåœ¨é·ç§»æœŸé–“ï¼Œæ‡‰ç”¨ç¨‹å¼åŒæ™‚å¯«å…¥æ–°èˆŠè³‡æ–™åº«ï¼Œç¢ºä¿è³‡æ–™ä¸€è‡´ã€‚
- **CDCï¼ˆChange Data Captureï¼‰**ï¼šä½¿ç”¨ CDC å·¥å…·æŒçºŒåŒæ­¥è®Šæ›´è³‡æ–™ï¼Œç¢ºä¿é·ç§»æœŸé–“çš„è³‡æ–™ä¸éºæ¼ã€‚
- **å»¶é²åˆ‡æ›ï¼ˆDelayed Cutoverï¼‰**ï¼šå…ˆå°‡è³‡æ–™åŒæ­¥å®Œæˆï¼Œå†é€²è¡Œæµé‡åˆ‡æ›ï¼Œé™ä½é¢¨éšªã€‚

---

#### 3. **åœæ©ŸæŠ„å¯«ï¼ˆOffline Migrationï¼‰**
- **åœæ©Ÿå‰å¿«ç…§**ï¼šåœ¨åœæ©Ÿå‰å°è³‡æ–™åº«åšå¿«ç…§æˆ– dumpï¼Œç¢ºä¿è³‡æ–™å®Œæ•´ã€‚
- **å…¨é‡æ¯”å°**ï¼šé·ç§»å¾Œé€²è¡Œ row countã€checksumã€hash æ¯”å°ï¼Œç¢ºèªè³‡æ–™ä¸€è‡´ã€‚
- **é©—è­‰å ±å‘Š**ï¼šç”¢å‡ºæ¯”å°å ±å‘Šï¼Œä¾› QA æˆ–ä¸»ç®¡å¯©æ ¸ã€‚

---

#### 4. **é©—è­‰æ–¹æ³•**
- **Row Count æ¯”å°**ï¼šæ¯å¼µè¡¨çš„ç­†æ•¸æ˜¯å¦ä¸€è‡´ã€‚
- **Checksum/Hash æ¯”å°**ï¼šæ¯å¼µè¡¨çš„è³‡æ–™å…§å®¹æ˜¯å¦ä¸€è‡´ã€‚
- **æŠ½æ¨£æ¯”å°**ï¼šéš¨æ©ŸæŠ½å–è³‡æ–™é€²è¡Œæ¬„ä½æ¯”å°ã€‚
- **æ¥­å‹™é‚è¼¯é©—è­‰**ï¼šä¾‹å¦‚å¸³å‹™è³‡æ–™æ˜¯å¦å¹³è¡¡ã€äº¤æ˜“ç´€éŒ„æ˜¯å¦å®Œæ•´ã€‚

---

#### 5. **è‡ªå‹•åŒ–èˆ‡ç›£æ§**
- å»ºç«‹è‡ªå‹•åŒ–é©—è­‰è…³æœ¬ï¼ˆPythonã€SQLã€ETL å·¥å…·ï¼‰ã€‚
- è¨­ç½®ç›£æ§èˆ‡å‘Šè­¦æ©Ÿåˆ¶ï¼Œåµæ¸¬ç•°å¸¸è³‡æ–™æˆ–åŒæ­¥å¤±æ•—ã€‚

---

å¦‚æœä½ æœ‰ç‰¹å®šçš„è³‡æ–™åº«é¡å‹ï¼ˆå¦‚ MySQLã€PostgreSQLã€Oracleã€SQL Serverï¼‰æˆ–å·¥å…·éœ€æ±‚ï¼Œæˆ‘å¯ä»¥æä¾›æ›´å…·é«”çš„å»ºè­°æˆ–ç¯„ä¾‹è…³æœ¬ã€‚ä½ ç›®å‰æ˜¯è€ƒæ…®å“ªç¨®é·ç§»æ–¹å¼ï¼Ÿæ˜¯å¦æœ‰æ­£åœ¨ä½¿ç”¨çš„å·¥å…·æˆ–æ¡†æ¶ï¼Ÿ


ä»¥ä¸‹æ˜¯ä¸€å€‹ç”¨ **Rust** å¯¦ä½œçš„ç°¡å–® **Checksum/Hash æ¯”å°å·¥å…·**ï¼Œå¯ä»¥ç”¨ä¾†é©—è­‰å…©ä»½è³‡æ–™æ˜¯å¦ä¸€è‡´ï¼Œå¸¸è¦‹æ–¼è³‡æ–™åº«é·ç§»å¾Œçš„è³‡æ–™é©—è­‰ã€‚

---

### ğŸ¦€ Rust Checksum/Hash æ¯”å°ç¯„ä¾‹

é€™å€‹ç¯„ä¾‹æœƒï¼š
1. è®€å–å…©å€‹æª”æ¡ˆï¼ˆæˆ–è³‡æ–™ä¾†æºï¼‰ã€‚
2. å°æ¯ä¸€è¡Œè¨ˆç®— SHA256 hashã€‚
3. æ¯”å° hash æ˜¯å¦ä¸€è‡´ã€‚

#### ğŸ“¦ ä¾è³´å¥—ä»¶ï¼ˆCargo.tomlï¼‰

```toml
[dependencies]
sha2 = "0.10"
hex = "0.4"
```

#### ğŸ§¾ ä¸»ç¨‹å¼ï¼ˆmain.rsï¼‰

```rust
use sha2::{Sha256, Digest};
use std::fs::File;
use std::io::{BufReader, BufRead};
use std::error::Error;

fn calculate_hash(file_path: &str) -> Result<Vec<String>, Box<dyn Error>> {
    let file = File::open(file_path)?;
    let reader = BufReader::new(file);
    let mut hashes = Vec::new();

    for line in reader.lines() {
        let line = line?;
        let mut hasher = Sha256::new();
        hasher.update(line.as_bytes());
        let result = hasher.finalize();
        hashes.push(hex::encode(result));
    }

    Ok(hashes)
}

fn compare_hashes(hashes1: Vec<String>, hashes2: Vec<String>) {
    if hashes1.len() != hashes2.len() {
        println!("è¡Œæ•¸ä¸ä¸€è‡´ï¼š{} vs {}", hashes1.len(), hashes2.len());
        return;
    }

    for (i, (h1, h2)) in hashes1.iter().zip(hashes2.iter()).enumerate() {
        if h1 != h2 {
            println!("ç¬¬ {} è¡Œä¸ä¸€è‡´", i + 1);
            println!("ä¾†æº1: {}", h1);
            println!("ä¾†æº2: {}", h2);
        }
    }

    println!("æ¯”å°å®Œæˆ");
}

fn main() -> Result<(), Box<dyn Error>> {
    let file1 = "source_data.txt";
    let file2 = "target_data.txt";

    let hashes1 = calculate_hash(file1)?;
    let hashes2 = calculate_hash(file2)?;

    compare_hashes(hashes1, hashes2);

    Ok(())
}
```

---

### âœ… ä½¿ç”¨æ–¹å¼

1. æº–å‚™å…©å€‹æª”æ¡ˆ `source_data.txt` å’Œ `target_data.txt`ã€‚
2. æ¯è¡Œä»£è¡¨ä¸€ç­†è³‡æ–™ï¼ˆä¾‹å¦‚ä¸€ç­† SQL row çš„åºåˆ—åŒ–çµæœï¼‰ã€‚
3. åŸ·è¡Œç¨‹å¼å¾Œæœƒåˆ—å‡ºä¸ä¸€è‡´çš„è¡Œã€‚

---

å¦‚æœä½ æƒ³è¦æ”¯æ´è³‡æ–™åº«ç›´æ¥é€£ç·šï¼ˆä¾‹å¦‚ PostgreSQLã€MySQLï¼‰ï¼Œä¹Ÿå¯ä»¥æ“´å……ä½¿ç”¨ `sqlx` æˆ– `diesel` å¥—ä»¶ä¾†è®€å–è³‡æ–™è¡¨ä¸¦é€²è¡Œ hash æ¯”å°ã€‚æˆ‘å¯ä»¥å¹«ä½ æ“´å……é€™éƒ¨åˆ†ï¼Œå¦‚æœä½ æœ‰ç‰¹å®šçš„è³‡æ–™åº«é¡å‹æˆ–æ¬„ä½æ ¼å¼ï¼Œæ­¡è¿å‘Šè¨´æˆ‘ï¼ä½ ç›®å‰æ˜¯è¦æ¯”å°å“ªç¨®è³‡æ–™ä¾†æºå‘¢ï¼Ÿ



å¤ªå¥½äº†ï¼æ—¢ç„¶ä½ ä½¿ç”¨çš„æ˜¯ **PostgreSQL**ï¼Œæˆ‘å€‘å¯ä»¥æ“´å…… Rust ç¨‹å¼ä¾†ç›´æ¥å¾è³‡æ–™åº«è®€å–è³‡æ–™ï¼Œè¨ˆç®—æ¯ç­†è³‡æ–™çš„ **SHA256 hash**ï¼Œä¸¦èˆ‡å¦ä¸€å€‹è³‡æ–™åº«æˆ–è³‡æ–™ä¾†æºé€²è¡Œæ¯”å°ã€‚

---

### ğŸ¦€ ç”¨ Rust å° PostgreSQL è³‡æ–™é€²è¡Œ Checksum/Hash æ¯”å°

#### ğŸ“¦ Cargo.toml å¥—ä»¶ä¾è³´

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
sqlx = { version = "0.7", features = ["postgres", "runtime-tokio-native-tls"] }
sha2 = "0.10"
hex = "0.4"
```

---

#### ğŸ§¾ ä¸»ç¨‹å¼ç¯„ä¾‹ï¼ˆmain.rsï¼‰

```rust
use sqlx::postgres::PgPoolOptions;
use sha2::{Sha256, Digest};
use hex;
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    // è³‡æ–™åº«é€£ç·šè¨­å®š
    let source_db_url = "postgres://user:password@localhost/source_db";
    let target_db_url = "postgres://user:password@localhost/target_db";

    // å»ºç«‹é€£ç·šæ± 
    let source_pool = PgPoolOptions::new().connect(source_db_url).await?;
    let target_pool = PgPoolOptions::new().connect(target_db_url).await?;

    // è¦æ¯”å°çš„è³‡æ–™è¡¨èˆ‡æ¬„ä½
    let table = "your_table";
    let key_column = "id"; // ä¸»éµæ¬„ä½
    let data_columns = vec!["name", "email", "created_at"]; // è¦ hash çš„æ¬„ä½

    // å¾ source è³‡æ–™åº«è®€å–è³‡æ–™
    let source_rows = sqlx::query(&format!(
        "SELECT {}, {} FROM {}",
        key_column,
        data_columns.join(", "),
        table
    ))
    .fetch_all(&source_pool)
    .await?;

    // å¾ target è³‡æ–™åº«è®€å–è³‡æ–™
    let target_rows = sqlx::query(&format!(
        "SELECT {}, {} FROM {}",
        key_column,
        data_columns.join(", "),
        table
    ))
    .fetch_all(&target_pool)
    .await?;

    // è¨ˆç®— hash
    let mut source_hashes = HashMap::new();
    for row in source_rows {
        let key: i32 = row.get(key_column);
        let mut hasher = Sha256::new();
        for col in &data_columns {
            let value: String = row.get(col);
            hasher.update(value.as_bytes());
        }
        let hash = hex::encode(hasher.finalize());
        source_hashes.insert(key, hash);
    }

    // æ¯”å° hash
    for row in target_rows {
        let key: i32 = row.get(key_column);
        let mut hasher = Sha256::new();
        for col in &data_columns {
            let value: String = row.get(col);
            hasher.update(value.as_bytes());
        }
        let hash = hex::encode(hasher.finalize());

        match source_hashes.get(&key) {
            Some(source_hash) if source_hash != &hash => {
                println!("è³‡æ–™ä¸ä¸€è‡´ï¼šID {} -> source: {}, target: {}", key, source_hash, hash);
            }
            None => {
                println!("target è³‡æ–™åº«æœ‰é¡å¤–è³‡æ–™ï¼šID {}", key);
            }
            _ => {}
        }
    }

    println!("æ¯”å°å®Œæˆï¼");
    Ok(())
}
```

---

### âœ… æ³¨æ„äº‹é …

- ä½ å¯ä»¥æ ¹æ“šå¯¦éš›æ¬„ä½å‹åˆ¥èª¿æ•´ `row.get::<String>(col)` çš„å‹åˆ¥ã€‚
- è‹¥è³‡æ–™é‡å¤§ï¼Œå»ºè­°åˆ†æ‰¹è™•ç†æˆ–ä½¿ç”¨ streamã€‚
- è‹¥è³‡æ–™è¡¨æ²’æœ‰ä¸»éµï¼Œå¯ä»¥ç”¨ row number æˆ– composite keyã€‚

---

éœ€è¦æˆ‘å¹«ä½ æ ¹æ“šå¯¦éš›çš„è³‡æ–™è¡¨çµæ§‹ç”¢ç”Ÿå®Œæ•´ç¨‹å¼å—ï¼Ÿä½ å¯ä»¥æä¾›ï¼š
- è³‡æ–™è¡¨åç¨±
- æ¬„ä½æ¸…å–®
- ä¸»éµæ¬„ä½
- è³‡æ–™åº«é€£ç·šæ–¹å¼ï¼ˆæ˜¯å¦ä½¿ç”¨ SSLã€portã€hostï¼‰

æˆ‘å¯ä»¥å¹«ä½ å®¢è£½åŒ–é€™æ®µç¨‹å¼ç¢¼ã€‚ä½ ç›®å‰æ˜¯è¦æ¯”å°å“ªå…©å€‹ PostgreSQL è³‡æ–™åº«ï¼Ÿ
