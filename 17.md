以下整理常見的**程式設計設計模式**，針對應用場景和快速選擇方法，以「簡明分類 + 場景判斷」方式呈現：

---

## 一、創建型模式（處理物件創建）
### 1. 單例模式 (Singleton)
- **場景**：全局唯一實例（如配置管理、日誌記錄、資料庫連接池）。
- **快速選擇**：當系統需要嚴格控制某個類別的實例數量（只能有一個）時使用。
- **陷阱**：多線程環境需處理同步問題。

### 2. 工廠方法 (Factory Method)
- **場景**：需要創建多種相似物件，但具體類型由子類決定（如UI組件跨平台生成）。
- **快速選擇**：當「物件創建邏輯可能變化」或「需要解耦使用者與具體類別」時。
- **舉例**：`Button` 介面，由 `WindowsButton` 和 `MacButton` 實現，通過 `ButtonFactory` 創建。

### 3. 抽象工廠 (Abstract Factory)
- **場景**：創建「產品家族」（如跨平台UI套件：按鈕+視窗+選單需風格一致）。
- **快速選擇**：當需要確保一組相關物件必須一起使用時。
- **舉例**：遊戲中「奇幻風格」與「科幻風格」的角色、武器、場景需成套創建。

### 4. 建造者模式 (Builder)
- **場景**：構造複雜物件（如組裝電腦、生成PDF文件），需分步驟設定參數。
- **快速選擇**：當物件構造過程需要「靈活組合參數」或「隱藏構造細節」時。
- **區別工廠**：工廠直接返回完整物件；建造者逐步配置。

### 5. 原型模式 (Prototype)
- **場景**：需要高效複製已有物件（如遊戲中大量生成相似NPC）。
- **快速選擇**：當物件創建成本高（如需讀取資料庫），且新物件與現有物件差異小時。

---

## 二、結構型模式（處理物件組合）
### 1. 適配器模式 (Adapter)
- **場景**：整合不相容的介面（如將舊系統API包裝成新介面）。
- **快速選擇**：當需要「讓兩個不兼容的類別協同工作」時。
- **類型**：類別適配器（繼承）、物件適配器（組合）。

### 2. 裝飾器模式 (Decorator)
- **場景**：動態擴充功能（如為咖啡加糖、加牛奶，且可疊加）。
- **快速選擇**：當需要「避免通過繼承爆炸式增加子類」來擴展功能時。
- **核心**：用組合替代繼承，保持開放-封閉原則。

### 3. 代理模式 (Proxy)
- **場景**：控制物件訪問（延遲載入、權限驗證、日誌記錄）。
- **快速選擇**：當需要「間接訪問物件」或「添加中間層控制」時。
- **舉例**：圖片懶加載代理、API呼叫的緩存代理。

### 4. 外觀模式 (Facade)
- **場景**：簡化複雜子系統的呼叫（如一鍵啟動電腦：開CPU、記憶體、硬碟）。
- **快速選擇**：當需要為複雜模組提供「統一的高層介面」時。

---

## 三、行為型模式（處理物件互動）
### 1. 策略模式 (Strategy)
- **場景**：多種算法可互換（如支付方式選擇：信用卡、PayPal、加密貨幣）。
- **快速選擇**：當需要「在運行時動態切換行為」時。
- **優勢**：避免多重條件判斷（if-else/switch）。

### 2. 觀察者模式 (Observer)
- **場景**：一對多的事件通知（如用戶訂閱新聞，當新聞更新時通知所有訂閱者）。
- **快速選擇**：當需要「解耦事件發送者與接收者」時。
- **應用**：GUI事件處理、發布-訂閱系統。

### 3. 命令模式 (Command)
- **場景**：將請求封裝為物件（如實現撤銷/重做、任務隊列、遠程呼叫）。
- **快速選擇**：當需要「分離請求發送者與執行者」或「支持事務操作」時。

### 4. 責任鏈模式 (Chain of Responsibility)
- **場景**：多個處理者按順序處理請求（如HTTP中間件、審批流程）。
- **快速選擇**：當需要「動態決定由哪個物件處理請求」時。

### 5. 狀態模式 (State)
- **場景**：物件行為隨內部狀態改變（如電梯的運行/停止/故障狀態）。
- **快速選擇**：當存在大量狀態相關的條件判斷，且狀態轉換複雜時。

---

## 四、快速選擇流程圖
```
1. 需要控制物件創建？ → 創建型模式
   - 唯一實例？ → 單例
   - 複雜構造？ → 建造者
   - 多種類物件？ → 工廠/抽象工廠

2. 需要重組或擴展物件結構？ → 結構型模式
   - 介面不兼容？ → 適配器
   - 動態添加功能？ → 裝飾器
   - 簡化複雜系統？ → 外觀

3. 需要管理物件互動邏輯？ → 行為型模式
   - 算法切換？ → 策略
   - 事件通知？ → 觀察者
   - 狀態驅動行為？ → 狀態
```

---

## 五、重點總結
- **優先組合而非繼承**：裝飾器、策略等模式都強調組合的靈活性。
- **解耦是核心目標**：工廠解耦創建、觀察者解耦事件、命令解耦請求。
- **識別重複程式碼**：若多處有相似條件判斷（如狀態檢查），可能適用狀態/策略模式。

建議實際開發時，先明確痛點（如擴展性、耦合度高），再反向匹配模式，而非強行套用。
