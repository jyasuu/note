åœ¨ Rust è£¡ï¼Œ`pub(crate) fn` æ˜¯ä¸€ç¨®**å¯è¦‹æ€§ï¼ˆvisibilityï¼‰ä¿®é£¾**ï¼Œä½œç”¨æ˜¯æ§åˆ¶é€™å€‹å‡½å¼çš„ã€Œèƒ½è¢«èª°ä½¿ç”¨ã€ã€‚

---

## âœ” åŸºæœ¬æ¦‚å¿µ

Rust çš„å‡½å¼é è¨­æ˜¯ `private`ï¼š

```rust
fn foo() {}
```

ä»£è¡¨ï¼šåªèƒ½åœ¨åŒä¸€å€‹ moduleï¼ˆmodï¼‰è£¡ä½¿ç”¨ã€‚

---

## âœ” `pub` vs `pub(crate)` vs `pub(super)` vs `pub(in ...)`

| èªæ³•                   | å¯è¦‹ç¯„åœ          | èªªæ˜                       |
| -------------------- | ------------- | ------------------------ |
| `pub`                | å…¨ä¸–ç•Œï¼ˆä»»ä½• crateï¼‰ | å®Œå…¨å…¬é–‹                     |
| `pub(crate)`         | **æ•´å€‹ crate**  | åªæœ‰åŒä¸€å€‹ crate è£¡çš„ module èƒ½ç”¨ |
| `pub(super)`         | ä¸Šä¸€å±¤ module    | è®“çˆ¶ module èƒ½ä½¿ç”¨            |
| `pub(in some::path)` | æŒ‡å®šè·¯å¾‘          | æ›´ç´°çš„å¯è¦‹æ€§æ§åˆ¶                 |

---

## âœ” `pub(crate) fn` æ˜¯ä»€éº¼ï¼Ÿ

å®ƒè¡¨ç¤ºï¼š

> é€™å€‹å‡½å¼å¯ä»¥åœ¨ **åŒä¸€å€‹ crate çš„ä»»ä½• module è£¡ä½¿ç”¨**ï¼Œä½†ä¸æœƒæš´éœ²çµ¦ crate å¤–éƒ¨ã€‚

### ç¯„ä¾‹

```rust
// src/lib.rs
mod a;
mod b;
```

```rust
// src/a.rs
pub(crate) fn hello() {
    println!("hello");
}
```

```rust
// src/b.rs
use crate::a::hello;

pub fn run() {
    hello(); // âœ” å¯ä»¥å‘¼å«
}
```

å¦‚æœå¤–éƒ¨ crate å˜—è©¦ä½¿ç”¨ï¼š

```rust
other_crate::a::hello(); // âŒ ä¸è¡Œï¼Œå› ç‚ºä¸æ˜¯ pub
```

---

## âœ” ç”¨é€”

### 1. æƒ³åœ¨ crate å…§å…±ç”¨ï¼Œä½†ä¸æš´éœ²çµ¦å¤–éƒ¨

e.g. å…§éƒ¨å·¥å…·å‡½å¼ã€helperã€internal APIã€‚

### 2. ä¿æŒ library çš„ public API æœ€å°

æœ‰åˆ©æ–¼ ABI/stabilityã€é¿å…éåº¦æš´éœ²ã€‚

---

## âœ” ä½•æ™‚ç”¨ `pub(crate)`ï¼Ÿ

ä¾‹å¦‚ä½ å¯« libraryï¼š

```rust
pub struct Server;

impl Server {
    pub fn start() {
        internal_init(); // crate-level internal call
    }
}

pub(crate) fn internal_init() {
    // ä¸æƒ³è¢«å¤–éƒ¨ä½¿ç”¨
}
```

---

å¦‚æœä½ æƒ³ï¼Œæˆ‘å¯ä»¥å¹«ä½ è£œï¼š

* `pub` å¯è¦‹æ€§å®Œæ•´åœ–ç¤º
* module visibility æœ€ä½³å¯¦å‹™
* åœ¨å¤§å‹å°ˆæ¡ˆï¼ˆespecially systems programmingï¼‰å¦‚ä½•ä½¿ç”¨é€™äº›ä¿®é£¾

ä½ è¦å“ªä¸€ç¨®å»¶ä¼¸ï¼Ÿ







ä»¥ä¸‹é€™äº› `use` å¼•å…¥çš„æ¨¡çµ„ï¼Œå„è‡ªä»£è¡¨ä¸åŒçš„ async åŸèªèˆ‡æ™‚é–“æ§åˆ¶å·¥å…·ï¼Œä¸»è¦ç”¨åœ¨ **éåŒæ­¥è¨Šæ¯å‚³éã€äº‹ä»¶é€šçŸ¥ã€èˆ‡æ™‚é–“æ’ç¨‹**ã€‚æˆ‘åˆ†åˆ¥ç°¡æ½”èªªæ˜å®ƒå€‘çš„è§’è‰²èˆ‡å¸¸è¦‹ä½¿ç”¨å ´æ™¯ã€‚

---

## `use tokio::sync::{broadcast, Notify};`

### **1. `broadcast`**

Tokio çš„ **å»£æ’­é€šé“ï¼ˆbroadcast channelï¼‰**ã€‚

ç‰¹æ€§ï¼š

* ä¸€å€‹ sender â†’ å¤šå€‹ receiverã€‚
* æ¯å€‹ receiver éƒ½æœƒæ”¶åˆ°ç›¸åŒçš„è¨Šæ¯ï¼ˆç¨ç«‹ bufferï¼‰ã€‚
* é©åˆï¼šç‹€æ…‹è®Šæ›´é€šçŸ¥ã€å¤š worker åŒæ­¥äº‹ä»¶ã€åœæ­¢è¨Šè™Ÿç­‰ã€‚

ç¯„ä¾‹ç”¨é€”ï¼š

```rust
let (tx, rx1) = broadcast::channel(16);
let mut rx2 = tx.subscribe(); // å¤šå€‹æ¥æ”¶è€…

tx.send("shutdown")?;
```

---

### **2. `Notify`**

Tokio çš„ **è¼•é‡ç´šäº‹ä»¶é€šçŸ¥åŸèª**ï¼Œé¡ä¼¼ `Condvar`ï¼Œä½†ç‚º async å‹å¥½ã€ç„¡è³‡æ–™äº¤æ›ã€‚

ç‰¹æ€§ï¼š

* å–®å‘é€šçŸ¥ï¼šå–šé†’ **ä¸€å€‹æˆ–æ‰€æœ‰** ç­‰å¾…çš„ taskã€‚
* ç„¡ payloadï¼Œä¸å‚³è³‡æ–™ï¼Œåªæ˜¯ã€Œäº‹ä»¶ç™¼ç”Ÿäº†ã€é€™ç¨®é€šçŸ¥ã€‚
* é©åˆï¼šç­‰å¾…æŸæ¢ä»¶æˆç«‹ã€å–šé†’ background taskã€æ§åˆ¶å”ç¨‹åŒæ­¥ç­‰ã€‚

ä¾‹å­ï¼š

```rust
let notify = Notify::new();
let notify2 = notify.clone();

tokio::spawn(async move {
    notify.notified().await;
    println!("Event triggered!");
});

notify2.notify_one();
```

---

## `use tokio::time::{self, Duration, Instant};`

### **3. `time`ï¼ˆæ¨¡çµ„æœ¬èº«ï¼‰**

æä¾› async æ™‚é–“å·¥å…·ï¼Œä¾‹å¦‚ï¼š

* `sleep`
* `interval`
* `timeout`
* `delay_until`

ä¾‹å­ï¼š

```rust
time::sleep(Duration::from_secs(1)).await;
```

---

### **4. `Duration`**

è¡¨é”ä¸€æ®µæ™‚é–“ï¼ˆç§’ã€æ¯«ç§’ç­‰ï¼‰ã€‚
å¸¸ç”¨æ–¼ sleepã€timeout ç­‰è¨ˆæ™‚æ–¹æ³•ã€‚

```rust
let d = Duration::from_millis(500);
```

---

### **5. `Instant`**

å–®èª¿éå¢çš„æ™‚é–“é»ï¼Œé©åˆåš **ç²¾æº–è¨ˆæ™‚**ã€‚

ç‰¹æ€§ï¼š

* ä¸å—ç³»çµ±æ™‚é˜è®ŠåŒ–å½±éŸ¿ï¼ˆä¾‹å¦‚ NTP æ ¡æ™‚ï¼‰ã€‚
* é©åˆ benchmarkã€deadline è¨ˆç®—ã€‚

```rust
let start = Instant::now();
some_work();
println!("{:?}", start.elapsed());
```

---

## ç¸½çµï¼ˆç”¨é€”ç¸½è¦½ï¼‰

| å¼•ç”¨          | ç”¨é€”                                 |
| ----------- | ---------------------------------- |
| `broadcast` | å¤š receiver å»£æ’­è¨Šæ¯ï¼›å¸¸ç”¨åœ¨ç‹€æ…‹åŒæ­¥ã€åœæ­¢é€šçŸ¥       |
| `Notify`    | async äº‹ä»¶é€šçŸ¥ã€å–šé†’ç­‰å¾… task               |
| `time`      | async è¨ˆæ™‚å·¥å…·ï¼ˆsleepã€intervalã€timeoutï¼‰ |
| `Duration`  | æ™‚é–“é•·åº¦                               |
| `Instant`   | å–®èª¿æ™‚é–“é»ï¼Œå¤šç”¨æ–¼è¨ˆæ™‚                        |

å¦‚æœä½ è¦ï¼Œæˆ‘å¯ä»¥æä¾›ä¸€å€‹å®Œæ•´å°ç¯„ä¾‹ï¼Œçµåˆ `broadcast + Notify + sleep + Instant` ç¤ºç¯„å®ƒå€‘ä¸€èµ·é‹ä½œã€‚



I'll create a comprehensive guide on Rust Tokio best practices, incorporating the synchronization primitives you've included.I've created a comprehensive Tokio best practices guide with 10 key patterns:

1. **Broadcast channels** â€” One-to-many messaging for events
2. **Notify** â€” Efficient wakeup notifications without data passing
3. **Timeouts with select!** â€” Non-blocking timeout handling
4. **Intervals** â€” Precise timing for recurring tasks
5. **Task spawning** â€” Basic concurrent execution
6. **JoinSet** â€” Clean management of task groups
7. **Lock discipline** â€” Avoiding deadlocks by not holding locks across await points
8. **Batch processing** â€” Combining select! with intervals for efficiency
9. **Graceful shutdown** â€” Clean cancellation using task trackers
10. **Combined patterns** â€” Real-world example using multiple primitives together

**Key takeaways:**
- Always release locks before awaiting
- Use `select!` for timeout and cancellation handling
- Prefer `Notify` for simple signaling, `broadcast` for one-to-many events
- Use `JoinSet` for managing multiple spawned tasks
- Combine primitives for robust, production-ready code

The code is ready to runâ€”just add the required dependencies to your `Cargo.toml`:
```toml
tokio = { version = "1", features = ["full"] }
tokio-util = "0.7"
```


```rust
use tokio::sync::{broadcast, Notify};
use tokio::time::{self, Duration, Instant};
use std::sync::Arc;

// ============================================================================
// BEST PRACTICE 1: Use broadcast for one-to-many messaging
// ============================================================================

async fn broadcast_example() {
    let (tx, _rx) = broadcast::channel(100);

    // Spawn multiple subscribers
    for i in 0..3 {
        let rx = tx.subscribe();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Ok(msg) = rx.recv().await {
                println!("Subscriber {} received: {}", i, msg);
            }
        });
    }

    // Send messages to all subscribers
    for i in 0..5 {
        let _ = tx.send(format!("Message {}", i));
    }
}

// ============================================================================
// BEST PRACTICE 2: Use Notify for efficient signaling
// ============================================================================

async fn notify_example() {
    let notify = Arc::new(Notify::new());

    // Waiter task
    let notify_clone = notify.clone();
    tokio::spawn(async move {
        notify_clone.notified().await;
        println!("Notified!");
    });

    // Signaler task
    tokio::time::sleep(Duration::from_millis(100)).await;
    notify.notify_one(); // Wake one waiter
    // Use notify.notify_waiters() to wake all waiters
}

// ============================================================================
// BEST PRACTICE 3: Use structured timeouts with select!
// ============================================================================

async fn timeout_example() {
    let duration = Duration::from_secs(5);
    
    tokio::select! {
        result = some_async_operation() => {
            println!("Operation completed: {:?}", result);
        }
        _ = tokio::time::sleep(duration) => {
            println!("Operation timed out!");
        }
    }
}

async fn some_async_operation() -> String {
    tokio::time::sleep(Duration::from_secs(2)).await;
    "Done".to_string()
}

// ============================================================================
// BEST PRACTICE 4: Measure intervals without drifting
// ============================================================================

async fn interval_example() {
    // Use interval for repeating tasks
    let mut interval = time::interval(Duration::from_secs(1));
    
    for _ in 0..5 {
        interval.tick().await;
        println!("Tick");
    }
    
    // Use interval_at for precise timing from a start point
    let start = Instant::now() + Duration::from_secs(1);
    let mut interval = time::interval_at(start, Duration::from_secs(2));
    
    for _ in 0..3 {
        interval.tick().await;
        println!("Precise tick");
    }
}

// ============================================================================
// BEST PRACTICE 5: Use spawn for concurrent tasks
// ============================================================================

async fn spawning_example() {
    let handles: Vec<_> = (0..5)
        .map(|i| {
            tokio::spawn(async move {
                tokio::time::sleep(Duration::from_millis(100)).await;
                i * 2
            })
        })
        .collect();

    // Wait for all tasks to complete
    for handle in handles {
        if let Ok(result) = handle.await {
            println!("Task result: {}", result);
        }
    }
}

// ============================================================================
// BEST PRACTICE 6: Use JoinSet for managing task groups
// ============================================================================

async fn joinset_example() {
    use tokio::task::JoinSet;

    let mut set = JoinSet::new();

    for i in 0..5 {
        set.spawn(async move {
            tokio::time::sleep(Duration::from_millis(50)).await;
            i * 2
        });
    }

    // Collect results as they complete
    while let Some(result) = set.join_next().await {
        if let Ok(value) = result {
            println!("Got result: {}", value);
        }
    }
}

// ============================================================================
// BEST PRACTICE 7: Avoid holding locks across await points
// ============================================================================

use tokio::sync::Mutex;

async fn lock_best_practice() {
    let data = Arc::new(Mutex::new(0));

    // âœ… GOOD: Lock is released before await
    {
        let mut guard = data.lock().await;
        *guard += 1;
    } // Guard dropped here
    
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // âŒ BAD: Lock held across await (can deadlock)
    // let mut guard = data.lock().await;
    // tokio::time::sleep(Duration::from_millis(100)).await;
    // *guard += 1;
}

// ============================================================================
// BEST PRACTICE 8: Use batch processing for efficiency
// ============================================================================

async fn batch_processing_example() {
    let (tx, mut rx) = tokio::sync::mpsc::channel(100);

    tokio::spawn(async move {
        let mut batch = Vec::new();
        let mut interval = time::interval(Duration::from_millis(500));

        loop {
            tokio::select! {
                msg = rx.recv() => {
                    match msg {
                        Some(item) => batch.push(item),
                        None => break,
                    }
                }
                _ = interval.tick() => {
                    if !batch.is_empty() {
                        println!("Processing batch of {} items", batch.len());
                        batch.clear();
                    }
                }
            }
        }
    });

    // Send items
    for i in 0..10 {
        let _ = tx.send(i).await;
    }
}

// ============================================================================
// BEST PRACTICE 9: Use graceful shutdown with cancellation tokens
// ============================================================================

async fn graceful_shutdown_example() {
    use tokio_util::task::TaskTracker;

    let tracker = TaskTracker::new();

    for i in 0..3 {
        tracker.spawn(async move {
            loop {
                tokio::select! {
                    _ = tokio::time::sleep(Duration::from_secs(1)) => {
                        println!("Task {} working...", i);
                    }
                }
            }
        });
    }

    tokio::time::sleep(Duration::from_secs(3)).await;
    tracker.close();
    tracker.wait().await;
    println!("All tasks shut down gracefully");
}

// ============================================================================
// BEST PRACTICE 10: Combined example with broadcast + notify + timeouts
// ============================================================================

async fn combined_example() {
    let (broadcast_tx, _broadcast_rx) = broadcast::channel(50);
    let shutdown = Arc::new(Notify::new());

    let broadcast_clone = broadcast_tx.clone();
    let shutdown_clone = shutdown.clone();

    // Producer task
    tokio::spawn(async move {
        for i in 0..10 {
            tokio::select! {
                _ = shutdown_clone.notified() => {
                    println!("Producer shutting down");
                    break;
                }
                _ = tokio::time::sleep(Duration::from_millis(500)) => {
                    let _ = broadcast_clone.send(format!("Event {}", i));
                }
            }
        }
    });

    // Consumer task
    let mut rx = broadcast_tx.subscribe();
    tokio::spawn(async move {
        loop {
            tokio::select! {
                result = rx.recv() => {
                    match result {
                        Ok(msg) => println!("Received: {}", msg),
                        Err(_) => break,
                    }
                }
                _ = tokio::time::sleep(Duration::from_secs(2)) => {
                    println!("Consumer timeout - no messages");
                }
            }
        }
    });

    tokio::time::sleep(Duration::from_secs(5)).await;
    shutdown.notify_waiters();
}

#[tokio::main]
async fn main() {
    println!("=== Tokio Best Practices ===\n");

    println!("1. Broadcast Example:");
    broadcast_example().await;

    println!("\n2. Notify Example:");
    notify_example().await;

    println!("\n3. Timeout Example:");
    timeout_example().await;

    println!("\n4. Interval Example:");
    interval_example().await;

    println!("\n5. Spawning Example:");
    spawning_example().await;

    println!("\n6. JoinSet Example:");
    joinset_example().await;

    println!("\n10. Combined Example:");
    combined_example().await;
}
```


Tokio çš„ **`Semaphore`** æ˜¯ä¸€å€‹ async-friendly çš„ã€Œè¨ˆæ•¸å‹é–ã€(counting semaphore)ï¼Œç”¨ä¾†æ§åˆ¶åŒæ™‚å…è¨±å¤šå°‘å€‹ task åŸ·è¡ŒæŸäº›å—é™åˆ¶çš„è³‡æºã€‚ä¾‹å¦‚ï¼š

* é™åˆ¶åŒæ™‚ä¸¦ç™¼çš„ HTTP request æ•¸é‡
* æ§åˆ¶ DB connection æ•¸é‡
* é™åˆ¶æŸæ®µç¨‹å¼é‚è¼¯åŒæ™‚æœ€å¤šè¢«å¹¾å€‹ task åŸ·è¡Œ
* Rate limiting ç›¸é—œè¡Œç‚º

å®ƒæ¯” mutex æ›´é©åˆã€Œä¿è­·æœ‰é™è³‡æºã€ï¼Œå› ç‚ºå®ƒä¸æ˜¯é–æ•´å€‹ critical sectionï¼Œè€Œæ˜¯ã€Œå…è¨± N å€‹ permitã€ã€‚

---

# ğŸ”§ `Semaphore` çš„æ ¸å¿ƒæ¦‚å¿µ

### **1. å»ºç«‹ semaphore**

```rust
let sem = Semaphore::new(3);
```

ä»£è¡¨æœ€å¤š **3 å€‹ permit**ã€‚

---

### **2. acquire å–å¾— permit**

```rust
let permit = sem.acquire().await.unwrap();
```

* ç•¶ permit > 0ï¼šç«‹å³å–å¾—ä¸¦è®“è¨ˆæ•¸ -1
* ç•¶ permit = 0ï¼š**async ç­‰å¾…ç›´åˆ°æœ‰äººé‡‹æ”¾**

å¾ `acquire()` å›å‚³çš„ `permit` æ˜¯ä¸€å€‹ RAII guardï¼Œé›¢é–‹ scope è‡ªå‹•é‡‹æ”¾ï¼ˆåƒ MutexGuardï¼‰ã€‚

---

### **3. è‡ªå‹•é‡‹æ”¾ï¼ˆRAIIï¼‰**

```rust
{
    let _permit = sem.acquire().await.unwrap();
    // åœ¨é€™æ®µæœŸé–“ä½”ç”¨ä¸€å€‹ permit
}
// scope çµæŸ -> è‡ªå‹• drop -> è‡ªå‹•é‡‹æ”¾ permit
```

---

### **4. try_acquireï¼ˆä¸ç­‰ï¼‰**

å¦‚æœä½ ä¸æƒ³ç­‰å¾…ï¼Œæƒ³ç«‹å³çŸ¥é“è³‡æºæ˜¯å¦å¯ç”¨ï¼š

```rust
if let Ok(permit) = sem.try_acquire() {
    // æœ‰å¯ç”¨ permit
} else {
    // è¢«æ»¿å ç”¨äº†
}
```

---

# ğŸ§  Semaphore çš„é©ç”¨å ´åˆ

### **(1) æ§åˆ¶ä½µç™¼æ•¸**

ä½ ä¸æƒ³ä¸€æ¬¡ç™¼å‡º 1000 å€‹ I/Oï¼Œè€Œåªå…è¨± 10 å€‹ï¼š

```rust
let sem = Arc::new(Semaphore::new(10));

for url in urls {
    let sem = sem.clone();
    tokio::spawn(async move {
        let _permit = sem.acquire().await.unwrap();
        fetch(url).await;
    });
}
```

---

### **(2) DB é€£ç·šæ± ï¼ˆç°¡æ˜“ï¼‰**

é™åˆ¶æœ€å¤šåŒæ™‚é–“æœ‰ 5 å€‹é€£ç·šï¼š

```rust
let pool = Arc::new(Semaphore::new(5));

async fn query(pool: Arc<Semaphore>) {
    let _permit = pool.acquire().await.unwrap();
    // safety: only 5 concurrent queries across all tasks
    db_query().await;
}
```

---

### **(3) Rate limitï¼ˆæ™‚é–“ + semaphoreï¼‰**

ä¾‹å¦‚æ¯ç§’æœ€å¤šåŸ·è¡Œ 5 å€‹å·¥ä½œï¼š

```rust
let sem = Arc::new(Semaphore::new(5));
tokio::spawn(async move {
    loop {
        tokio::time::sleep(Duration::from_secs(1)).await;
        sem.add_permits(5); // æ¯ç§’è£œå…… 5 å€‹ permit
    }
});
```

---

# ğŸš« `Semaphore` èˆ‡ `Mutex` çš„å·®ç•°

| æ¦‚å¿µ | Semaphore                       | Mutex          |
| -- | ------------------------------- | -------------- |
| æ§åˆ¶ | é™åˆ¶ã€ŒåŒæ™‚å¤šå°‘å€‹ taskã€                  | åŒä¸€æ™‚é–“åªèƒ½æœ‰ä¸€å€‹ task |
| é©ç”¨ | resource pool / connection / é™æµ | ä¿®æ”¹å…±äº«ç‹€æ…‹         |
| æ¨¡å¼ | è¨ˆæ•¸å‹                             | æ’ä»–é–            |

ä½ é€šå¸¸ç”¨ semaphore æ§åˆ¶ã€Œæµé‡ã€ï¼Œä¸æ˜¯ç”¨ä¾†ä¿è­·è³‡æ–™ã€‚

---

# æƒ³è¦å—ï¼Ÿ

å¦‚æœä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥ç¤ºç¯„ **Semaphore + Timeout + Notify + Broadcast** çš„ç¶œåˆä¾‹å­ï¼Œå±•ç¤ºå¦‚ä½•è®“å¤š task åœ¨é™åˆ¶ä½µç™¼ä¸‹ç­‰å¾…äº‹ä»¶ã€å»£æ’­é—œé–‰ã€ä¸¦è¨ˆæ™‚ã€‚
