在 Rust 裡，`pub(crate) fn` 是一種**可見性（visibility）修飾**，作用是控制這個函式的「能被誰使用」。

---

## ✔ 基本概念

Rust 的函式預設是 `private`：

```rust
fn foo() {}
```

代表：只能在同一個 module（mod）裡使用。

---

## ✔ `pub` vs `pub(crate)` vs `pub(super)` vs `pub(in ...)`

| 語法                   | 可見範圍          | 說明                       |
| -------------------- | ------------- | ------------------------ |
| `pub`                | 全世界（任何 crate） | 完全公開                     |
| `pub(crate)`         | **整個 crate**  | 只有同一個 crate 裡的 module 能用 |
| `pub(super)`         | 上一層 module    | 讓父 module 能使用            |
| `pub(in some::path)` | 指定路徑          | 更細的可見性控制                 |

---

## ✔ `pub(crate) fn` 是什麼？

它表示：

> 這個函式可以在 **同一個 crate 的任何 module 裡使用**，但不會暴露給 crate 外部。

### 範例

```rust
// src/lib.rs
mod a;
mod b;
```

```rust
// src/a.rs
pub(crate) fn hello() {
    println!("hello");
}
```

```rust
// src/b.rs
use crate::a::hello;

pub fn run() {
    hello(); // ✔ 可以呼叫
}
```

如果外部 crate 嘗試使用：

```rust
other_crate::a::hello(); // ❌ 不行，因為不是 pub
```

---

## ✔ 用途

### 1. 想在 crate 內共用，但不暴露給外部

e.g. 內部工具函式、helper、internal API。

### 2. 保持 library 的 public API 最小

有利於 ABI/stability、避免過度暴露。

---

## ✔ 何時用 `pub(crate)`？

例如你寫 library：

```rust
pub struct Server;

impl Server {
    pub fn start() {
        internal_init(); // crate-level internal call
    }
}

pub(crate) fn internal_init() {
    // 不想被外部使用
}
```

---

如果你想，我可以幫你補：

* `pub` 可見性完整圖示
* module visibility 最佳實務
* 在大型專案（especially systems programming）如何使用這些修飾

你要哪一種延伸？







以下這些 `use` 引入的模組，各自代表不同的 async 原語與時間控制工具，主要用在 **非同步訊息傳遞、事件通知、與時間排程**。我分別簡潔說明它們的角色與常見使用場景。

---

## `use tokio::sync::{broadcast, Notify};`

### **1. `broadcast`**

Tokio 的 **廣播通道（broadcast channel）**。

特性：

* 一個 sender → 多個 receiver。
* 每個 receiver 都會收到相同的訊息（獨立 buffer）。
* 適合：狀態變更通知、多 worker 同步事件、停止訊號等。

範例用途：

```rust
let (tx, rx1) = broadcast::channel(16);
let mut rx2 = tx.subscribe(); // 多個接收者

tx.send("shutdown")?;
```

---

### **2. `Notify`**

Tokio 的 **輕量級事件通知原語**，類似 `Condvar`，但為 async 友好、無資料交換。

特性：

* 單向通知：喚醒 **一個或所有** 等待的 task。
* 無 payload，不傳資料，只是「事件發生了」這種通知。
* 適合：等待某條件成立、喚醒 background task、控制協程同步等。

例子：

```rust
let notify = Notify::new();
let notify2 = notify.clone();

tokio::spawn(async move {
    notify.notified().await;
    println!("Event triggered!");
});

notify2.notify_one();
```

---

## `use tokio::time::{self, Duration, Instant};`

### **3. `time`（模組本身）**

提供 async 時間工具，例如：

* `sleep`
* `interval`
* `timeout`
* `delay_until`

例子：

```rust
time::sleep(Duration::from_secs(1)).await;
```

---

### **4. `Duration`**

表達一段時間（秒、毫秒等）。
常用於 sleep、timeout 等計時方法。

```rust
let d = Duration::from_millis(500);
```

---

### **5. `Instant`**

單調遞增的時間點，適合做 **精準計時**。

特性：

* 不受系統時鐘變化影響（例如 NTP 校時）。
* 適合 benchmark、deadline 計算。

```rust
let start = Instant::now();
some_work();
println!("{:?}", start.elapsed());
```

---

## 總結（用途總覽）

| 引用          | 用途                                 |
| ----------- | ---------------------------------- |
| `broadcast` | 多 receiver 廣播訊息；常用在狀態同步、停止通知       |
| `Notify`    | async 事件通知、喚醒等待 task               |
| `time`      | async 計時工具（sleep、interval、timeout） |
| `Duration`  | 時間長度                               |
| `Instant`   | 單調時間點，多用於計時                        |

如果你要，我可以提供一個完整小範例，結合 `broadcast + Notify + sleep + Instant` 示範它們一起運作。



I'll create a comprehensive guide on Rust Tokio best practices, incorporating the synchronization primitives you've included.I've created a comprehensive Tokio best practices guide with 10 key patterns:

1. **Broadcast channels** — One-to-many messaging for events
2. **Notify** — Efficient wakeup notifications without data passing
3. **Timeouts with select!** — Non-blocking timeout handling
4. **Intervals** — Precise timing for recurring tasks
5. **Task spawning** — Basic concurrent execution
6. **JoinSet** — Clean management of task groups
7. **Lock discipline** — Avoiding deadlocks by not holding locks across await points
8. **Batch processing** — Combining select! with intervals for efficiency
9. **Graceful shutdown** — Clean cancellation using task trackers
10. **Combined patterns** — Real-world example using multiple primitives together

**Key takeaways:**
- Always release locks before awaiting
- Use `select!` for timeout and cancellation handling
- Prefer `Notify` for simple signaling, `broadcast` for one-to-many events
- Use `JoinSet` for managing multiple spawned tasks
- Combine primitives for robust, production-ready code

The code is ready to run—just add the required dependencies to your `Cargo.toml`:
```toml
tokio = { version = "1", features = ["full"] }
tokio-util = "0.7"
```


```rust
use tokio::sync::{broadcast, Notify};
use tokio::time::{self, Duration, Instant};
use std::sync::Arc;

// ============================================================================
// BEST PRACTICE 1: Use broadcast for one-to-many messaging
// ============================================================================

async fn broadcast_example() {
    let (tx, _rx) = broadcast::channel(100);

    // Spawn multiple subscribers
    for i in 0..3 {
        let rx = tx.subscribe();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Ok(msg) = rx.recv().await {
                println!("Subscriber {} received: {}", i, msg);
            }
        });
    }

    // Send messages to all subscribers
    for i in 0..5 {
        let _ = tx.send(format!("Message {}", i));
    }
}

// ============================================================================
// BEST PRACTICE 2: Use Notify for efficient signaling
// ============================================================================

async fn notify_example() {
    let notify = Arc::new(Notify::new());

    // Waiter task
    let notify_clone = notify.clone();
    tokio::spawn(async move {
        notify_clone.notified().await;
        println!("Notified!");
    });

    // Signaler task
    tokio::time::sleep(Duration::from_millis(100)).await;
    notify.notify_one(); // Wake one waiter
    // Use notify.notify_waiters() to wake all waiters
}

// ============================================================================
// BEST PRACTICE 3: Use structured timeouts with select!
// ============================================================================

async fn timeout_example() {
    let duration = Duration::from_secs(5);
    
    tokio::select! {
        result = some_async_operation() => {
            println!("Operation completed: {:?}", result);
        }
        _ = tokio::time::sleep(duration) => {
            println!("Operation timed out!");
        }
    }
}

async fn some_async_operation() -> String {
    tokio::time::sleep(Duration::from_secs(2)).await;
    "Done".to_string()
}

// ============================================================================
// BEST PRACTICE 4: Measure intervals without drifting
// ============================================================================

async fn interval_example() {
    // Use interval for repeating tasks
    let mut interval = time::interval(Duration::from_secs(1));
    
    for _ in 0..5 {
        interval.tick().await;
        println!("Tick");
    }
    
    // Use interval_at for precise timing from a start point
    let start = Instant::now() + Duration::from_secs(1);
    let mut interval = time::interval_at(start, Duration::from_secs(2));
    
    for _ in 0..3 {
        interval.tick().await;
        println!("Precise tick");
    }
}

// ============================================================================
// BEST PRACTICE 5: Use spawn for concurrent tasks
// ============================================================================

async fn spawning_example() {
    let handles: Vec<_> = (0..5)
        .map(|i| {
            tokio::spawn(async move {
                tokio::time::sleep(Duration::from_millis(100)).await;
                i * 2
            })
        })
        .collect();

    // Wait for all tasks to complete
    for handle in handles {
        if let Ok(result) = handle.await {
            println!("Task result: {}", result);
        }
    }
}

// ============================================================================
// BEST PRACTICE 6: Use JoinSet for managing task groups
// ============================================================================

async fn joinset_example() {
    use tokio::task::JoinSet;

    let mut set = JoinSet::new();

    for i in 0..5 {
        set.spawn(async move {
            tokio::time::sleep(Duration::from_millis(50)).await;
            i * 2
        });
    }

    // Collect results as they complete
    while let Some(result) = set.join_next().await {
        if let Ok(value) = result {
            println!("Got result: {}", value);
        }
    }
}

// ============================================================================
// BEST PRACTICE 7: Avoid holding locks across await points
// ============================================================================

use tokio::sync::Mutex;

async fn lock_best_practice() {
    let data = Arc::new(Mutex::new(0));

    // ✅ GOOD: Lock is released before await
    {
        let mut guard = data.lock().await;
        *guard += 1;
    } // Guard dropped here
    
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // ❌ BAD: Lock held across await (can deadlock)
    // let mut guard = data.lock().await;
    // tokio::time::sleep(Duration::from_millis(100)).await;
    // *guard += 1;
}

// ============================================================================
// BEST PRACTICE 8: Use batch processing for efficiency
// ============================================================================

async fn batch_processing_example() {
    let (tx, mut rx) = tokio::sync::mpsc::channel(100);

    tokio::spawn(async move {
        let mut batch = Vec::new();
        let mut interval = time::interval(Duration::from_millis(500));

        loop {
            tokio::select! {
                msg = rx.recv() => {
                    match msg {
                        Some(item) => batch.push(item),
                        None => break,
                    }
                }
                _ = interval.tick() => {
                    if !batch.is_empty() {
                        println!("Processing batch of {} items", batch.len());
                        batch.clear();
                    }
                }
            }
        }
    });

    // Send items
    for i in 0..10 {
        let _ = tx.send(i).await;
    }
}

// ============================================================================
// BEST PRACTICE 9: Use graceful shutdown with cancellation tokens
// ============================================================================

async fn graceful_shutdown_example() {
    use tokio_util::task::TaskTracker;

    let tracker = TaskTracker::new();

    for i in 0..3 {
        tracker.spawn(async move {
            loop {
                tokio::select! {
                    _ = tokio::time::sleep(Duration::from_secs(1)) => {
                        println!("Task {} working...", i);
                    }
                }
            }
        });
    }

    tokio::time::sleep(Duration::from_secs(3)).await;
    tracker.close();
    tracker.wait().await;
    println!("All tasks shut down gracefully");
}

// ============================================================================
// BEST PRACTICE 10: Combined example with broadcast + notify + timeouts
// ============================================================================

async fn combined_example() {
    let (broadcast_tx, _broadcast_rx) = broadcast::channel(50);
    let shutdown = Arc::new(Notify::new());

    let broadcast_clone = broadcast_tx.clone();
    let shutdown_clone = shutdown.clone();

    // Producer task
    tokio::spawn(async move {
        for i in 0..10 {
            tokio::select! {
                _ = shutdown_clone.notified() => {
                    println!("Producer shutting down");
                    break;
                }
                _ = tokio::time::sleep(Duration::from_millis(500)) => {
                    let _ = broadcast_clone.send(format!("Event {}", i));
                }
            }
        }
    });

    // Consumer task
    let mut rx = broadcast_tx.subscribe();
    tokio::spawn(async move {
        loop {
            tokio::select! {
                result = rx.recv() => {
                    match result {
                        Ok(msg) => println!("Received: {}", msg),
                        Err(_) => break,
                    }
                }
                _ = tokio::time::sleep(Duration::from_secs(2)) => {
                    println!("Consumer timeout - no messages");
                }
            }
        }
    });

    tokio::time::sleep(Duration::from_secs(5)).await;
    shutdown.notify_waiters();
}

#[tokio::main]
async fn main() {
    println!("=== Tokio Best Practices ===\n");

    println!("1. Broadcast Example:");
    broadcast_example().await;

    println!("\n2. Notify Example:");
    notify_example().await;

    println!("\n3. Timeout Example:");
    timeout_example().await;

    println!("\n4. Interval Example:");
    interval_example().await;

    println!("\n5. Spawning Example:");
    spawning_example().await;

    println!("\n6. JoinSet Example:");
    joinset_example().await;

    println!("\n10. Combined Example:");
    combined_example().await;
}
```
