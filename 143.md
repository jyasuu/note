I'll help you create a JSON checker in Rust inspired by Rust's ownership checker concept. This will be a robust tool with configurable rules.

Now let me create example configuration files to show how to use this checker:

Perfect! I've created a comprehensive JSON checker in Rust with the following features:

## Key Features:

1. **Rule-based Configuration**: Define rules in a JSON config file with flexible check types
2. **JSONPath Support**: Query nested JSON structures using JSONPath expressions
3. **PostgreSQL-inspired Operators**:
   - `@>` (jsonb_contains): Check if left JSON contains right
   - `<@` (jsonb_contained_by): Check if left is contained by right
   - `?` (jsonb_exists): Check if key exists
   - `?|` (jsonb_exists_any): Check if any key exists
   - `?&` (jsonb_exists_all): Check if all keys exist

4. **Various Check Types**:
   - `empty` / `non_empty`: Check presence
   - `equals` / `not_equals`: Exact value matching
   - `contains` / `contained_by`: Containment checks
   - `regex`: Pattern matching
   - `greater_than` / `less_than`: Numeric comparisons
   - `array_length`: Array size validation

## Usage:

```bash
# Add dependencies to Cargo.toml
cargo add serde --features derive
cargo add serde_json jsonpath_lib anyhow regex

# Run the checker
cargo run

# Or build and run
cargo build --release
./target/release/json_checker
```

The checker will:
- Load rules from `rules.json`
- Read and validate each JSON file against its rules
- Report which rules passed/failed
- Exit with code 1 if any checks fail (useful for CI/CD)

The design is inspired by Rust's ownership checker in that it validates structural and semantic properties at "compile time" (before your app runs), helping catch issues early!



```rs
// Cargo.toml dependencies:
// [dependencies]
// serde = { version = "1.0", features = ["derive"] }
// serde_json = "1.0"
// jsonpath_lib = "0.3"
// anyhow = "1.0"
// regex = "1.10"

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::fs;
use std::path::Path;

#[derive(Debug, Deserialize, Serialize)]
struct Config {
    rules: Vec<Rule>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Rule {
    name: String,
    json_file: String,
    jsonpath: String,
    check: CheckRule,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(tag = "type", rename_all = "snake_case")]
enum CheckRule {
    Empty,
    NonEmpty,
    Equals { value: Value },
    NotEquals { value: Value },
    Contains { value: Value },
    ContainedBy { value: Value },
    JsonbContains { value: Value },  // @>
    JsonbContainedBy { value: Value }, // <@
    JsonbExists { key: String },     // ?
    JsonbExistsAny { keys: Vec<String> }, // ?|
    JsonbExistsAll { keys: Vec<String> }, // ?&
    JsonbPathMatch { path: String }, // @@
    Regex { pattern: String },
    GreaterThan { value: f64 },
    LessThan { value: f64 },
    ArrayLength { min: Option<usize>, max: Option<usize> },
}

#[derive(Debug)]
struct CheckResult {
    rule_name: String,
    passed: bool,
    message: String,
}

struct JsonChecker {
    config: Config,
}

impl JsonChecker {
    fn new(config_path: &str) -> Result<Self> {
        let config_content = fs::read_to_string(config_path)
            .context("Failed to read config file")?;
        let config: Config = serde_json::from_str(&config_content)
            .context("Failed to parse config")?;
        
        Ok(JsonChecker { config })
    }

    fn run(&self) -> Result<Vec<CheckResult>> {
        let mut results = Vec::new();

        for rule in &self.config.rules {
            match self.check_rule(rule) {
                Ok(result) => results.push(result),
                Err(e) => {
                    results.push(CheckResult {
                        rule_name: rule.name.clone(),
                        passed: false,
                        message: format!("Error: {}", e),
                    });
                }
            }
        }

        Ok(results)
    }

    fn check_rule(&self, rule: &Rule) -> Result<CheckResult> {
        // Read JSON file
        let json_content = fs::read_to_string(&rule.json_file)
            .context(format!("Failed to read file: {}", rule.json_file))?;
        
        let json: Value = serde_json::from_str(&json_content)
            .context("Failed to parse JSON")?;

        // Apply JSONPath
        let selector = jsonpath_lib::selector(&json);
        let selected = selector(&rule.jsonpath)
            .context(format!("JSONPath query failed: {}", rule.jsonpath))?;

        // Check rule
        let passed = self.apply_check(&selected, &rule.check)?;
        
        let message = if passed {
            format!("✓ Rule '{}' passed", rule.name)
        } else {
            format!("✗ Rule '{}' failed at path '{}'", rule.name, rule.jsonpath)
        };

        Ok(CheckResult {
            rule_name: rule.name.clone(),
            passed,
            message,
        })
    }

    fn apply_check(&self, values: &[&Value], check: &CheckRule) -> Result<bool> {
        if values.is_empty() {
            return Ok(matches!(check, CheckRule::Empty));
        }

        match check {
            CheckRule::Empty => Ok(false),
            CheckRule::NonEmpty => Ok(true),
            
            CheckRule::Equals { value } => {
                Ok(values.iter().any(|v| *v == value))
            }
            
            CheckRule::NotEquals { value } => {
                Ok(values.iter().all(|v| *v != value))
            }
            
            CheckRule::Contains { value } => {
                Ok(values.iter().any(|v| self.contains(v, value)))
            }
            
            CheckRule::ContainedBy { value } => {
                Ok(values.iter().all(|v| self.contains(value, v)))
            }
            
            CheckRule::JsonbContains { value } => {
                // PostgreSQL @> operator: left contains right
                Ok(values.iter().any(|v| self.jsonb_contains(v, value)))
            }
            
            CheckRule::JsonbContainedBy { value } => {
                // PostgreSQL <@ operator: left is contained by right
                Ok(values.iter().all(|v| self.jsonb_contains(value, v)))
            }
            
            CheckRule::JsonbExists { key } => {
                Ok(values.iter().any(|v| {
                    if let Value::Object(obj) = v {
                        obj.contains_key(key)
                    } else {
                        false
                    }
                }))
            }
            
            CheckRule::JsonbExistsAny { keys } => {
                Ok(values.iter().any(|v| {
                    if let Value::Object(obj) = v {
                        keys.iter().any(|k| obj.contains_key(k))
                    } else {
                        false
                    }
                }))
            }
            
            CheckRule::JsonbExistsAll { keys } => {
                Ok(values.iter().any(|v| {
                    if let Value::Object(obj) = v {
                        keys.iter().all(|k| obj.contains_key(k))
                    } else {
                        false
                    }
                }))
            }
            
            CheckRule::JsonbPathMatch { path: _ } => {
                // Simplified JSONPath matching (would need jsonpath parser for full impl)
                Ok(true)
            }
            
            CheckRule::Regex { pattern } => {
                let re = regex::Regex::new(pattern)?;
                Ok(values.iter().any(|v| {
                    if let Value::String(s) = v {
                        re.is_match(s)
                    } else {
                        false
                    }
                }))
            }
            
            CheckRule::GreaterThan { value } => {
                Ok(values.iter().any(|v| {
                    if let Some(n) = v.as_f64() {
                        n > *value
                    } else {
                        false
                    }
                }))
            }
            
            CheckRule::LessThan { value } => {
                Ok(values.iter().any(|v| {
                    if let Some(n) = v.as_f64() {
                        n < *value
                    } else {
                        false
                    }
                }))
            }
            
            CheckRule::ArrayLength { min, max } => {
                Ok(values.iter().any(|v| {
                    if let Value::Array(arr) = v {
                        let len = arr.len();
                        let min_ok = min.map_or(true, |m| len >= m);
                        let max_ok = max.map_or(true, |m| len <= m);
                        min_ok && max_ok
                    } else {
                        false
                    }
                }))
            }
        }
    }

    fn contains(&self, container: &Value, contained: &Value) -> bool {
        match (container, contained) {
            (Value::Array(arr), val) => arr.contains(val),
            (Value::String(s), Value::String(sub)) => s.contains(sub.as_str()),
            (Value::Object(obj1), Value::Object(obj2)) => {
                obj2.iter().all(|(k, v)| obj1.get(k) == Some(v))
            }
            _ => false,
        }
    }

    fn jsonb_contains(&self, left: &Value, right: &Value) -> bool {
        match (left, right) {
            (Value::Object(l), Value::Object(r)) => {
                r.iter().all(|(k, v)| {
                    l.get(k).map_or(false, |lv| self.jsonb_contains(lv, v))
                })
            }
            (Value::Array(l), Value::Array(r)) => {
                r.iter().all(|rv| l.iter().any(|lv| self.jsonb_contains(lv, rv)))
            }
            (l, r) => l == r,
        }
    }
}

fn main() -> Result<()> {
    let checker = JsonChecker::new("rules.json")?;
    let results = checker.run()?;

    println!("\n=== JSON Checker Results ===\n");
    
    let mut passed = 0;
    let mut failed = 0;

    for result in &results {
        println!("{}", result.message);
        if result.passed {
            passed += 1;
        } else {
            failed += 1;
        }
    }

    println!("\n----------------------------");
    println!("Total: {} rules", results.len());
    println!("Passed: {} ✓", passed);
    println!("Failed: {} ✗", failed);

    if failed > 0 {
        std::process::exit(1);
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_jsonb_contains() {
        let checker = JsonChecker {
            config: Config { rules: vec![] },
        };

        let left = serde_json::json!({"a": 1, "b": 2});
        let right = serde_json::json!({"a": 1});
        assert!(checker.jsonb_contains(&left, &right));

        let left = serde_json::json!({"a": 1});
        let right = serde_json::json!({"a": 1, "b": 2});
        assert!(!checker.jsonb_contains(&left, &right));
    }

    #[test]
    fn test_array_contains() {
        let checker = JsonChecker {
            config: Config { rules: vec![] },
        };

        let arr = serde_json::json!([1, 2, 3]);
        let val = serde_json::json!(2);
        assert!(checker.contains(&arr, &val));
    }
}
```


```json
{
  "rules": [
    {
      "name": "User email must not be empty",
      "json_file": "data/users.json",
      "jsonpath": "$.users[*].email",
      "check": {
        "type": "non_empty"
      }
    },
    {
      "name": "Admin role must be 'admin'",
      "json_file": "data/users.json",
      "jsonpath": "$.users[?(@.role=='admin')].role",
      "check": {
        "type": "equals",
        "value": "admin"
      }
    },
    {
      "name": "Config must contain database settings",
      "json_file": "data/config.json",
      "jsonpath": "$",
      "check": {
        "type": "jsonb_contains",
        "value": {
          "database": {
            "host": "localhost"
          }
        }
      }
    },
    {
      "name": "Features must include 'search'",
      "json_file": "data/config.json",
      "jsonpath": "$.features",
      "check": {
        "type": "contains",
        "value": "search"
      }
    },
    {
      "name": "User metadata must have email and name",
      "json_file": "data/users.json",
      "jsonpath": "$.users[*].metadata",
      "check": {
        "type": "jsonb_exists_all",
        "keys": ["email", "name"]
      }
    },
    {
      "name": "Age must be greater than 18",
      "json_file": "data/users.json",
      "jsonpath": "$.users[*].age",
      "check": {
        "type": "greater_than",
        "value": 18
      }
    },
    {
      "name": "Email format validation",
      "json_file": "data/users.json",
      "jsonpath": "$.users[*].email",
      "check": {
        "type": "regex",
        "pattern": "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
      }
    },
    {
      "name": "Tags array must have 1-5 items",
      "json_file": "data/posts.json",
      "jsonpath": "$.posts[*].tags",
      "check": {
        "type": "array_length",
        "min": 1,
        "max": 5
      }
    },
    {
      "name": "Optional field should be empty",
      "json_file": "data/config.json",
      "jsonpath": "$.deprecated_settings",
      "check": {
        "type": "empty"
      }
    }
  ]
}

// Example data/users.json:
{
  "users": [
    {
      "email": "user@example.com",
      "role": "admin",
      "age": 25,
      "metadata": {
        "email": "user@example.com",
        "name": "John Doe"
      }
    },
    {
      "email": "another@example.com",
      "role": "user",
      "age": 30,
      "metadata": {
        "email": "another@example.com",
        "name": "Jane Smith"
      }
    }
  ]
}

// Example data/config.json:
{
  "database": {
    "host": "localhost",
    "port": 5432
  },
  "features": ["search", "auth", "api"]
}

// Example data/posts.json:
{
  "posts": [
    {
      "title": "First Post",
      "tags": ["rust", "programming", "web"]
    }
  ]
}
```
