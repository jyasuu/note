
https://www.youtube.com/watch?list=TLGGZTVMIcnli6QyMTEwMjAyNQ&v=Z68PotL_O98

這段文字是 YouTube 頻道「s09g」上傳的影片「System Design - CICD / Github Action」的腳本節錄，內容**全面性地闡述了持續整合與持續部署（CI/CD）系統的設計考量**。講者首先定義了**功能性需求和非功能性需求**，例如系統必須具備**可擴展性、低延遲**和接近即時的狀態更新。接著，討論了如何透過**控制平面（Control Plane）和資料平面（Data Plane）**的乾淨分離來構建系統架構，並深入探討了**任務接收、排程和分配的機制**。文中也對**資料儲存（例如分片的關聯式資料庫、NoSQL 或 NewSQL）**進行了比較，並討論了**Runner 閘道和訊息佇列（Event Bus）**在任務分發中的應用，最後探討了**Runner（執行器）的選擇**（如虛擬機或容器）以及**執行結果與日誌的回傳**方法。


本影片的技術評估是圍繞建立一個類似 GitHub Actions 的系統展開的，主要將系統劃分為**控制平面 (Control Plane)** 和 **數據平面 (Data Plane)**，並依序對各個組成部分進行了技術方案的選擇和評估。

以下依照影片播放順序說明技術評估：

### 1. 系統要求與架構原則

影片首先確立了系統的非功能需求 (Non-functional requirements) 和基礎架構原則：

*   **非功能需求：** 系統必須滿足**可擴展性 (Scalability)**、**低延遲 (Low Latency)**，且最好能夠接近**實時 (Real-time)** 狀態，以便用戶知道任務執行的實時狀態。
*   **架構分離：** 系統應採用 Control Plane 和 Data Plane 的乾淨分離。
    *   **控制平面職責：** 接收任務、處理或編排任務，然後將任務分配下去。
    *   **數據平面職責：** 獲取上游過來的任務、執行任務，如果需要的話，將結果回報上去。

### 2. 接收任務與事件處理 (控制平面)

在控制平面接收任務階段，主要評估了數據匯流排的選擇：

*   **任務接收方式：** 可以使用事件監聽器 (event listener) 或 WebHook。
*   **數據持久化/傳遞方案評估：**
    *   **NoSQL + Change Feed/Streaming：** 如果不希望引入額外的組件，可以考慮在 NoSQL 數據庫上做 Change Feed 或 Streaming (例如 DynamoDB 支持 Streaming)。
        *   **優點：** 簡化系統複雜度、延遲較低、運維成本較低。
    *   **Event Bus (如 Kafka)：** 使用消息隊列 (event bus)。
        *   **優點：** 支持更複雜的路由和分歧，方便進行審計、重訪和路由。
        *   **選擇傾向：** 由於系統要求支持**多租戶 (machine tenants)**，需要為不同類型的客戶分配不同的優先級和額度，因此較傾向於使用 **Event Bus** 方案，為系統留下更多的擴展空間。

### 3. 任務編排與持久化

任務編排涉及到有向無環圖 (DAG) 的處理與持久化。

*   **數據結構評估：** 為了處理任務依賴 (dependency)，需要持續更新狀態。
    *   **放棄方案：** 直接儲存一份完整的 workflow 文件會使複雜的依賴處理變得困難。
    *   **採用方案：** 使用結構化的三張表進行持久化：
        1.  `workflow run` (記錄執行 ID, 租戶 ID, repo/commit sha, 狀態, 時間戳等)。
        2.  `job` (記錄任務 ID, 所屬 workflow run id, Runner ID, 狀態, 前置任務 Dependency 等)。
        3.  `Dependency` (記錄邊的數據，包含 `from` 和 `to`，表示任務之間的依賴關係)。

*   **數據存儲 (數據庫) 評估：** 由於 job 和 workflow 之間有關聯，且依賴關係要求數據一致性。
    *   **方案一：分片關係型數據庫 (Sharding Relational Database)：** 例如 PostgreSQL 或 MySQL。
        *   **分片鍵 (Sharding Key) 評估：**
            *   按 `workflow id` 分片：可以在 workflow 內部達到強一致性，但用戶查詢自己所有的 workflow 時會導致跨分片查詢。
            *   按 `tenant id` 分片：解決了用戶查詢問題，但仍需面對 Hash 帶來的弊端。
        *   **結論：** 考慮到目前的數據量，分片的關係型數據庫應已足夠。
    *   **方案二：NewSQL (如 Spanner)：**
        *   **優點：** 支持分佈式事務和彈性擴展，沒有跨分片事務的問題。
        *   **缺點：** 部署和運營複雜度高，需要專業團隊進行調優，且成本更高。被認為有點 overkill。

### 4. 任務分發與 Runner Gateway

控制層需要將任務分發下去，通過一個 **Runner Gateway** 作為對外暴露的端點。

*   **Runner Gateway 實現評估：**
    *   **CDC (Change Data Capture) 模式：** 在同一個事務內，將數據變化同時寫入 `job table` 和 `output table`，然後使用投遞器將 `output table` 的消息異步投遞到消息隊列中。
        *   **優點：** 結構性強、支持多用戶和多平台的扇出 (Fan-out)，容易做重放和可觀察性。
        *   **缺點：** 引入新的消息系統，增加了系統複雜度和運維成本。
    *   **Database Queue：** 如果場景規模不大，可以簡單地使用數據庫隊列 (如一張 `ready` 表)。
        *   **缺點：** QPS 高時，數據庫可能成為瓶頸。
    *   **NewSQL (Change Stream as Q)：** 如果使用 NewSQL (如 Spanner)，它的 Change Stream 可以作為隊列。
        *   **優點：** 不需要額外的消息隊列組件，能承擔很高的 QPS，延遲低。
        *   **缺點：** 成本更高。

### 5. 控制層與執行層的通信

這是將 Job 從控制平面分發到數據平面 (Runner) 的問題。

*   **通信模式評估 (Push vs. Pull)：** 指導思想是將控制平面和數據平面盡可能**解耦**。
    *   **Push 模式：** 控制平面主動將 Job 推送到下游 Runner。
        *   **缺點：** 用戶可能使用自託管平台 (Self-hosted platform)，受限於 NAT 和防火牆，控制平面難以穿透進去，需要增加延遲。
    *   **Pull 模式 (Runner 拉取)：** 下游 Runner 主動從上游拉取 Job。
        *   **優點：** 比較簡單，Runner 只需出站訪問控制平面，在配置上更安全。
        *   **採用方案：** 採用 Runner **拉取**模式。
*   **拉取機制：**
    *   **Long-Polling：** Runner 最好使用 **Long-polling** 方式發起請求。如果在 60 秒內未收到任務分配，則重置連接。
    *   **緩解熱點：** 為避免 Runner Gateway 壓力過大產生熱點，可以在上游添加指數回退 (exponential backoff) 來延長等待間隔。
    *   **租約管理 (Lease)：** Runner 和 Gateway 之間應維護一個租約 (timestamp)，代表 Runner 可以在一段時間內 (例如 60 秒) 執行該 Job。Runner 必須在到期前更新 Lease。
*   **優化方案：**
    *   **Pull + Notify：** Runner 通過 Push 模式建立連接，升級為 WebSocket。控制平面可以用 Notify 方式喚醒空閒 Runner，延遲更低。
        *   **缺點：** 產生額外的 Web 依賴，且由於 Runner 資源是跑在外部平台，不如直接回收空閒 Runner。

### 6. Runner 執行環境評估

如果用戶選擇自託管平台 (self host)，執行環境設計選項有限。

*   **執行單元評估：** 主要有兩種方案：虛擬機 (VM) 或 容器 (Container)。
    *   **容器 (如 Kubernetes)：** 大部分自託管用戶的選擇。
        *   **優點：** 啟動快、延遲低、消耗小。
        *   **缺點：** 安全性較低 (儘管用戶可能有自己的安全方案，如增加一層隔離)。
    *   **虛擬機 (VM)：** 雲廠商基本上會選擇 VM。
        *   **優點：** 提供更好的隔離性和安全性 (這對於 build 和執行用戶未知的代碼非常重要)。
        *   **缺點：** 啟動較慢。
*   **啟動優化：**
    *   **Mini-VM/Nano-VM (如 Firecracker)：** 使用裁剪的虛擬機，移除無用的功能以減少 VM 體積。例如 AWS Lambda 使用的 Firecracker，內存佔用僅 5 兆，啟動延遲約 125 毫秒。

### 7. 日誌與結果回傳

如何將任務執行情況和日誌回傳到控制平面，存在兩條不同的通道：

*   **通道一 (輕量、實時性高)：狀態事件與有限日誌切片**
    *   用途：上報小的消息、狀態事件和有限的日誌切片。
    *   方式：通過 Gateway 連接，以串流 (stream) 方式傳輸到控制平面。
    *   後續處理：狀態變更先落盤到 Datasource，然後通過 Inventory Pass 廣播出去。可以添加 Push Service (使用 WebSocket 或 Source Event) 推送到 UI，連接輕量且實時性高。
*   **通道二 (大文件)：完整的日誌與執行產物**
    *   用途：回傳完整的執行日誌，以及執行產物 (例如 Docker Image)。這些文件通常比較大。
    *   方式：在分發任務時，直接配置一個 **Presigned URL**。Runner 將完整的日誌和執行產物直接存儲到 **Object Storage** 中。
    *   **共享存儲優勢：** 這種共享存儲可以在 Job 之間傳遞，前一個 Job build 出來的 Image 可以在後續 Job 中使用，開銷較低，且便於水平擴展。
