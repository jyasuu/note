https://vicxu.medium.com/%E7%99%BE%E8%90%AC%E7%B4%9A%E5%90%9E%E5%90%90%E9%87%8F%E7%9A%84%E4%BA%A4%E6%98%93%E6%89%80%E9%A4%98%E9%A1%8D%E7%B3%BB%E7%B5%B1-%E7%B3%BB%E7%B5%B1%E5%AF%A6%E4%BD%9C-68203fe708a5
https://vicxu.medium.com/%E7%99%BE%E8%90%AC%E7%B4%9A-tps-%E7%9A%84%E4%BA%A4%E6%98%93%E6%89%80%E9%A4%98%E9%A1%8D%E7%B3%BB%E7%B5%B1-3297140272b2

這句話描述的是在分散式系統（Distributed Systems）中，解決 **「資料一致性」** 與 **「重複請求（Retry）」** 問題的一種經典組合技。

簡單來說，這句話的目標是：**「確保一個操作（如：付款、下訂單）在系統因為網路不穩而重試時，只會被執行一次，且相關的事件通知（如：寄 Email、通知下游服務）絕對不會遺失。」**

我們拆解成兩個核心部分，並用 Rust 程式碼來演示。

-----

### 核心概念拆解

1.  **DB Unique Index (資料庫唯一索引) -\> 實現冪等性 (Idempotency)**

      * **目的：** 防止同一個請求被處理兩次。
      * **做法：** 每個請求（Request）都必須帶有一個 `request_id`（通常是 UUID）。我們在資料庫建一張表，把這個 ID 設為 `UNIQUE`。
      * **效果：** 當重複的請求進來時，資料庫會報錯（Unique Constraint Violation），程式捕捉到這個錯誤就知道：「啊！這個之前處理過了」，直接回傳之前的結果即可。

2.  **Outbox Pattern (Outbox 模式) -\> 實現可靠性 (Reliability)**

      * **目的：** 確保「業務資料寫入」與「發送事件通知」這兩件事是**原子性 (Atomic)** 的（要嘛都成功，要嘛都失敗）。
      * **做法：** 不要直接在程式碼裡發送 HTTP 請求或寫入 Kafka/RabbitMQ（因為如果發送成功但資料庫寫入失敗，就會資料不一致）。而是把「要發送的訊息」寫入到同一個資料庫的 `outbox` 表格中。
      * **效果：** 因為業務資料和 Outbox 訊息是在**同一個資料庫 Transaction** 內提交的，所以保證了資料的一致性。

-----

### Rust 程式碼實作範例

我們假設一個場景：**使用者下訂單 (Create Order)**。
我們使用 `sqlx` (Rust 常用的異步資料庫庫) 來模擬這個過程。

#### 1\. 資料庫結構 (SQL 示意)

```sql
-- 業務表
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    amount DECIMAL,
    status TEXT
);

-- 冪等性檢查表 (關鍵：request_id 是 UNIQUE)
CREATE TABLE idempotency (
    user_id UUID,
    request_id UUID,
    created_at TIMESTAMP,
    PRIMARY KEY (user_id, request_id) -- 這裡就是 Unique Index
);

-- Outbox 表 (存放待發送的事件)
CREATE TABLE outbox (
    id UUID PRIMARY KEY,
    event_type TEXT,
    payload JSONB,
    created_at TIMESTAMP
);
```

#### 2\. Rust 實作邏輯

```rust
use sqlx::{PgPool, Postgres, Transaction};
use uuid::Uuid;
use serde_json::json;

// 模擬請求結構
struct CreateOrderRequest {
    request_id: Uuid, // 這是冪等性的關鍵 Key (Idempotency Key)
    user_id: Uuid,
    amount: f64,
}

// 處理下訂單的函數
async fn handle_create_order(
    pool: &PgPool,
    req: CreateOrderRequest,
) -> Result<String, String> {
    
    // 1. 開啟一個資料庫 Transaction (交易)
    // 這是 Outbox Pattern 的基礎，確保所有寫入是原子性的
    let mut tx = pool.begin().await.map_err(|e| e.to_string())?;

    // =========================================================
    // 第一步：利用 DB Unique Index 實現冪等性防護
    // =========================================================
    
    // 嘗試將 request_id 寫入冪等表
    let insert_idempotency = sqlx::query!(
        r#"
        INSERT INTO idempotency (user_id, request_id, created_at)
        VALUES ($1, $2, NOW())
        "#,
        req.user_id,
        req.request_id
    )
    .execute(&mut *tx)
    .await;

    match insert_idempotency {
        Ok(_) => {
            // 插入成功，代表這是第一次處理這個請求，繼續往下執行
        }
        Err(sqlx::Error::Database(db_err)) => {
            // 檢查是否違反 Unique Constraint (唯一性約束)
            if db_err.constraint() == Some("idempotency_pkey") {
                // 如果是 Unique Violation，代表這個 request_id 已經處理過了！
                // 這裡可以直接回傳「成功」，或者回傳之前處理的結果
                return Ok("Order already processed (Idempotent success)".to_string());
            } else {
                return Err(db_err.to_string());
            }
        }
        Err(e) => return Err(e.to_string()),
    }

    // =========================================================
    // 第二步：執行真正的業務邏輯
    // =========================================================
    
    let order_id = Uuid::new_v4();
    sqlx::query!(
        r#"
        INSERT INTO orders (id, amount, status)
        VALUES ($1, $2, 'CREATED')
        "#,
        order_id,
        req.amount
    )
    .execute(&mut *tx)
    .await
    .map_err(|e| e.to_string())?;

    // =========================================================
    // 第三步：Outbox Pattern 寫入事件
    // =========================================================
    
    // 我們不直接發送 HTTP 或 Kafka 訊息，而是寫入 Outbox 表
    // 因為這是在同一個 tx (Transaction) 內，如果上面的 INSERT order 失敗，
    // 這個 Outbox 也不會被寫入。
    let event_payload = json!({
        "order_id": order_id,
        "user_id": req.user_id,
        "amount": req.amount
    });

    sqlx::query!(
        r#"
        INSERT INTO outbox (id, event_type, payload, created_at)
        VALUES ($1, 'OrderCreated', $2, NOW())
        "#,
        Uuid::new_v4(),
        event_payload
    )
    .execute(&mut *tx)
    .await
    .map_err(|e| e.to_string())?;

    // =========================================================
    // 第四步：提交 Transaction
    // =========================================================
    
    // 只有到這一刻，冪等紀錄、訂單資料、Outbox 事件才會同時生效
    tx.commit().await.map_err(|e| e.to_string())?;

    Ok(format!("Order created successfully with ID: {}", order_id))
}
```

-----

### 總結圖解

這個模式解決了什麼問題？

1.  **如果沒有 Unique Index (冪等鍵)：**

      * 使用者點了兩次「付款」，你的系統可能會扣兩次錢。
      * **解決方案：** 程式碼中的 `INSERT INTO idempotency`，如果 DB 報錯重複，我們就擋下來。

2.  **如果沒有 Outbox (直接 Call 外部服務)：**

      * 你把訂單存進 DB 了，然後準備發送「訂單成立」事件給物流系統。
      * 這時候**程式崩潰**或**網路斷線**。
      * 結果：**訂單成立了，但物流系統永遠不知道**（資料不一致）。
      * **解決方案：** 程式碼中將 `Event` 存入 `outbox` 表。因為它和 `orders` 表在同一個 Transaction，保證「訂單有，事件就有」。

### 後續步驟 (The "Relay")

你可能會問：「那存在 `outbox` 表裡的資料誰來發送？」

這通常需要另一個背景程式（Background Worker），它會：

1.  不斷讀取 `outbox` 表。
2.  把訊息發送到 Message Broker (如 Kafka)。
3.  發送成功後，刪除 `outbox` 裡的該筆資料（或標記為已發送）。

這種架構雖然寫起來稍微麻煩一點，但在要求**高可靠性**的金融或電商系統中是非常標準的作法。

需要我為你解釋 **「如何實作那個讀取 Outbox 的背景程式 (Relay Worker)」** 嗎？
