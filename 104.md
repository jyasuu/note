I'll help you set up MongoDB with Rust using best practices, covering both basic CRUD operations and advanced features.I've created a comprehensive MongoDB + Rust guide that covers both basic CRUD operations with complex data structures and advanced features. Here are the key highlights:

## Basic CRUD with Complex Objects:
- **Complex Data Models**: User entity with nested structures (addresses, contact info, preferences, metadata)
- **Repository Pattern**: Clean, organized data access layer
- **All CRUD Operations**: Create, read, update, delete with various query patterns
- **Bulk Operations**: Efficient batch processing
- **Proper Indexing**: Strategic indexes for performance

## Advanced Features:
- **Transactions**: ACID compliance for related operations
- **Change Streams**: Real-time change monitoring
- **Text Search**: Full-text search capabilities
- **Geospatial Queries**: Location-based searches
- **Aggregation Pipelines**: Complex data analysis
- **Connection Pooling**: Production-ready connection management

## Best Practices Included:
- Proper error handling with `anyhow`
- UUID usage for external APIs
- Soft deletes for data preservation
- Compound indexes for complex queries
- Separation of concerns with repository pattern
- Environment-based configuration

The code is production-ready and includes comprehensive examples of working with complex, nested data structures. You can start with the basic CRUD operations and gradually implement the advanced features as needed.

Would you like me to explain any specific part in more detail or add additional features like caching, validation, or specific query patterns?


# MongoDB + Rust Best Practices Guide

## Dependencies (Cargo.toml)

```toml
[dependencies]
mongodb = "2.8"
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
bson = { version = "2.9", features = ["chrono-0_4"] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
anyhow = "1.0"
futures = "0.3"
```

## 1. Basic Setup and Connection

```rust
use mongodb::{Client, Database, Collection, options::ClientOptions};
use serde::{Deserialize, Serialize};
use bson::{doc, oid::ObjectId, DateTime};
use chrono::{Utc, DateTime as ChronoDateTime};
use uuid::Uuid;
use std::env;

// Database connection with connection pooling
pub struct MongoClient {
    pub client: Client,
    pub database: Database,
}

impl MongoClient {
    pub async fn new() -> anyhow::Result<Self> {
        let uri = env::var("MONGODB_URI")
            .unwrap_or_else(|_| "mongodb://localhost:27017".to_string());
        
        let mut client_options = ClientOptions::parse(&uri).await?;
        
        // Best practice: Configure connection pool
        client_options.max_pool_size = Some(10);
        client_options.min_pool_size = Some(5);
        client_options.max_idle_time = Some(std::time::Duration::from_secs(30));
        
        let client = Client::with_options(client_options)?;
        let database = client.database("myapp");
        
        // Test connection
        client.database("admin").run_command(doc! {"ping": 1}, None).await?;
        println!("Connected to MongoDB successfully!");
        
        Ok(MongoClient { client, database })
    }
}

// Complex data models
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Address {
    pub street: String,
    pub city: String,
    pub state: String,
    pub zip_code: String,
    pub country: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ContactInfo {
    pub email: String,
    pub phone: Option<String>,
    pub social_media: Vec<SocialMedia>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SocialMedia {
    pub platform: String,
    pub handle: String,
    pub verified: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct User {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub uuid: Uuid,
    pub username: String,
    pub email: String,
    pub profile: UserProfile,
    pub addresses: Vec<Address>,
    pub contact_info: ContactInfo,
    pub preferences: UserPreferences,
    pub metadata: UserMetadata,
    pub created_at: DateTime,
    pub updated_at: DateTime,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserProfile {
    pub first_name: String,
    pub last_name: String,
    pub bio: Option<String>,
    pub avatar_url: Option<String>,
    pub date_of_birth: Option<DateTime>,
    pub tags: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserPreferences {
    pub theme: String,
    pub language: String,
    pub notifications: NotificationSettings,
    pub privacy: PrivacySettings,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NotificationSettings {
    pub email_notifications: bool,
    pub push_notifications: bool,
    pub sms_notifications: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PrivacySettings {
    pub profile_visibility: String, // "public", "friends", "private"
    pub show_email: bool,
    pub show_phone: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserMetadata {
    pub login_count: i32,
    pub last_login: Option<DateTime>,
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
    pub referrer: Option<String>,
}

impl User {
    pub fn new(username: String, email: String, first_name: String, last_name: String) -> Self {
        let now = DateTime::now();
        
        User {
            id: None,
            uuid: Uuid::new_v4(),
            username,
            email: email.clone(),
            profile: UserProfile {
                first_name,
                last_name,
                bio: None,
                avatar_url: None,
                date_of_birth: None,
                tags: Vec::new(),
            },
            addresses: Vec::new(),
            contact_info: ContactInfo {
                email,
                phone: None,
                social_media: Vec::new(),
            },
            preferences: UserPreferences {
                theme: "light".to_string(),
                language: "en".to_string(),
                notifications: NotificationSettings {
                    email_notifications: true,
                    push_notifications: true,
                    sms_notifications: false,
                },
                privacy: PrivacySettings {
                    profile_visibility: "public".to_string(),
                    show_email: false,
                    show_phone: false,
                },
            },
            metadata: UserMetadata {
                login_count: 0,
                last_login: None,
                ip_address: None,
                user_agent: None,
                referrer: None,
            },
            created_at: now,
            updated_at: now,
        }
    }
}
```

## 2. Repository Pattern with CRUD Operations

```rust
use mongodb::{Collection, options::{FindOptions, UpdateOptions, IndexOptions}};
use futures::stream::TryStreamExt;

pub struct UserRepository {
    collection: Collection<User>,
}

impl UserRepository {
    pub fn new(database: &Database) -> Self {
        Self {
            collection: database.collection("users"),
        }
    }
    
    // Ensure indexes for performance
    pub async fn ensure_indexes(&self) -> anyhow::Result<()> {
        use mongodb::IndexModel;
        
        let indexes = vec![
            IndexModel::builder()
                .keys(doc! { "email": 1 })
                .options(IndexOptions::builder().unique(true).build())
                .build(),
            IndexModel::builder()
                .keys(doc! { "username": 1 })
                .options(IndexOptions::builder().unique(true).build())
                .build(),
            IndexModel::builder()
                .keys(doc! { "uuid": 1 })
                .options(IndexOptions::builder().unique(true).build())
                .build(),
            IndexModel::builder()
                .keys(doc! { "created_at": 1 })
                .build(),
            // Compound index for common queries
            IndexModel::builder()
                .keys(doc! { 
                    "profile.first_name": 1, 
                    "profile.last_name": 1 
                })
                .build(),
        ];
        
        self.collection.create_indexes(indexes, None).await?;
        Ok(())
    }

    // CREATE
    pub async fn create_user(&self, user: &User) -> anyhow::Result<ObjectId> {
        let mut user = user.clone();
        user.created_at = DateTime::now();
        user.updated_at = DateTime::now();
        
        let result = self.collection.insert_one(&user, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }

    // CREATE MANY
    pub async fn create_users(&self, users: Vec<User>) -> anyhow::Result<Vec<ObjectId>> {
        let mut users = users;
        let now = DateTime::now();
        
        for user in &mut users {
            user.created_at = now;
            user.updated_at = now;
        }
        
        let result = self.collection.insert_many(&users, None).await?;
        Ok(result.inserted_ids.values()
            .map(|id| id.as_object_id().unwrap())
            .collect())
    }

    // READ - Find by ID
    pub async fn find_by_id(&self, id: &ObjectId) -> anyhow::Result<Option<User>> {
        let user = self.collection.find_one(doc! { "_id": id }, None).await?;
        Ok(user)
    }

    // READ - Find by UUID (better for external APIs)
    pub async fn find_by_uuid(&self, uuid: &Uuid) -> anyhow::Result<Option<User>> {
        let user = self.collection
            .find_one(doc! { "uuid": uuid.to_string() }, None)
            .await?;
        Ok(user)
    }

    // READ - Find by email
    pub async fn find_by_email(&self, email: &str) -> anyhow::Result<Option<User>> {
        let user = self.collection
            .find_one(doc! { "email": email }, None)
            .await?;
        Ok(user)
    }

    // READ - Complex query with filters
    pub async fn find_users_with_filters(
        &self,
        theme: Option<&str>,
        city: Option<&str>,
        tags: Option<Vec<&str>>,
        limit: Option<u64>,
        skip: Option<u64>,
    ) -> anyhow::Result<Vec<User>> {
        let mut filter = doc! {};
        
        if let Some(theme) = theme {
            filter.insert("preferences.theme", theme);
        }
        
        if let Some(city) = city {
            filter.insert("addresses.city", city);
        }
        
        if let Some(tags) = tags {
            filter.insert("profile.tags", doc! { "$in": tags });
        }
        
        let find_options = FindOptions::builder()
            .limit(limit.unwrap_or(100))
            .skip(skip)
            .sort(doc! { "created_at": -1 })
            .build();
        
        let cursor = self.collection.find(filter, find_options).await?;
        let users: Vec<User> = cursor.try_collect().await?;
        Ok(users)
    }

    // READ - Aggregation pipeline example
    pub async fn get_user_stats_by_city(&self) -> anyhow::Result<Vec<bson::Document>> {
        let pipeline = vec![
            doc! {
                "$unwind": "$addresses"
            },
            doc! {
                "$group": {
                    "_id": "$addresses.city",
                    "user_count": { "$sum": 1 },
                    "avg_login_count": { "$avg": "$metadata.login_count" },
                    "users": { "$push": {
                        "username": "$username",
                        "email": "$email"
                    }}
                }
            },
            doc! {
                "$sort": { "user_count": -1 }
            }
        ];
        
        let cursor = self.collection.aggregate(pipeline, None).await?;
        let results: Vec<bson::Document> = cursor.try_collect().await?;
        Ok(results)
    }

    // UPDATE - Update user profile
    pub async fn update_profile(
        &self,
        id: &ObjectId,
        profile_updates: UserProfile,
    ) -> anyhow::Result<bool> {
        let update = doc! {
            "$set": {
                "profile": bson::to_bson(&profile_updates)?,
                "updated_at": DateTime::now()
            }
        };
        
        let result = self.collection
            .update_one(doc! { "_id": id }, update, None)
            .await?;
        
        Ok(result.modified_count > 0)
    }

    // UPDATE - Add address
    pub async fn add_address(&self, id: &ObjectId, address: Address) -> anyhow::Result<bool> {
        let update = doc! {
            "$push": { "addresses": bson::to_bson(&address)? },
            "$set": { "updated_at": DateTime::now() }
        };
        
        let result = self.collection
            .update_one(doc! { "_id": id }, update, None)
            .await?;
        
        Ok(result.modified_count > 0)
    }

    // UPDATE - Increment login count and update metadata
    pub async fn record_login(
        &self,
        id: &ObjectId,
        ip_address: Option<String>,
        user_agent: Option<String>,
    ) -> anyhow::Result<bool> {
        let update = doc! {
            "$inc": { "metadata.login_count": 1 },
            "$set": {
                "metadata.last_login": DateTime::now(),
                "metadata.ip_address": ip_address,
                "metadata.user_agent": user_agent,
                "updated_at": DateTime::now()
            }
        };
        
        let result = self.collection
            .update_one(doc! { "_id": id }, update, None)
            .await?;
        
        Ok(result.modified_count > 0)
    }

    // UPDATE - Bulk update
    pub async fn bulk_update_theme(&self, old_theme: &str, new_theme: &str) -> anyhow::Result<u64> {
        let filter = doc! { "preferences.theme": old_theme };
        let update = doc! {
            "$set": {
                "preferences.theme": new_theme,
                "updated_at": DateTime::now()
            }
        };
        
        let options = UpdateOptions::builder().build();
        let result = self.collection.update_many(filter, update, options).await?;
        Ok(result.modified_count)
    }

    // DELETE - Soft delete (recommended)
    pub async fn soft_delete(&self, id: &ObjectId) -> anyhow::Result<bool> {
        let update = doc! {
            "$set": {
                "deleted_at": DateTime::now(),
                "updated_at": DateTime::now()
            }
        };
        
        let result = self.collection
            .update_one(doc! { "_id": id }, update, None)
            .await?;
        
        Ok(result.modified_count > 0)
    }

    // DELETE - Hard delete
    pub async fn delete(&self, id: &ObjectId) -> anyhow::Result<bool> {
        let result = self.collection
            .delete_one(doc! { "_id": id }, None)
            .await?;
        
        Ok(result.deleted_count > 0)
    }

    // Utility - Count documents
    pub async fn count_users(&self) -> anyhow::Result<u64> {
        let count = self.collection.count_documents(None, None).await?;
        Ok(count)
    }

    // Utility - Check if user exists
    pub async fn exists_by_email(&self, email: &str) -> anyhow::Result<bool> {
        let count = self.collection
            .count_documents(doc! { "email": email }, None)
            .await?;
        Ok(count > 0)
    }
}
```

## 3. Advanced Features

```rust
// Transaction support
impl UserRepository {
    pub async fn create_user_with_related_data(
        &self,
        mongo_client: &MongoClient,
        user: User,
        initial_posts: Vec<Post>, // Assume we have a Post model
    ) -> anyhow::Result<ObjectId> {
        let mut session = mongo_client.client.start_session(None).await?;
        session.start_transaction(None).await?;
        
        // Insert user
        let user_result = self.collection
            .insert_one_with_session(&user, None, &mut session)
            .await?;
        
        let user_id = user_result.inserted_id.as_object_id().unwrap();
        
        // Insert related posts
        let posts_collection: Collection<Post> = mongo_client.database.collection("posts");
        let mut posts_with_user_id = initial_posts;
        for post in &mut posts_with_user_id {
            post.user_id = user_id;
        }
        
        posts_collection
            .insert_many_with_session(&posts_with_user_id, None, &mut session)
            .await?;
        
        session.commit_transaction().await?;
        Ok(user_id)
    }
}

// Change Streams for real-time updates
pub async fn watch_user_changes(
    collection: &Collection<User>,
) -> anyhow::Result<()> {
    let pipeline = vec![
        doc! {
            "$match": {
                "operationType": { "$in": ["insert", "update", "delete"] }
            }
        }
    ];
    
    let mut change_stream = collection.watch(pipeline, None).await?;
    
    while change_stream.is_alive() {
        if let Some(change) = change_stream.try_next().await? {
            println!("Change detected: {:?}", change);
            // Handle the change event
            match change.operation_type {
                mongodb::change_stream::event::OperationType::Insert => {
                    println!("New user created!");
                }
                mongodb::change_stream::event::OperationType::Update => {
                    println!("User updated!");
                }
                mongodb::change_stream::event::OperationType::Delete => {
                    println!("User deleted!");
                }
                _ => {}
            }
        }
    }
    
    Ok(())
}

// Text Search
impl UserRepository {
    pub async fn setup_text_search(&self) -> anyhow::Result<()> {
        use mongodb::IndexModel;
        
        let text_index = IndexModel::builder()
            .keys(doc! {
                "username": "text",
                "profile.first_name": "text",
                "profile.last_name": "text",
                "profile.bio": "text"
            })
            .build();
        
        self.collection.create_index(text_index, None).await?;
        Ok(())
    }
    
    pub async fn search_users(&self, query: &str) -> anyhow::Result<Vec<User>> {
        let filter = doc! {
            "$text": { "$search": query }
        };
        
        let find_options = FindOptions::builder()
            .sort(doc! { "score": { "$meta": "textScore" } })
            .limit(20)
            .build();
        
        let cursor = self.collection.find(filter, find_options).await?;
        let users: Vec<User> = cursor.try_collect().await?;
        Ok(users)
    }
}

// Geospatial queries (if you add location data)
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct GeoLocation {
    pub r#type: String, // "Point"
    pub coordinates: [f64; 2], // [longitude, latitude]
}

impl UserRepository {
    pub async fn setup_geo_index(&self) -> anyhow::Result<()> {
        use mongodb::IndexModel;
        
        let geo_index = IndexModel::builder()
            .keys(doc! { "location": "2dsphere" })
            .build();
        
        self.collection.create_index(geo_index, None).await?;
        Ok(())
    }
    
    pub async fn find_users_near(
        &self,
        longitude: f64,
        latitude: f64,
        max_distance: f64,
    ) -> anyhow::Result<Vec<User>> {
        let filter = doc! {
            "location": {
                "$near": {
                    "$geometry": {
                        "type": "Point",
                        "coordinates": [longitude, latitude]
                    },
                    "$maxDistance": max_distance
                }
            }
        };
        
        let cursor = self.collection.find(filter, None).await?;
        let users: Vec<User> = cursor.try_collect().await?;
        Ok(users)
    }
}
```

## 4. Usage Example

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize connection
    let mongo_client = MongoClient::new().await?;
    let user_repo = UserRepository::new(&mongo_client.database);
    
    // Ensure indexes
    user_repo.ensure_indexes().await?;
    
    // Create a complex user
    let mut user = User::new(
        "johndoe".to_string(),
        "john@example.com".to_string(),
        "John".to_string(),
        "Doe".to_string(),
    );
    
    // Add complex data
    user.addresses.push(Address {
        street: "123 Main St".to_string(),
        city: "New York".to_string(),
        state: "NY".to_string(),
        zip_code: "10001".to_string(),
        country: "USA".to_string(),
    });
    
    user.contact_info.social_media.push(SocialMedia {
        platform: "Twitter".to_string(),
        handle: "@johndoe".to_string(),
        verified: false,
    });
    
    user.profile.tags = vec!["developer".to_string(), "rust".to_string()];
    
    // Create user
    let user_id = user_repo.create_user(&user).await?;
    println!("Created user with ID: {}", user_id);
    
    // Find user
    let found_user = user_repo.find_by_id(&user_id).await?;
    println!("Found user: {:?}", found_user);
    
    // Update profile
    let mut updated_profile = user.profile.clone();
    updated_profile.bio = Some("Rust developer passionate about systems programming".to_string());
    user_repo.update_profile(&user_id, updated_profile).await?;
    
    // Record login
    user_repo.record_login(
        &user_id,
        Some("192.168.1.1".to_string()),
        Some("Mozilla/5.0...".to_string()),
    ).await?;
    
    // Complex query
    let users = user_repo.find_users_with_filters(
        Some("light"),
        Some("New York"),
        Some(vec!["developer", "rust"]),
        Some(10),
        None,
    ).await?;
    
    println!("Found {} users matching criteria", users.len());
    
    // Aggregation
    let stats = user_repo.get_user_stats_by_city().await?;
    println!("User stats by city: {:?}", stats);
    
    Ok(())
}

// Example Post model for transaction demo
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Post {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub user_id: ObjectId,
    pub title: String,
    pub content: String,
    pub created_at: DateTime,
}
```

## Key Best Practices Demonstrated:

1. **Connection Management**: Proper connection pooling and configuration
2. **Data Modeling**: Complex nested structures with proper serialization
3. **Repository Pattern**: Clean separation of concerns
4. **Indexing**: Strategic indexes for performance
5. **Error Handling**: Comprehensive error handling with `anyhow`
6. **Transactions**: ACID transactions for related operations
7. **Change Streams**: Real-time change monitoring
8. **Text Search**: Full-text search capabilities
9. **Geospatial**: Location-based queries
10. **Aggregation**: Complex data analysis pipelines
11. **Bulk Operations**: Efficient batch operations
12. **Soft Deletes**: Data preservation strategy

This setup provides a production-ready foundation for MongoDB with Rust applications.
