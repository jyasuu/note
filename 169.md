可以！下面給你一個 **純 Rust** 的 trigram（含一般 n-gram 擴充）實作，支援：

*   字元模式（整段文字滑動）與 **詞模式**（每個詞加邊界 padding，貼近 `pg_trgm` 行為）
*   選項：大小寫規範、壓縮空白、是否做詞邊界 padding、n 的可調整（預設 3）
*   **Jaccard 相似度**（`pg_trgm` 的 `similarity()` 等價指標）
*   簡易 **倒排索引**（posting lists）與 `LIKE '%pattern%'` 的近似加速流程（候選→精確驗證）

> 說明：`pg_trgm` 的三元組建立規則為先規整空白、加邊界空白以保留詞首/詞尾，再做連續三字元切片；它的相似度採集合交並比（Jaccard）。以下的詞模式與相似度定義與官方概念一致；細節如「字元分類、語系、排序規則」在 PostgreSQL 內有更多考量，但此純 Rust 實作可作為通用近似與教學用途。

***

## Rust 實作：`trigram.rs`

```rust
use std::collections::{HashMap, HashSet};

/// n-gram 模式
#[derive(Clone, Copy, Debug)]
pub enum GramMode {
    /// 字元模式：對整段文字（含可選的整段 padding）做滑窗
    Char,
    /// 詞模式：以 is_alphanumeric() 作為詞界定，對每個詞做邊界 padding 後再切 n-gram
    Word,
}

/// Trigram / n-gram 的選項
#[derive(Clone, Debug)]
pub struct TrigramOptions {
    /// n 的大小（trigram = 3）
    pub n: usize,
    /// 是否轉為小寫（粗略大小寫無關；受語系影響）
    pub to_lowercase: bool,
    /// 壓縮空白（連續空白壓成一個空白）
    pub compress_whitespace: bool,
    /// 是否在字串或詞的兩端加入兩個空白作為邊界（模擬 pg_trgm 的邊界行為）
    pub pad_boundaries: bool,
    /// 模式：字元或詞
    pub mode: GramMode,
}

impl Default for TrigramOptions {
    fn default() -> Self {
        Self {
            n: 3,
            to_lowercase: true,
            compress_whitespace: true,
            pad_boundaries: true,
            mode: GramMode::Word, // 預設用詞模式，較貼近 pg_trgm
        }
    }
}

/// 將文字依選項預處理（大小寫、壓縮空白）
fn preprocess(text: &str, to_lowercase: bool, compress_ws: bool) -> String {
    let mut s = if to_lowercase {
        text.to_lowercase()
    } else {
        text.to_string()
    };

    if compress_ws {
        let mut out = String::with_capacity(s.len());
        let mut prev_ws = false;
        for ch in s.chars() {
            if ch.is_whitespace() {
                if !prev_ws {
                    out.push(' ');
                    prev_ws = true;
                }
            } else {
                out.push(ch);
                prev_ws = false;
            }
        }
        s = out;
    }

    s
}

/// 以字元（整段）建立 n-gram
fn ngrams_by_char(s: &str, n: usize, pad_boundaries: bool) -> HashSet<String> {
    let mut base = if pad_boundaries {
        // 兩端各加兩個空白，模擬 pg_trgm 的字首/字尾保留
        format!("  {}  ", s)
    } else {
        s.to_string()
    };

    // 若長度比 n 小，仍給 padding 後的 n-gram（與 pg_trgm 行為相近）
    let chars: Vec<char> = base.chars().collect();
    let mut grams = HashSet::new();

    if chars.len() < n {
        // 無法切足 n 長度：直接返回空集合或（可選）返回整段
        // 這裡選擇空集合，避免非預期的短片段。
        return grams;
    }

    for i in 0..=chars.len() - n {
        let slice: String = chars[i..i + n].iter().collect();
        grams.insert(slice);
    }
    grams
}

/// 以詞建立 n-gram（每個詞加邊界 padding）
fn ngrams_by_word(s: &str, n: usize, pad_boundaries: bool) -> HashSet<String> {
    let mut grams = HashSet::new();

    let mut i = 0;
    let chars: Vec<char> = s.chars().collect();
    let len = chars.len();

    while i < len {
        // 跳過非詞元（非 is_alphanumeric）
        while i < len && !chars[i].is_alphanumeric() {
            i += 1;
        }
        if i >= len {
            break;
        }

        // 收集一個詞
        let start = i;
        while i < len && chars[i].is_alphanumeric() {
            i += 1;
        }
        let word: String = chars[start..i].iter().collect();

        // 對詞加邊界 padding
        let padded = if pad_boundaries {
            format!("  {}  ", word)
        } else {
            word
        };

        let wchars: Vec<char> = padded.chars().collect();
        if wchars.len() < n {
            continue;
        }

        for j in 0..=wchars.len() - n {
            let tri: String = wchars[j..j + n].iter().collect();
            grams.insert(tri);
        }
    }

    grams
}

/// 產生 n-gram（預設 trigram）
pub fn generate_ngrams(text: &str, opts: &TrigramOptions) -> Vec<String> {
    let pre = preprocess(text, opts.to_lowercase, opts.compress_whitespace);

    let set = match opts.mode {
        GramMode::Char => ngrams_by_char(&pre, opts.n, opts.pad_boundaries),
        GramMode::Word => ngrams_by_word(&pre, opts.n, opts.pad_boundaries),
    };

    let mut vec: Vec<String> = set.into_iter().collect();
    vec.sort();
    vec
}

/// Jaccard 相似度：|A ∩ B| / |A ∪ B|
pub fn jaccard_similarity(a: &[String], b: &[String]) -> f32 {
    let sa: HashSet<&String> = a.iter().collect();
    let sb: HashSet<&String> = b.iter().collect();

    let (small, large) = if sa.len() <= sb.len() { (sa, sb) } else { (sb, sa) };

    let mut inter = 0usize;
    for x in &small {
        if large.contains(x) {
            inter += 1;
        }
    }
    let union = small.len() + large.len() - inter;
    if union == 0 { 0.0 } else { inter as f32 / union as f32 }
}

/// 一個簡易的 trigram 倒排索引，近似支援 LIKE '%pattern%'
pub type DocId = usize;

pub struct TrigramIndex {
    pub opts: TrigramOptions,
    postings: HashMap<String, Vec<DocId>>,
}

impl TrigramIndex {
    pub fn new(opts: TrigramOptions) -> Self {
        Self {
            opts,
            postings: HashMap::new(),
        }
    }

    /// 將文件加入索引（每個 doc 對同一 trigram 只記一次）
    pub fn index_document(&mut self, doc_id: DocId, text: &str) {
        let grams = generate_ngrams(text, &self.opts);
        for g in grams {
            let entry = self.postings.entry(g).or_default();
            // 避免同 doc 重覆出現在 posting list
            if entry.last().copied() != Some(doc_id) {
                // 注意：這是假設一次 index 不會多次插入同 doc；若會，改用去重邏輯
                entry.push(doc_id);
            }
        }
    }

    /// 以 pattern 的 n-gram 取 posting lists 的聯集，回傳候選（依命中數排序）
    pub fn query_candidates(&self, pattern: &str) -> Vec<(DocId, usize)> {
        let grams = generate_ngrams(pattern, &self.opts);
        let mut counter: HashMap<DocId, usize> = HashMap::new();

        for g in grams {
            if let Some(list) = self.postings.get(&g) {
                for &doc in list {
                    *counter.entry(doc).or_insert(0) += 1;
                }
            }
        }

        let mut items: Vec<(DocId, usize)> = counter.into_iter().collect();
        items.sort_by(|a, b| b.1.cmp(&a.1).then_with(|| a.0.cmp(&b.0)));
        items
    }

    /// 近似 LIKE '%pattern%'：先用候選縮小，再做精確 contains 驗證
    pub fn query_like_contains(
        &self,
        pattern: &str,
        corpus: &HashMap<DocId, String>,
    ) -> Vec<DocId> {
        let candidates = self.query_candidates(pattern);
        let p = if self.opts.to_lowercase {
            pattern.to_lowercase()
        } else {
            pattern.to_string()
        };

        let mut result = Vec::new();
        for (doc_id, _hit) in candidates {
            if let Some(text) = corpus.get(&doc_id) {
                let t = if self.opts.to_lowercase {
                    text.to_lowercase()
                } else {
                    text.clone()
                };
                if t.contains(&p) {
                    result.push(doc_id);
                }
            }
        }
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trigram_word_mode() {
        let opts = TrigramOptions::default();
        let grams = generate_ngrams("PostgreSQL trigram!", &opts);
        assert!(grams.contains(&"  po".to_string()) || grams.contains(&"  po".to_string()));
        assert!(grams.iter().all(|g| g.chars().count() == 3));
    }

    #[test]
    fn test_trigram_char_mode() {
        let mut opts = TrigramOptions::default();
        opts.mode = GramMode::Char;
        let grams = generate_ngrams("foo bar", &opts);
        assert!(grams.iter().all(|g| g.chars().count() == 3));
    }

    #[test]
    fn test_jaccard() {
        let opts = TrigramOptions::default();
        let a = generate_ngrams("abcdef", &opts);
        let b = generate_ngrams("abcxyz", &opts);
        let s = jaccard_similarity(&a, &b);
        assert!(s >= 0.0 && s <= 1.0);
    }

    #[test]
    fn test_index_and_query() {
        let mut idx = TrigramIndex::new(TrigramOptions::default());
        let mut corpus: HashMap<DocId, String> = HashMap::new();

        corpus.insert(1, "PostgreSQL supports trigram indexing.".to_string());
        corpus.insert(2, "Rust implementation of trigrams for substring search.".to_string());
        corpus.insert(3, "Completely unrelated text.".to_string());

        for (id, text) in &corpus {
            idx.index_document(*id, text);
        }

        let hits = idx.query_like_contains("gram", &corpus);
        assert!(hits.contains(&1) || hits.contains(&2));
        assert!(!hits.contains(&3));
    }
}

fn main() {
    // 範例使用
    let mut opts = TrigramOptions::default();
    opts.mode = GramMode::Word; // 或 GramMode::Char

    let s = "PostgreSQL trigram index";
    let grams = generate_ngrams(s, &opts);
    println!("Trigrams of '{s}': {:?}", grams);

    // 建索引與查詢
    let mut idx = TrigramIndex::new(opts.clone());
    let mut corpus: HashMap<DocId, String> = HashMap::new();
    corpus.insert(1, "PostgreSQL supports trigram indexing.".to_string());
    corpus.insert(2, "Rust implementation of trigrams for substring search.".to_string());
    corpus.insert(3, "GIN index accelerates LIKE '%pattern%' queries.".to_string());

    for (id, text) in &corpus {
        idx.index_document(*id, text);
    }

    let candidates = idx.query_candidates("trigram");
    println!("Candidates (doc_id, hits): {:?}", candidates);

    let exact = idx.query_like_contains("pattern", &corpus);
    println!("Exact LIKE '%pattern%' matches: {:?}", exact);
}
```

***

## 說明與設計取捨

*   **模式選擇**
    *   `Word` 模式：以 `is_alphanumeric()` 判詞，對每個詞加「兩端空白」後做 n-gram，保留詞首/尾的訊息（近似 `pg_trgm`）。
    *   `Char` 模式：對整段字串（可選整段 padding）滑動，對跨詞邊界的特徵也會產生 n-gram。

*   **空白壓縮與大小寫**
    *   壓縮空白（多空白 → 單空白）與小寫化是常見、貼近 `pg_trgm` 的規整步驟；實務中 PostgreSQL 會受 **collation**（語系排序）、字元分類與 ICU 行為影響，純 Rust 版用 `char::is_alphanumeric()` 做簡化。

*   **相似度**
    *   `jaccard_similarity()` 以集合交並比，等價於 `pg_trgm` 的 `similarity()` 定義（集合層面）。
    *   若要模擬 `strict_word_similarity()`，可改以詞為單位（非字元）再計算 Jaccard。

*   **倒排索引**
    *   `TrigramIndex` 用 `HashMap<trigram, Vec<DocId>>` 做 posting lists，查詢時合併多個 trigram 的 posting lists 以產生候選，再做 **精確 `contains` 驗證**，即是 `LIKE '%pattern%'` 的典型兩階段流程（索引過濾 → 精確比對）。

*   **複雜度**
    *   建索引：每文件生成 n-gram 的成本約 **O(L)**（L 為文件長度），加入 posting lists；總體與資料量線性。
    *   查詢：`O(T · log M)`（取 posting lists；`T` 為 pattern n-gram 數、`M` 為索引大小）＋**候選驗證** `O(k · L)`（k ≪ N）。這與你前面問題中的分析一致。

***

## 與 `pg_trgm` 完全一致的注意點

若你需要 **和 PostgreSQL `pg_trgm` 完全一致**：

1.  **字元分類與分詞**：`pg_trgm` 對「詞元」與「分隔符」的判定會依據語系、字元類別與 ICU；上面的實作用 `is_alphanumeric()` 做了簡化。
2.  **邊界與空白處理**：官方做法是壓縮空白、加入邊界空白，確保詞首/尾的 trigram 能被建立。
3.  **相似度閾值**：Postgres 有 `pg_trgm.similarity_threshold`；你可以在查詢階段以 Jaccard 值過濾候選。
4.  **多語系與大小寫**：大小寫化在某些語系（例如土耳其語）有特殊規則。

需要的話，我可以把以上程式碼再 **調整為更貼近 `pg_trgm` 的字元分類與詞邊界策略**，或提供一個 **基準測試（benchmark）** 來比較無索引 vs trigram 索引下的效能。你偏好 **字元模式** 還是 **詞模式**？以及是否需要完全同步 PostgreSQL 的行為？
