å¾ˆå¥½ â€” æˆ‘æœƒç›´æ¥çµ¦ä½ ä¸€å¥—å¯å¯¦ä½œã€å¯ç·¨è­¯çš„å…¥é–€ç¯„ä¾‹èˆ‡å¯¦ä½œèªªæ˜ï¼Œç¤ºç¯„å¦‚ä½•ç”¨ **Pingora (Cloudflare é–‹æºçš„ Rust æ¡†æ¶)** å¯¦ä½œ **HTTP åå‘ proxy / gateway / load-balancer**ï¼ˆå«å¥åº·æª¢æŸ¥ã€ç°¡å–®é¸æ“‡å™¨èˆ‡ TLS/è§€æ¸¬æç¤ºï¼‰ã€‚æˆ‘æœƒç”¨ä¸­æ–‡èªªæ˜ä¸¦é™„ä¸Šæœ€å°å¯è·‘çš„ç¨‹å¼éª¨æ¶ã€`Cargo.toml`ã€åŸ·è¡ŒæŒ‡ä»¤ã€ä»¥åŠéƒ¨ç½²/æ¸¬è©¦èˆ‡é€²éšå»ºè­°ã€‚é—œéµæ¦‚å¿µèˆ‡ API ä¾æ“šå®˜æ–¹ repo èˆ‡æ–‡ä»¶ï¼æ•™å­¸ç¯„ä¾‹ã€‚([GitHub][1])

---

# è¦é»æ‘˜è¦ï¼ˆå¿«é€Ÿçœ‹ï¼‰

* ä½¿ç”¨å¥—ä»¶ï¼š`pingora` / `pingora-proxy` / `pingora-load-balancing`ï¼ˆå®˜æ–¹æä¾› proxy èˆ‡ lb ç¯„ä¾‹ï¼‰ã€‚([docs.rs][2])
* åŸºæœ¬æ€è·¯ï¼šå¯¦ä½œä¸€å€‹ `ProxyHttp`ï¼ˆæˆ–ç¹¼æ‰¿ Pingora æä¾›çš„ http proxy serviceï¼‰ï¼Œåœ¨ `upstream_peer()` ä¸­ä½¿ç”¨ `LoadBalancer` é¸æ“‡å¾Œç«¯ peerã€‚å®˜æ–¹æœ‰ `examples/load_balancer.rs` å¯åƒè€ƒã€‚([docs.rs][3])
* å¯æ“´å±•ï¼šå¥åº·æª¢æŸ¥ã€æ•…éšœé‡è©¦ã€è¼ªè©¢/ä¸€è‡´æ€§å“ˆå¸Œ/æ¬Šé‡ã€TLSï¼ˆOpenSSL/BoringSSL/rustlsï¼‰ã€è§€æ¸¬ï¼ˆmetrics/logï¼‰ã€‚([GitHub][1])

---

# æœ€å°å¯è·‘ç¯„ä¾‹ï¼ˆload-balancer / reverse proxyï¼‰

ä»¥ä¸‹ç‚º **æœ€å°åŒ–**ã€èƒ½å•Ÿå‹•ä¸¦æŠŠè«‹æ±‚åœ¨å…©å€‹ upstreamï¼ˆç¤ºä¾‹ IPï¼‰é–“ round-robin çš„ç¯„ä¾‹ã€‚

### 1) å»ºå°ˆæ¡ˆ

```bash
cargo new pingora_lb
cd pingora_lb
```

### 2) `Cargo.toml`

```toml
[package]
name = "pingora_lb"
version = "0.1.0"
edition = "2021"

[dependencies]
async-trait = "0.1"
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }

# pingora å®¶æ—å¥—ä»¶ (è¦–ç‰ˆæœ¬æ›´æ–°æ›æˆæœ€æ–°ç©©å®šç‰ˆæœ¬)
pingora = { version = "0.6", features = ["lb"] }
pingora-proxy = "0.6"
pingora-load-balancing = "0.6"
```

> ï¼ˆè‹¥ä½ åœ¨ cargo ä¸Šçœ‹åˆ°ä¸åŒæ¬¡ç‰ˆæœ¬è™Ÿï¼Œè«‹ä»¥ crates.io / docs.rs çš„æœ€æ–°ç‰ˆæœ¬ç‚ºæº–ï¼›ä¸Šé¢ç‰ˆæœ¬ä»¥ 0.6.x ç³»åˆ—ç‚ºç¤ºæ„ï¼Œå¯¦éš›å¯ç”¨ `cargo search pingora` æˆ–æŸ¥ docs.rsã€‚ï¼‰([crates.io][4])

### 3) `src/main.rs`ï¼ˆç°¡åŒ–ç¤ºä¾‹ï¼‰

> æ³¨æ„ï¼šPingora çš„ API æœ‰äº› trait/å‹åˆ¥æ˜¯ç”± `pingora-proxy` èˆ‡ `pingora-core` æä¾›ã€‚ä¸‹é¢ç¨‹å¼æ¡å®˜æ–¹ blog/docs ç¯„ä¾‹é¢¨æ ¼ï¼ˆä½œç‚ºä¸€å€‹ minimal starting-pointï¼‰ï¼Œå¯èƒ½éœ€è¦æ ¹æ“šä½ æ‰€ç”¨çš„ pingora ç‰ˆæœ¬ä½œå°æ”¹å‹•ï¼ˆä½†å¤§æ–¹å‘ã€callback èˆ‡ `upstream_peer()` çš„æ¦‚å¿µä¸è®Šï¼‰ã€‚

```rust
use async_trait::async_trait;
use pingora_core::server::Server;
use pingora_core::Result as PingoraResult;
use pingora_load_balancing::LoadBalancer;
use pingora_proxy::prelude::*;
use std::sync::Arc;

/// æˆ‘å€‘çš„ LB ç‰©ä»¶ï¼šå…§å« pingora_load_balancing::LoadBalancer
pub struct LB(Arc<LoadBalancer>);

#[async_trait]
impl ProxyHttp for LB {
    /// é€™æ˜¯ pingora-proxy è¦ä½ å¯¦ä½œçš„æ ¸å¿ƒå‡½å¼ï¼šæ¯å€‹è«‹æ±‚æœƒå‘¼å«ï¼Œå›å‚³è¦ proxy çš„ upstream HttpPeer
    async fn upstream_peer(
        &self,
        _session: &Session,
        _ctx: &ProxyContext,
    ) -> PingoraResult<Box<dyn HttpPeer>> {
        // å¾ LoadBalancer é¸ä¸€å€‹ backendï¼ˆround-robin / å¥åº·æª¢æŸ¥å·²ç”± LoadBalancer ç®¡ç†ï¼‰
        let peer = self.0.select().ok_or_else(|| {
            pingora_core::Error::from("no healthy upstream available")
        })?;
        Ok(Box::new(peer))
    }

    // å…¶ä»– callbackï¼ˆå¦‚ä¿®æ”¹ requestã€responseã€éŒ¯èª¤è™•ç†ï¼‰å¯ä»¥é¸æ“‡æ€§å¯¦ä½œ
}

#[tokio::main(flavor = "multi_thread")]
async fn main() -> anyhow::Result<()> {
    // å»ºç«‹ä¸€å€‹ LoadBalancerï¼Œä¾†æºå¯ä»¥æ˜¯éœæ…‹ list æˆ– service-discovery
    // ç¯„ä¾‹: å…©å€‹ upstream (IP:port)ï¼›çœŸå¯¦æ¡ˆä¾‹å¯ç”¨ DNS/service discovery
    let backends = vec!["1.1.1.1:443".to_string(), "1.0.0.1:443".to_string()];
    let lb = LoadBalancer::try_from_iter(backends.into_iter()).unwrap();
    let lb = Arc::new(lb);

    // å»ºç«‹ pingora http proxy serviceï¼ˆæŠŠæˆ‘å€‘çš„ LB å°é€²å»ï¼‰
    let proxy = pingora_proxy::http_proxy_service(&Default::default(), LB(lb.clone()));
    // ç¶å®šä¸€å€‹ TCP port æä¾›å¤–éƒ¨é€£ç·š
    proxy.add_tcp("127.0.0.1:6188");

    // å»ºä¸€å€‹ Server å¯¦ä¾‹ï¼Œè¨»å†Š serviceï¼Œå•Ÿå‹•
    let mut server = Server::new(None).unwrap();
    server.add_service(proxy);
    server.run_forever(); // é˜»å¡ç›´åˆ°æ”¶åˆ° shutdown ä¿¡è™Ÿ
    Ok(())
}
```

> ä¸Šé¢ç¤ºä¾‹æ¡ç”¨å®˜æ–¹ blog / quick-start çš„å¯«æ³•ï¼š`ProxyHttp` åªéœ€å›å‚³ upstream peerï¼Œè€Œ `LoadBalancer` è² è²¬å¥åº·æª¢æŸ¥èˆ‡é¸æ“‡é‚è¼¯ã€‚ç´°ç¯€è«‹åƒè€ƒå®˜æ–¹ `examples/load_balancer.rs`ã€‚([The Cloudflare Blog][5])

---

# è¨­è¨ˆè¦é»èˆ‡é€²éšåŠŸèƒ½ï¼ˆå¯¦å‹™è¨Šæ¯ï¼‰

1. **å¥åº·æª¢æŸ¥ & service discovery**
   `pingora-load-balancing` æä¾› service discovery èˆ‡ health-check æ¨¡çµ„ï¼Œä½ å¯ä»¥è®“ LoadBalancer é€±æœŸæ€§åœ°è·‘ health checkã€æ›´æ–° backend åˆ—è¡¨ï¼ˆæ”¯æ´ parallel checksã€é »ç‡è¨­å®šç­‰ï¼‰ã€‚([docs.rs][6])

2. **é¸æ“‡æ¼”ç®—æ³•**
   é è¨­æœ‰ round-robinã€ä¸€è‡´æ€§å“ˆå¸Œï¼ˆKetamaï¼‰ç­‰ï¼›ä¹Ÿå¯å¯¦ä½œè‡ªå®š selectionï¼ˆä¾‹å¦‚ä¾æ¬Šé‡ã€å»¶é²ã€éŒ¯èª¤ç‡ï¼‰ã€‚`pingora-load-balancing` æ¨¡çµ„æœ‰ selection interfacesã€‚([docs.rs][6])

3. **TLS**
   Pingora æ”¯æ´ OpenSSLã€BoringSSLã€(experimental) rustlsï¼›å¯ä»¥åš TLS çµ‚ç«¯ï¼ˆlistenerï¼‰æˆ–åš upstream TLSï¼ˆå‘ backend å»º TLSï¼‰ã€‚è‹¥ä½¿ç”¨ BoringSSL/OpenSSLï¼Œbuild ç’°å¢ƒéœ€æœ‰ clang/perl ç­‰ build depsã€‚([docs.rs][2])

4. **é€£ç·šæ± ã€HTTP/2ã€gRPCã€WebSocket**
   Pingora æ”¯æ´ HTTP/1.x èˆ‡ HTTP/2 çš„å…¨ç«¯åˆ°ç«¯ proxyï¼Œä»¥åŠ gRPC / websocket proxyingï¼Œä¸¦æœ‰é€£ç·šæ± æ©Ÿåˆ¶ã€‚è¦–éœ€æ±‚å¯å•Ÿç”¨æˆ–è‡ªè¨‚è½‰é€ï¼æƒæè«‹æ±‚èˆ‡å›æ‡‰ã€‚([docs.rs][7])

5. **éŒ¯èª¤è™•ç†èˆ‡é‡è©¦**
   å¯è¨­å®šé‡è©¦ã€failover èˆ‡å›é€€ç­–ç•¥ï¼ˆä¾‹å¦‚é‡ç‰¹å®š 5xx æˆ– connection error å†æ› backendï¼‰ã€‚`ProxyHttp` æä¾›åœ¨ä¸åŒéšæ®µæ””æˆªè™•ç†çš„ hooksã€‚([docs.rs][7])

6. **è§€æ¸¬ (metrics / logging / tracing)**
   åœ¨ç”Ÿç”¢ç’°å¢ƒå»ºè­°æ¥å…¥ Prometheus metricsã€structured loggingï¼ˆtrace/spanï¼‰ï¼Œä¸¦æŠŠè«‹æ±‚ summaryã€retry/latency/error è³‡è¨Šè¼¸å‡ºï¼Œæ–¹ä¾¿ load balancing èª¿å„ªã€‚

7. **ç†±å‡ç´š / graceful reload**
   Pingora server æœ‰å…§å»º signal è™•ç†ï¼Œå¯åš zero-downtime reload æˆ– graceful shutdownï¼ˆå®˜æ–¹ Server ç®¡ç†ç”Ÿå‘½é€±æœŸï¼‰ã€‚([docs.rs][2])

---

# æ¸¬è©¦æ–¹æ³•ï¼ˆlocalï¼‰

1. å•Ÿå‹•å…©å€‹ç°¡å–®çš„ HTTP å¾Œç«¯ï¼ˆä¾‹å¦‚ç”¨ `python -m http.server 4000` èˆ‡ 4001ï¼Œæˆ–ç”¨ç°¡å–®çš„ echo serverï¼‰ã€‚
2. ç·¨è­¯ä¸¦å•Ÿå‹•ä¸Šé¢çš„ pingora æœå‹™ï¼š`cargo run`ã€‚
3. ç”¨ `curl` é€£åˆ° frontend `127.0.0.1:6188` å¤šæ¬¡ï¼Œæª¢æŸ¥è«‹æ±‚æ˜¯å¦è¢«åˆ†æ•£åˆ°å…©å€‹ backendï¼ˆæˆ–åœ¨ response header ç”¨è‡ªè¨‚ header é¡¯ç¤º upstreamï¼‰ã€‚
4. åœæ‰å…¶ä¸­ä¸€å€‹ backendï¼Œè§€å¯Ÿ LoadBalancer æ˜¯å¦å°‡è©² backend æ¨™ç‚º unhealthy ä¸¦åœæ­¢é¸å®ƒï¼ˆæª¢æŸ¥ logs / metricsï¼‰ã€‚

---

# å¸¸è¦‹å•é¡Œèˆ‡å¯¦ä½œå»ºè­°

* **examples ä¸å¯ç›´æ¥è·‘ï¼Ÿ** å®˜æ–¹ example åœ¨ä¸åŒç‰ˆæœ¬é–“å¯èƒ½éœ€è¦å¾®èª¿ï¼ˆissue ä¹Ÿæœ‰è¨è«–ï¼‰ï¼›å¦‚æœé‡åˆ° build/502ï¼Œè«‹ç¢ºèªä½ æœ¬åœ°çš„ crate ç‰ˆæœ¬èˆ‡ `examples` å°æ‡‰çš„ç‰ˆæœ¬ä¸€è‡´ï¼ˆæˆ–ç›´æ¥ç”¨ docs.rs ä¸Šçš„ç¯„ä¾‹ï¼‰ã€‚([GitHub][8])
* **æƒ³è¦ URL è·¯ç”±ï¼ˆAPI Gatewayï¼‰**ï¼šåœ¨ `ProxyHttp` çš„ callback éšæ®µï¼Œæ ¹æ“š `Host`ã€path æˆ– header æ±ºå®šä¸åŒçš„ LoadBalancerï¼ˆmulti-tenant or multi-lbï¼‰ã€‚å®˜æ–¹ `examples/gateway.rs` å±•ç¤ºå¦‚ä½•åš gateway é¡å‹çš„è¡Œç‚ºã€‚([docs.rs][3])
* **å®‰å…¨æ³¨æ„**ï¼šè‹¥è™•ç†å…¬é–‹æµé‡ï¼Œå¼·çƒˆå»ºè­°ä½¿ç”¨ mTLS / å¼·åŒ– TLS è¨­å®šä¸¦é™åˆ¶ upstream åˆ—è¡¨ä¾†æºï¼Œä¸¦æ–½è¡Œ rate-limits / WAF å±¤ï¼ˆå¯ä»¥åœ¨ proxy éšæ®µåŠ å…¥ request scanning æ¨¡çµ„ï¼‰ã€‚

---

# åƒè€ƒï¼ˆé‡è¦ä¾†æºï¼‰

1. Pingora GitHubï¼ˆrepo / README / examplesï¼‰ã€‚([GitHub][1])
2. `pingora-proxy` crate docsï¼ˆexamples é›†åˆï¼š`load_balancer.rs`, `gateway.rs` ç­‰ï¼‰ã€‚([docs.rs][3])
3. Cloudflare ç™¼è¡¨æ–‡ç« èˆ‡ quick-startï¼ˆæ•™å­¸ç¯„ä¾‹èˆ‡æ¦‚å¿µèªªæ˜ï¼‰ã€‚([The Cloudflare Blog][5])
4. `pingora-load-balancing` crate docsï¼ˆhealth check / selection APIï¼‰ã€‚([docs.rs][6])

---

å¦‚æœä½ è¦ï¼Œæˆ‘å¯ä»¥ï¼š

1. æŠŠä¸Šé¢çš„æœ€å°ç¯„ä¾‹ **è£œæˆçœŸæ­£åœ¨æœ¬åœ°å¯ç·¨è­¯ä¸”å« `Cargo.lock` çš„å®Œæ•´å°ˆæ¡ˆ**ï¼ˆæˆ‘æœƒç›´æ¥è²¼å®Œæ•´ `main.rs`ã€`Cargo.toml`ï¼Œä¸¦æŠŠéœ€è¦çš„å¾®èª¿èªªæ˜åˆ—å‡ºï¼‰ã€‚
2. å¹«ä½ æŠŠè¨­è¨ˆå»¶ä¼¸ç‚º**å…·é«” production blueprint**ï¼ˆTLS + mTLS é…ç½®ã€Prometheus metricsã€systemd / container åŒ–ã€CI/CD éƒ¨ç½²æ­¥é©Ÿï¼‰ã€‚
3. æˆ–è€…ç›´æ¥ç‚º **API Gateway** åšè·¯ç”±ç¯„ä¾‹ï¼ˆæ ¹æ“š hostname è·¯ç”±åˆ°ä¸åŒ backend æ± ï¼‰ï¼Œä¸¦ç¤ºç¯„ health-check èˆ‡æ¬Šé‡åˆ†é…ç¨‹å¼ç¢¼ç‰‡æ®µã€‚

ä½ æƒ³è¦å…ˆè¦å“ªä¸€å€‹ï¼Ÿæˆ‘æœƒç›´æ¥æŠŠå°æ‡‰çš„å®Œæ•´ç¨‹å¼ç¢¼èˆ‡æ­¥é©Ÿè²¼å‡ºä¾†ï¼ˆä¸ç”¨ä½ ç­‰å€™ï¼‰ã€‚

[1]: https://github.com/cloudflare/pingora?utm_source=chatgpt.com "cloudflare/pingora: A library for building fast, reliable and ..."
[2]: https://docs.rs/pingora?utm_source=chatgpt.com "pingora - Rust"
[3]: https://docs.rs/crate/pingora-proxy/latest/source/examples/multi_lb.rs?utm_source=chatgpt.com "pingora-proxy 0.6.0"
[4]: https://crates.io/crates/pingora?utm_source=chatgpt.com "pingora - crates.io: Rust Package Registry"
[5]: https://blog.cloudflare.com/pingora-open-source/?utm_source=chatgpt.com "Open sourcing Pingora: our Rust framework for building ..."
[6]: https://docs.rs/pingora-load-balancing?utm_source=chatgpt.com "pingora_load_balancing - Rust"
[7]: https://docs.rs/pingora-proxy?utm_source=chatgpt.com "pingora_proxy - Rust"
[8]: https://github.com/cloudflare/pingora/issues/460?utm_source=chatgpt.com "Examples not reproducible Â· Issue #460 Â· cloudflare/pingora"



Excellent â€” thatâ€™s one of **Pingoraâ€™s key strengths**.
It provides precise hooks in the request/response pipeline for **header manipulation**, **body rewriting**, and even **protocol upgrades (WebSocket, gRPC, etc.)**.

Letâ€™s walk through how to do **HTTP header rewrite** (both request â†’ upstream and response â† downstream) cleanly in Rust with Pingora.

---

## ğŸ§© Overview â€” Where to Rewrite Headers

When implementing `ProxyHttp`, you have multiple hook points:

| Hook method                          | When it runs                                       | Use case                         |
| ------------------------------------ | -------------------------------------------------- | -------------------------------- |
| `prepare_request`                    | Before sending request to upstream                 | Rewrite request headers or URL   |
| `prepare_response`                   | After receiving response from upstream             | Rewrite response headers or body |
| `upstream_peer`                      | Select upstream server                             | Routing/load-balance logic       |
| `request_filter` / `response_filter` | Stream-level hooks (body streaming / modification) | Advanced transformations         |

So for headers specifically, you usually want to override **`prepare_request`** and **`prepare_response`**.

---

## ğŸ¦€ Example: Rewrite Request + Response Headers

Below is a minimal example based on `pingora-proxy` demonstrating both directions.

```rust
use async_trait::async_trait;
use pingora_core::Result as PingoraResult;
use pingora_core::server::Server;
use pingora_proxy::prelude::*;
use std::sync::Arc;

pub struct HeaderRewriteProxy;

#[async_trait]
impl ProxyHttp for HeaderRewriteProxy {
    async fn upstream_peer(
        &self,
        _session: &Session,
        _ctx: &ProxyContext,
    ) -> PingoraResult<Box<dyn HttpPeer>> {
        // Choose a static upstream for this example
        Ok(Box::new(HttpPeer::new("httpbin.org:80", false)))
    }

    async fn prepare_request(
        &self,
        session: &mut Session,
        _ctx: &mut ProxyContext,
    ) -> PingoraResult<()> {
        let req = session.req_header_mut();

        // Add or replace headers before forwarding to upstream
        req.insert_header("x-proxy-added", "pingora");
        req.remove_header("x-secret-internal"); // strip internal headers
        req.insert_header("user-agent", "PingoraProxy/1.0");

        // Optionally rewrite path or host
        req.set_uri_path("/anything"); // rewrite target path

        Ok(())
    }

    async fn prepare_response(
        &self,
        session: &mut Session,
        _ctx: &mut ProxyContext,
    ) -> PingoraResult<()> {
        let resp = session.rsp_header_mut();

        // Add custom response header before sending to client
        resp.insert_header("x-proxy", "pingora");

        // Strip sensitive backend info
        resp.remove_header("server");

        Ok(())
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut server = Server::new(None)?;
    let proxy = pingora_proxy::http_proxy_service(&Default::default(), HeaderRewriteProxy);
    proxy.add_tcp("0.0.0.0:6188");
    server.add_service(proxy);
    server.run_forever();
    Ok(())
}
```

âœ… **Behavior:**

* Client connects to your proxy at `127.0.0.1:6188`.
* Request is rewritten (e.g., changes `User-Agent`, adds `x-proxy-added`).
* Response header `server` is removed; `x-proxy` is added.

---

## ğŸ§  Notes & Best Practices

### 1. Header API summary

Pingoraâ€™s `HeaderMap` interface supports:

```rust
req.get_header("header-name");
req.insert_header("header-name", "value");
req.remove_header("header-name");
req.set_uri_path("/new/path");
req.set_uri_host("backend.example.com");
```

### 2. Case-insensitive header handling

HTTP headers are case-insensitive; Pingora normalizes them internally.

### 3. Response streaming

If you need to *inspect or modify* body content, use `response_filter()` instead â€”
it gives you async streams of bytes for deeper transformations.

### 4. Conditional rewrite

Because you have full access to `Session`, you can conditionally rewrite:

```rust
if session.req_header().uri().path().starts_with("/api/") {
    req.insert_header("x-api-route", "1");
}
```

### 5. Tracing / metrics

You can record metrics on rewrite actions or inject tracing headers like:

```rust
req.insert_header("x-request-id", uuid::Uuid::new_v4().to_string());
```

---

## ğŸ§± Integration with Load Balancer / Gateway

Combine this with the previous load-balancer example:

* Keep `LB(Arc<LoadBalancer>)` struct.
* Implement both `upstream_peer()` and `prepare_request()` / `prepare_response()`.
* Header rewrite happens naturally before/after upstream connection.

So your struct could look like:

```rust
pub struct LBProxy {
    lb: Arc<LoadBalancer>,
}
```

and implement:

```rust
impl ProxyHttp for LBProxy {
    async fn upstream_peer(...) { ... }
    async fn prepare_request(...) { rewrite headers }
    async fn prepare_response(...) { rewrite headers }
}
```

---

## ğŸ”§ Testing

Run:

```bash
cargo run
```

Then test with `curl`:

```bash
curl -v http://127.0.0.1:6188/get
```

You should see:

```
> User-Agent: PingoraProxy/1.0
> X-Proxy-Added: pingora
< X-Proxy: pingora
```

---

## ğŸš€ Advanced Ideas

* **Dynamic header policy**: Load rewrite rules from config file / Redis / etcd.
* **Per-route logic**: Use path/host matchers to apply different rewrite rules.
* **Header-based routing**: Inspect headers (like `x-tenant-id`) to select different upstream pools.

---

Would you like me to extend this into a **Gateway-style proxy** (multiple backends, route & rewrite based on hostname/path) next?
Thatâ€™s usually the next step â€” like a full mini-Envoy built with Pingora.
