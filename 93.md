Here's a practical example to help you practice event-driven architecture with Rust and Actix using the Actor model. We'll build an order processing system with multiple actors communicating via messages.

### Step 1: Setup Dependencies
Add to `Cargo.toml`:
```toml
[package]
name = "actix-event-driven"
version = "0.1.0"
edition = "2021"

[dependencies]
actix = "0.13.0"
actix-rt = "2.8.0"  # Runtime for Actix
serde = { version = "1.0", features = ["derive"] }  # For serialization
tracing = "0.1"  # For logging
tracing-subscriber = "0.3"
```

### Step 2: Define Messages and Actors
```rust
// main.rs
use actix::prelude::*;
use serde::Serialize;
use tracing::{info, Level};
use tracing_subscriber::FmtSubscriber;

// Events (Messages)
#[derive(Message, Debug)]
#[rtype(result = "()")]
enum OrderEvent {
    OrderCreated {
        id: u32,
        product: String,
        quantity: u32,
    },
    OrderCancelled(u32),
}

#[derive(Message, Debug)]
#[rtype(result = "()")]
struct PaymentProcessed {
    order_id: u32,
    amount: f64,
}

// Actors
struct OrderProcessor {
    processed_count: u32,
}

struct PaymentGateway;

struct InventoryManager;

// Actor Implementations
impl Actor for OrderProcessor {
    type Context = Context<Self>;
}

impl Actor for PaymentGateway {
    type Context = Context<Self>;
}

impl Actor for InventoryManager {
    type Context = Context<Self>;
}

// Message Handlers
impl Handler<OrderEvent> for OrderProcessor {
    type Result = ();

    fn handle(&mut self, msg: OrderEvent, ctx: &mut Context<Self>) {
        self.processed_count += 1;
        
        match &msg {
            OrderEvent::OrderCreated { id, product, quantity } => {
                info!("üì¶ Processing order #{}: {}x {}", id, quantity, product);
                // Forward to payment and inventory
                PaymentGateway::from_registry().do_send(PaymentProcessed {
                    order_id: *id,
                    amount: (quantity * 10) as f64,
                });
                
                InventoryManager::from_registry().do_send(msg.clone());
            }
            OrderEvent::OrderCancelled(id) => {
                info!("‚ùå Cancelling order #{}", id);
                InventoryManager::from_registry().do_send(msg.clone());
            }
        }
    }
}

impl Handler<PaymentProcessed> for PaymentGateway {
    type Result = ();

    fn handle(&mut self, msg: PaymentProcessed, _ctx: &mut Context<Self>) {
        info!("üí≥ Processed payment for order #{}: ${:.2}", msg.order_id, msg.amount);
    }
}

impl Handler<OrderEvent> for InventoryManager {
    type Result = ();

    fn handle(&mut self, msg: OrderEvent, _ctx: &mut Context<Self>) {
        match msg {
            OrderEvent::OrderCreated { id, product, quantity } => {
                info!("üì¶ Updated inventory for {}: -{} units", product, quantity);
            }
            OrderEvent::OrderCancelled(id) => {
                info!("üì¶ Restocked items from cancelled order #{}", id);
            }
        }
    }
}
```

### Step 3: Main Application
```rust
#[actix_rt::main]
async fn main() {
    // Initialize logging
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber).unwrap();

    // Start actors
    OrderProcessor { processed_count: 0 }.start();
    PaymentGateway.start();
    InventoryManager.start();

    // Get OrderProcessor address
    let order_processor = OrderProcessor::from_registry();

    // Send events
    order_processor.send(OrderEvent::OrderCreated {
        id: 1,
        product: "Rust Book".to_string(),
        quantity: 2,
    }).await.unwrap();

    order_processor.send(OrderEvent::OrderCreated {
        id: 2,
        product: "Actix Guide".to_string(),
        quantity: 1,
    }).await.unwrap();

    tokio::time::sleep(std::time::Duration::from_secs(1)).await;

    order_processor.send(OrderEvent::OrderCancelled(2)).await.unwrap();
}
```

### Step 4: Run and Output
```bash
cargo run

üì¶ Processing order #1: 2x Rust Book
üí≥ Processed payment for order #1: $20.00
üì¶ Updated inventory for Rust Book: -2 units

üì¶ Processing order #2: 1x Actix Guide
üí≥ Processed payment for order #2: $10.00
üì¶ Updated inventory for Actix Guide: -1 units

‚ùå Cancelling order #2
üì¶ Restocked items from cancelled order #2
```

### Key Concepts Practiced:
1. **Actor System**:
   - Each component (OrderProcessor, PaymentGateway, InventoryManager) is a separate actor
   - Actors run in isolation with private state

2. **Message Passing**:
   - Events are sent as messages (`OrderEvent`, `PaymentProcessed`)
   - Non-blocking communication with `do_send` and `send`

3. **Decoupled Components**:
   - Actors communicate only through messages
   - Easy to add new processors (e.g., ShippingManager)

4. **Error Isolation**:
   - Failures in one actor don't crash others
   - Supervision strategies can be added

5. **Registry Pattern**:
   - `from_registry()` for easy actor discovery
   - Automatic address management

### Practice Extensions:
1. Add dead letter handling:
   ```rust
   system.registry().set_dead_letters(DeadLetterHandler::new());
   ```

2. Implement retry logic for failed payments:
   ```rust
   impl Handler<PaymentFailed> for OrderProcessor {
       fn handle(&mut self, msg: PaymentFailed, ctx: &mut Context<Self>) {
           ctx.run_later(Duration::from_secs(5), |act, ctx| {
               PaymentGateway::from_registry().do_send(RetryPayment(msg.order_id))
           });
       }
   }
   ```

3. Add metrics collection:
   ```rust
   struct MetricsCollector;
   impl Handler<ProcessedEvent> for MetricsCollector {
       fn handle(&mut self, msg: ProcessedEvent, _ctx: &mut Context<Self>) {
           metrics::increment_counter!("events_processed");
       }
   }
   ```

4. Implement backpressure:
   ```rust
   let (tx, rx) = bounded(100); // Backpressure at 100 messages
   ```

This example demonstrates core EDA principles using Rust's strong type system and Actix's actor model. The compiler ensures message correctness, while the actor model provides natural concurrency boundaries.
