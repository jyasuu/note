ç•¶ç„¶å¯ä»¥ï¼æˆ‘å€‘ä¾†ç³»çµ±æ€§åœ°è£œç¿’ã€Œå“ˆå¸Œè¡¨ã€ï¼ˆHash Tableï¼Œä¹Ÿç¨±æ•£åˆ—è¡¨ï¼‰çš„çŸ¥è­˜ã€‚æˆ‘æœƒå¾åŸºç¤æ¦‚å¿µè¬›èµ·ï¼Œé€æ­¥æ·±å…¥ï¼Œä¸¦æ­é…å¯¦éš›æ‡‰ç”¨å ´æ™¯å’Œç°¡å–®ç¨‹å¼ç¯„ä¾‹ï¼ˆPythonï¼‰ï¼Œå¹«åŠ©ä½ å¾¹åº•ç†è§£ã€‚

---

## ä¸€ã€å“ˆå¸Œè¡¨æ˜¯ä»€éº¼ï¼Ÿ
**å“ˆå¸Œè¡¨**æ˜¯ä¸€ç¨®é«˜æ•ˆçš„ã€Œéµå€¼å°ã€ï¼ˆKey-Value Pairï¼‰è³‡æ–™çµæ§‹ï¼Œèƒ½åœ¨å¹³å‡ **O(1) æ™‚é–“è¤‡é›œåº¦**ä¸‹å®Œæˆè³‡æ–™çš„æ’å…¥ã€åˆªé™¤å’ŒæŸ¥è©¢æ“ä½œã€‚

### æ ¸å¿ƒæ€æƒ³ï¼š
1. **é€éã€Œå“ˆå¸Œå‡½æ•¸ã€å°‡ Key è½‰æ›æˆé™£åˆ—ç´¢å¼•**  
   ï¼ˆä¾‹å¦‚ï¼š`hash("apple") = 3` â†’ å°‡è³‡æ–™å­˜åœ¨é™£åˆ—ç´¢å¼• 3 çš„ä½ç½®ï¼‰ã€‚
2. **ç”¨é™£åˆ—å„²å­˜ Value**ï¼Œé€éç´¢å¼•å¿«é€Ÿå®šä½ã€‚

---

## äºŒã€å“ˆå¸Œå‡½æ•¸ï¼ˆHash Functionï¼‰
é€™æ˜¯å“ˆå¸Œè¡¨çš„éˆé­‚ï¼Œéœ€æ»¿è¶³ï¼š
1. **ä¸€è‡´æ€§**ï¼šç›¸åŒ Key æ°¸é å¾—åˆ°ç›¸åŒç´¢å¼•ã€‚
2. **é«˜æ•ˆæ€§**ï¼šè¨ˆç®—é€Ÿåº¦è¦å¿«ã€‚
3. **å‡å‹»åˆ†ä½ˆ**ï¼šä¸åŒ Key ç›¡é‡æ˜ å°„åˆ°ä¸åŒç´¢å¼•ï¼ˆæ¸›å°‘è¡çªï¼‰ã€‚

### å¸¸è¦‹å“ˆå¸Œå‡½æ•¸ï¼š
- **é™¤ç•™é¤˜æ•¸æ³•**ï¼š`hash(key) = key % table_size`
- **ä¹˜æ³•å“ˆå¸Œ**ï¼š`hash(key) = floor(table_size * (key * A % 1))`ï¼ˆ`0<A<1`ï¼‰
- å­—ä¸²å¸¸ç”¨ **Polynomial Rolling Hash**ï¼ˆå¦‚ Java çš„ `String.hashCode()`ï¼‰

---

## ä¸‰ã€å“ˆå¸Œè¡çªï¼ˆCollisionï¼‰
ç•¶å…©å€‹ä¸åŒçš„ Key å“ˆå¸Œåˆ°åŒä¸€å€‹ç´¢å¼•æ™‚ï¼Œç¨±ç‚º**è¡çª**ã€‚è§£æ±ºæ–¹æ³•ä¸»è¦æœ‰å…©é¡ï¼š

### 1. é–‹æ”¾å®šå€æ³•ï¼ˆOpen Addressingï¼‰
- **ç·šæ€§æ¢æ¸¬**ï¼šè‹¥ç´¢å¼• `i` è¢«ä½”ç”¨ï¼Œå˜—è©¦ `i+1, i+2, ...`ï¼ˆå¯èƒ½å°è‡´èšé›†ï¼‰ã€‚
- **å¹³æ–¹æ¢æ¸¬**ï¼šå˜—è©¦ `i + 1Â², i + 2Â², ...`ï¼ˆæ¸›è¼•èšé›†å•é¡Œï¼‰ã€‚
- **é›™é‡å“ˆå¸Œ**ï¼šç”¨ç¬¬äºŒå€‹å“ˆå¸Œå‡½æ•¸è¨ˆç®—æ­¥é•·ã€‚

### 2. éˆåœ°å€æ³•ï¼ˆSeparate Chainingï¼‰
- **åœ¨æ¯å€‹ç´¢å¼•ä½ç½®å­˜ä¸€å€‹éˆè¡¨ï¼ˆæˆ–æ¨¹ï¼‰**ï¼Œè¡çªçš„ Key è¿½åŠ åˆ°éˆè¡¨ä¸­ã€‚  
  ï¼ˆå¦‚ Java çš„ `HashMap` åœ¨è¡çªå¤šæ™‚æœƒè½‰ç‚ºç´…é»‘æ¨¹ï¼‰

---

## å››ã€å¯¦éš›æ“ä½œæµç¨‹ï¼ˆä»¥æ’å…¥ç‚ºä¾‹ï¼‰
å‡è¨­å“ˆå¸Œå‡½æ•¸ç‚º `hash(key) = key % 10`ï¼š
1. æ’å…¥ `(5, "A")` â†’ ç´¢å¼• `5%10=5` â†’ å­˜å…¥ä½ç½® 5ã€‚
2. æ’å…¥ `(15, "B")` â†’ ç´¢å¼• `15%10=5` â†’ **è¡çªï¼**
   - è‹¥ç”¨éˆåœ°å€æ³•ï¼šåœ¨ç´¢å¼• 5 çš„éˆè¡¨è¿½åŠ ç¯€é»ã€‚
   - è‹¥ç”¨ç·šæ€§æ¢æ¸¬ï¼šå°‹æ‰¾ä¸‹ä¸€å€‹ç©ºä½ï¼ˆå¦‚ä½ç½® 6ï¼‰ã€‚

---

## äº”ã€é—œéµåƒæ•¸ï¼šè² è¼‰å› å­ï¼ˆLoad Factorï¼‰
å®šç¾©ï¼š`Î± = ç•¶å‰å…ƒç´ æ•¸é‡ / å“ˆå¸Œè¡¨ç¸½æ§½æ•¸`  
ç•¶ `Î± > é–¾å€¼`ï¼ˆé€šå¸¸è¨­ 0.7ï¼‰æ™‚ï¼Œå“ˆå¸Œè¡¨æœƒ**è‡ªå‹•æ“´å®¹ï¼ˆRehashingï¼‰**ï¼š
1. å‰µå»ºä¸€å€‹æ›´å¤§çš„æ–°é™£åˆ—ï¼ˆå¦‚ 2 å€å¤§å°ï¼‰ã€‚
2. é‡æ–°å“ˆå¸Œæ‰€æœ‰ Key ä¸¦å­˜å…¥æ–°é™£åˆ—ã€‚
3. **æ“´å®¹æ˜¯ O(n) æ“ä½œ**ï¼Œä½†æ”¤é‚„åˆ†æä¸‹ä»è¦–ç‚º O(1)ã€‚

---

## å…­ã€æ™‚é–“è¤‡é›œåº¦åˆ†æ
| æ“ä½œ       | å¹³å‡æƒ…æ³ | æœ€å£æƒ…æ³       |
|------------|----------|----------------|
| æ’å…¥       | O(1)     | O(n)           |
| åˆªé™¤       | O(1)     | O(n)           |
| æŸ¥è©¢       | O(1)     | O(n)           |

> **æœ€å£æƒ…æ³**ï¼šæ‰€æœ‰ Key éƒ½è¡çªï¼Œé€€åŒ–ç‚ºéˆè¡¨ï¼ˆæˆ–éœ€ç·šæ€§æ¢æ¸¬æ•´å€‹è¡¨ï¼‰ã€‚

---

## ä¸ƒã€å“ˆå¸Œè¡¨çš„å„ªç¼ºé»
### âœ… å„ªé»ï¼š
- **æ¥µå¿«çš„æŸ¥è©¢/æ’å…¥/åˆªé™¤**ï¼ˆå¹³å‡ O(1)ï¼‰ã€‚
- éˆæ´»å„²å­˜ä»»æ„éµå€¼å°ã€‚

### âŒ ç¼ºé»ï¼š
- **ä¸ä¿è­‰é †åº**ï¼ˆè‹¥éœ€æœ‰åºéœ€ç‰¹æ®Šè¨­è¨ˆï¼Œå¦‚ LinkedHashMapï¼‰ã€‚
- å“ˆå¸Œå‡½æ•¸è¨­è¨ˆä¸ç•¶æœƒå°è‡´æ•ˆç‡ä¸‹é™ã€‚
- éœ€è¦é ç•™è¨˜æ†¶é«”ç©ºé–“ï¼ˆç©ºé–“æ›æ™‚é–“ï¼‰ã€‚

---

## å…«ã€å¯¦éš›æ‡‰ç”¨å ´æ™¯
1. **è³‡æ–™åº«ç´¢å¼•**ï¼šå¿«é€Ÿå®šä½è¨˜éŒ„ã€‚
2. **ç·©å­˜ç³»çµ±**ï¼ˆå¦‚ Redisï¼‰ï¼šéµå€¼å­˜å„²ã€‚
3. **å­—å…¸çµæ§‹**ï¼ˆPython `dict`ã€JavaScript `Map`ï¼‰ã€‚
4. **å»é‡è¤‡**ï¼ˆå¦‚çµ±è¨ˆä¸é‡è¤‡å–®è©æ•¸ï¼‰ã€‚
5. **ç‰©ä»¶å±¬æ€§æŸ¥æ‰¾**ï¼ˆJavaScript ç‰©ä»¶åŸç†ï¼‰ã€‚

---

## ä¹ã€ç¨‹å¼ç¯„ä¾‹ï¼ˆPython å¯¦ç¾ç°¡æ˜“å“ˆå¸Œè¡¨ï¼‰
```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # ä½¿ç”¨éˆåœ°å€æ³•

    def _hash(self, key):
        return hash(key) % self.size  # å…§å»º hash() å‡½æ•¸

    def put(self, key, value):
        index = self._hash(key)
        for item in self.table[index]:
            if item[0] == key:
                item[1] = value  # æ›´æ–°ç¾æœ‰ Key
                return
        self.table[index].append([key, value])  # æ–°å¢éµå€¼å°

    def get(self, key):
        index = self._hash(key)
        for item in self.table[index]:
            if item[0] == key:
                return item[1]
        raise KeyError(f"Key '{key}' not found")

# æ¸¬è©¦
ht = HashTable()
ht.put("name", "Alice")
ht.put("age", 30)
print(ht.get("name"))  # è¼¸å‡º: Alice
```

---

## åã€é¢è©¦å¸¸è¦‹å•é¡Œ
1. å¦‚ä½•è¨­è¨ˆä¸€å€‹å“ˆå¸Œå‡½æ•¸ï¼Ÿ
2. è§£é‡‹ Rehashing çš„éç¨‹èˆ‡é–‹éŠ·ã€‚
3. å“ˆå¸Œè¡¨ vs å¹³è¡¡æ¨¹ï¼ˆå¦‚ç´…é»‘æ¨¹ï¼‰çš„é©ç”¨å ´æ™¯ï¼Ÿ
4. å¦‚ä½•ç”¨å“ˆå¸Œè¡¨å¯¦ç¾ LRU ç·©å­˜ï¼Ÿ
5. è§£æ±ºè¡çªçš„æ–¹æ³•æœ‰å“ªäº›ï¼Ÿå„æœ‰å“ªäº›å„ªç¼ºé»ï¼Ÿ

---

## ç¸½çµé‡é»ï¼š
- å“ˆå¸Œè¡¨æ ¸å¿ƒï¼š**å“ˆå¸Œå‡½æ•¸ + è¡çªè§£æ±º**ã€‚
- ç›®æ¨™ï¼š**å¹³å‡ O(1) æ™‚é–“æ“ä½œ**ã€‚
- é—œéµåƒæ•¸ï¼š**è² è¼‰å› å­ Î±**ï¼Œè§¸ç™¼æ“´å®¹ã€‚
- æ‡‰ç”¨ï¼š**å¿«é€ŸæŸ¥æ‰¾ã€ç·©å­˜ã€å»é‡**ã€‚

å¦‚æœéœ€è¦æ›´æ·±å…¥æ¢è¨æŸå€‹éƒ¨åˆ†ï¼ˆå¦‚æ“´å®¹ç´°ç¯€ã€å“ˆå¸Œå‡½æ•¸è¨­è¨ˆï¼‰ï¼Œæˆ–æƒ³ç·´ç¿’ç›¸é—œæ¼”ç®—æ³•é¡Œç›®ï¼ˆå¦‚ LeetCode çš„å…©æ•¸ä¹‹å’Œï¼‰ï¼Œéš¨æ™‚å‘Šè¨´æˆ‘ï¼ ğŸ˜Š


ä»¥ä¸‹æ˜¯ä½¿ç”¨ Rust å¯¦ç¾çš„å“ˆå¸Œè¡¨ï¼ˆæ¡ç”¨éˆåœ°å€æ³•è™•ç†è¡çªï¼‰ï¼ŒåŒ…å«è©³ç´°è¨»è§£å’Œæ¸¬è©¦æ¡ˆä¾‹ï¼š

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

const INITIAL_CAPACITY: usize = 7; // åˆå§‹å®¹é‡é¸æ“‡è³ªæ•¸ä»¥æ¸›å°‘è¡çª
const LOAD_FACTOR_THRESHOLD: f64 = 0.75; // è§¸ç™¼æ“´å®¹çš„è² è¼‰å› å­é–¾å€¼

pub struct HashMap<K, V> {
    buckets: Vec<Vec<(K, V)>>, // æ¡¶æ•¸çµ„ï¼Œæ¯å€‹æ¡¶æ˜¯éµå€¼å°çš„å‘é‡
    len: usize,                // ç•¶å‰å­˜å„²çš„éµå€¼å°æ•¸é‡
}

impl<K: Hash + Eq, V> HashMap<K, V> {
    /// å‰µå»ºä¸€å€‹æ–°çš„ç©ºå“ˆå¸Œè¡¨
    pub fn new() -> Self {
        Self {
            buckets: vec![Vec::new(); INITIAL_CAPACITY],
            len: 0,
        }
    }

    /// è¨ˆç®—éµå°æ‡‰çš„æ¡¶ç´¢å¼•
    fn bucket_index(&self, key: &K, bucket_size: usize) -> usize {
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        (hasher.finish() as usize) % bucket_size
    }

    /// æ’å…¥æˆ–æ›´æ–°éµå€¼å°
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        // æª¢æŸ¥æ˜¯å¦éœ€è¦æ“´å®¹
        if self.load_factor() > LOAD_FACTOR_THRESHOLD {
            self.resize();
        }

        let bucket_size = self.buckets.len();
        let index = self.bucket_index(&key, bucket_size);
        let bucket = &mut self.buckets[index];

        // æª¢æŸ¥éµæ˜¯å¦å·²å­˜åœ¨
        for (k, v) in bucket.iter_mut() {
            if k == &key {
                return Some(std::mem::replace(v, value));
            }
        }

        // éµä¸å­˜åœ¨ï¼Œæ’å…¥æ–°å€¼
        bucket.push((key, value));
        self.len += 1;
        None
    }

    /// æ ¹æ“šéµç²å–å€¼
    pub fn get(&self, key: &K) -> Option<&V> {
        let index = self.bucket_index(key, self.buckets.len());
        self.buckets[index]
            .iter()
            .find(|(k, _)| k == key)
            .map(|(_, v)| v)
    }

    /// æ ¹æ“šéµç²å–å¯è®Šå¼•ç”¨
    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {
        let index = self.bucket_index(key, self.buckets.len());
        self.buckets[index]
            .iter_mut()
            .find(|(k, _)| k == key)
            .map(|(_, v)| v)
    }

    /// åˆªé™¤éµå€¼å°
    pub fn remove(&mut self, key: &K) -> Option<V> {
        let index = self.bucket_index(key, self.buckets.len());
        let bucket = &mut self.buckets[index];
        
        if let Some(pos) = bucket.iter().position(|(k, _)| k == key) {
            let (_, value) = bucket.remove(pos);
            self.len -= 1;
            Some(value)
        } else {
            None
        }
    }

    /// è¨ˆç®—ç•¶å‰è² è¼‰å› å­
    fn load_factor(&self) -> f64 {
        self.len as f64 / self.buckets.len() as f64
    }

    /// æ“´å®¹å“ˆå¸Œè¡¨
    fn resize(&mut self) {
        let new_size = self.buckets.len() * 2; // å®¹é‡ç¿»å€
        let mut new_buckets = vec![Vec::new(); new_size];
        
        // å°‡æ‰€æœ‰å…ƒç´ é‡æ–°åˆ†é…åˆ°æ–°æ¡¶ä¸­
        for bucket in self.buckets.drain(..) {
            for (key, value) in bucket {
                let index = self.bucket_index(&key, new_size);
                new_buckets[index].push((key, value));
            }
        }
        
        self.buckets = new_buckets;
    }

    /// ç²å–ç•¶å‰å…ƒç´ æ•¸é‡
    pub fn len(&self) -> usize {
        self.len
    }

    /// æª¢æŸ¥å“ˆå¸Œè¡¨æ˜¯å¦ç‚ºç©º
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let mut map = HashMap::new();
        
        // æ¸¬è©¦æ’å…¥å’ŒæŸ¥è©¢
        assert_eq!(map.insert("key1", 100), None);
        assert_eq!(map.insert("key2", 200), None);
        assert_eq!(*map.get(&"key1").unwrap(), 100);
        assert_eq!(*map.get(&"key2").unwrap(), 200);
        
        // æ¸¬è©¦æ›´æ–°
        assert_eq!(map.insert("key1", 150), Some(100));
        assert_eq!(*map.get(&"key1").unwrap(), 150);
        
        // æ¸¬è©¦åˆªé™¤
        assert_eq!(map.remove(&"key2"), Some(200));
        assert_eq!(map.get(&"key2"), None);
    }

    #[test]
    fn test_resize_mechanism() {
        let mut map = HashMap::new();
        let initial_capacity = map.buckets.len();
        
        // æ’å…¥è¶³å¤ å…ƒç´ è§¸ç™¼æ“´å®¹
        for i in 0..(initial_capacity * 2) {
            map.insert(i, i * 10);
        }
        
        // é©—è­‰æ“´å®¹å¾Œå®¹é‡ç¿»å€
        assert_eq!(map.buckets.len(), initial_capacity * 2);
        
        // é©—è­‰æ‰€æœ‰å…ƒç´ ä»å¯è¨ªå•
        for i in 0..(initial_capacity * 2) {
            assert_eq!(*map.get(&i).unwrap(), i * 10);
        }
    }

    #[test]
    fn test_collision_handling() {
        let mut map = HashMap::new();
        
        // å‰µå»ºæœƒç”¢ç”Ÿè¡çªçš„éµï¼ˆæ•…æ„ä½¿ç”¨ç›¸åŒå“ˆå¸Œå€¼ï¼‰
        #[derive(Debug, PartialEq, Eq)]
        struct CollisionKey(i32);
        
        impl Hash for CollisionKey {
            fn hash<H: Hasher>(&self, state: &mut H) {
                // æ‰€æœ‰éµè¿”å›ç›¸åŒå“ˆå¸Œå€¼
                42.hash(state);
            }
        }
        
        // æ’å…¥å¤šå€‹è¡çªéµ
        map.insert(CollisionKey(1), "first");
        map.insert(CollisionKey(2), "second");
        map.insert(CollisionKey(3), "third");
        
        // é©—è­‰æ‰€æœ‰éµå€¼å°éƒ½å­˜åœ¨
        assert_eq!(map.get(&CollisionKey(1)), Some(&"first"));
        assert_eq!(map.get(&CollisionKey(2)), Some(&"second"));
        assert_eq!(map.get(&CollisionKey(3)), Some(&"third"));
        
        // åˆªé™¤ä¸­é–“éµ
        assert_eq!(map.remove(&CollisionKey(2)), Some("second"));
        
        // é©—è­‰å…¶ä»–éµä»å­˜åœ¨
        assert_eq!(map.get(&CollisionKey(1)), Some(&"first"));
        assert_eq!(map.get(&CollisionKey(3)), Some(&"third"));
    }
}

fn main() {
    // ä½¿ç”¨ç¤ºä¾‹
    let mut word_count = HashMap::new();
    
    let text = "apple banana apple orange banana apple";
    for word in text.split_whitespace() {
        *word_count.get_mut(&word).unwrap_or_else(|| {
            word_count.insert(word, 0);
            word_count.get_mut(&word).unwrap()
        }) += 1;
    }
    
    println!("'apple' count: {}", word_count.get(&"apple").unwrap()); // 3
    println!("'banana' count: {}", word_count.get(&"banana").unwrap()); // 2
}
```

### é—œéµå¯¦ç¾ç´°ç¯€ï¼š

1. **è¡çªè™•ç†**ï¼š
   - ä½¿ç”¨éˆåœ°å€æ³•ï¼ˆæ¯å€‹æ¡¶æ˜¯ `Vec<(K, V)>`ï¼‰
   - è¡çªæ™‚åœ¨å°æ‡‰æ¡¶çš„å‘é‡ä¸­è¿½åŠ å…ƒç´ 

2. **å“ˆå¸Œå‡½æ•¸**ï¼š
   - ä½¿ç”¨ Rust æ¨™æº–åº«çš„ `DefaultHasher`
   - é€šé `key.hash(&mut hasher)` è¨ˆç®—å“ˆå¸Œå€¼
   - æœ€çµ‚ç´¢å¼• = `hash_value % bucket_size`

3. **å‹•æ…‹æ“´å®¹**ï¼š
   - ç•¶è² è¼‰å› å­ > 0.75 æ™‚è§¸ç™¼æ“´å®¹
   - æ–°å®¹é‡ = èˆŠå®¹é‡ Ã— 2
   - æ“´å®¹æ™‚é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 

4. **æ ¸å¿ƒæ“ä½œè¤‡é›œåº¦**ï¼š
   | æ“ä½œ   | å¹³å‡æƒ…æ³ | æœ€å£æƒ…æ³ |
   |--------|----------|----------|
   | æ’å…¥   | O(1)     | O(n)     |
   | æŸ¥è©¢   | O(1)     | O(n)     |
   | åˆªé™¤   | O(1)     | O(n)     |
   | æ“´å®¹   | O(n)     | O(n)     |

5. **å…§å­˜ç®¡ç†**ï¼š
   - ä½¿ç”¨ `Vec` å‹•æ…‹åˆ†é…æ¡¶æ•¸çµ„
   - æ“´å®¹æ™‚é€šé `drain` é«˜æ•ˆè½‰ç§»å…ƒç´ 

### æ¸¬è©¦æ¡ˆä¾‹è¦†è“‹ï¼š

1. **åŸºç¤åŠŸèƒ½æ¸¬è©¦**ï¼š
   - æ’å…¥/æŸ¥è©¢/æ›´æ–°/åˆªé™¤æ“ä½œ
   - è¿”å›å€¼é©—è­‰

2. **æ“´å®¹æ©Ÿåˆ¶æ¸¬è©¦**ï¼š
   - è‡ªå‹•è§¸ç™¼æ“´å®¹çš„æ¢ä»¶
   - æ“´å®¹å¾Œæ•¸æ“šå®Œæ•´æ€§

3. **è¡çªè™•ç†æ¸¬è©¦**ï¼š
   - æ•…æ„å‰µå»ºå“ˆå¸Œè¡çª
   - é©—è­‰è¡çªéµçš„æ­£ç¢ºè™•ç†
   - åˆªé™¤ä¸­é–“è¡çªéµçš„é‚Šç•Œæƒ…æ³

### ä½¿ç”¨å ´æ™¯ç¤ºä¾‹ï¼š
```rust
// çµ±è¨ˆå–®è©é »ç‡
let mut word_count = HashMap::new();
for word in text.split_whitespace() {
    let count = word_count.get_mut(&word).unwrap_or_else(|| {
        word_count.insert(word, 0);
        word_count.get_mut(&word).unwrap()
    });
    *count += 1;
}
```

é€™å€‹å¯¦ç¾å±•ç¤ºäº† Rust çš„æ‰€æœ‰æ¬Šç³»çµ±å¦‚ä½•æ‡‰ç”¨æ–¼å“ˆå¸Œè¡¨ï¼š
1. `insert` ç²å¾—éµå€¼çš„æ‰€æœ‰æ¬Š
2. `get` è¿”å›ä¸å¯è®Šå¼•ç”¨
3. `get_mut` è¿”å›å¯è®Šå¼•ç”¨
4. `remove` è¿”å›è¢«åˆªé™¤å€¼çš„æ‰€æœ‰æ¬Š

å¯ä»¥é€šé `cargo test` é‹è¡Œæ¸¬è©¦æ¡ˆä¾‹é©—è­‰å¯¦ç¾æ­£ç¢ºæ€§ã€‚å¯¦éš›ä½¿ç”¨æ™‚å»ºè­°åƒè€ƒ Rust æ¨™æº–åº«çš„ `std::collections::HashMap`ï¼Œå®ƒä½¿ç”¨æ›´è¤‡é›œçš„æŠ€è¡“ï¼ˆå¦‚ SIMD å„ªåŒ–ã€å®‰å…¨éš¨æ©ŸåŒ–ç¨®å­ç­‰ï¼‰ä¾†æé«˜æ€§èƒ½å’Œå®‰å…¨æ€§ã€‚
