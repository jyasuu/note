I'll help you create a best practice custom DSL (Domain Specific Language) in Rust. Let me build a comprehensive example that demonstrates modern Rust patterns for DSL development.

```rs
// Best practice Rust DSL: A simple query builder DSL
// This demonstrates: builders, macros, trait objects, and error handling

use std::fmt;

// ============= AST (Abstract Syntax Tree) =============
#[derive(Debug, Clone)]
pub enum Expr {
    Column(String),
    Literal(Value),
    BinOp(Box<Expr>, BinOp, Box<Expr>),
    Function(String, Vec<Expr>),
}

#[derive(Debug, Clone)]
pub enum Value {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Null,
}

#[derive(Debug, Clone, Copy)]
pub enum BinOp {
    Eq,
    Gt,
    Lt,
    And,
    Or,
    Add,
    Sub,
}

// ============= Query Builder (Fluent API) =============
pub struct QueryBuilder {
    select: Vec<Expr>,
    from: Option<String>,
    where_clause: Option<Expr>,
    limit: Option<usize>,
}

impl QueryBuilder {
    pub fn new() -> Self {
        Self {
            select: Vec::new(),
            from: None,
            where_clause: None,
            limit: None,
        }
    }

    pub fn select(mut self, expr: Expr) -> Self {
        self.select.push(expr);
        self
    }

    pub fn select_col(self, name: &str) -> Self {
        self.select(Expr::Column(name.to_string()))
    }

    pub fn from(mut self, table: &str) -> Self {
        self.from = Some(table.to_string());
        self
    }

    pub fn where_clause(mut self, expr: Expr) -> Self {
        self.where_clause = Some(expr);
        self
    }

    pub fn limit(mut self, n: usize) -> Self {
        self.limit = Some(n);
        self
    }

    pub fn build(self) -> Result<Query, BuildError> {
        if self.select.is_empty() {
            return Err(BuildError::MissingSelect);
        }
        if self.from.is_none() {
            return Err(BuildError::MissingFrom);
        }

        Ok(Query {
            select: self.select,
            from: self.from.unwrap(),
            where_clause: self.where_clause,
            limit: self.limit,
        })
    }
}

impl Default for QueryBuilder {
    fn default() -> Self {
        Self::new()
    }
}

// ============= Query (Final DSL Result) =============
#[derive(Debug, Clone)]
pub struct Query {
    select: Vec<Expr>,
    from: String,
    where_clause: Option<Expr>,
    limit: Option<usize>,
}

impl Query {
    pub fn to_sql(&self) -> String {
        let mut sql = String::from("SELECT ");
        sql.push_str(
            &self
                .select
                .iter()
                .map(|e| expr_to_sql(e))
                .collect::<Vec<_>>()
                .join(", "),
        );
        sql.push_str(&format!(" FROM {}", self.from));

        if let Some(ref where_expr) = self.where_clause {
            sql.push_str(&format!(" WHERE {}", expr_to_sql(where_expr)));
        }

        if let Some(limit) = self.limit {
            sql.push_str(&format!(" LIMIT {}", limit));
        }

        sql
    }
}

fn expr_to_sql(expr: &Expr) -> String {
    match expr {
        Expr::Column(name) => name.clone(),
        Expr::Literal(val) => value_to_sql(val),
        Expr::BinOp(left, op, right) => {
            format!("({} {} {})", expr_to_sql(left), binop_to_sql(*op), expr_to_sql(right))
        }
        Expr::Function(name, args) => {
            let args_sql = args
                .iter()
                .map(expr_to_sql)
                .collect::<Vec<_>>()
                .join(", ");
            format!("{}({})", name, args_sql)
        }
    }
}

fn value_to_sql(val: &Value) -> String {
    match val {
        Value::String(s) => format!("'{}'", s.replace('\'', "''")),
        Value::Integer(i) => i.to_string(),
        Value::Float(f) => f.to_string(),
        Value::Boolean(b) => b.to_string(),
        Value::Null => "NULL".to_string(),
    }
}

fn binop_to_sql(op: BinOp) -> &'static str {
    match op {
        BinOp::Eq => "=",
        BinOp::Gt => ">",
        BinOp::Lt => "<",
        BinOp::And => "AND",
        BinOp::Or => "OR",
        BinOp::Add => "+",
        BinOp::Sub => "-",
    }
}

// ============= Error Handling =============
#[derive(Debug)]
pub enum BuildError {
    MissingSelect,
    MissingFrom,
}

impl fmt::Display for BuildError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::MissingSelect => write!(f, "SELECT clause is required"),
            Self::MissingFrom => write!(f, "FROM clause is required"),
        }
    }
}

impl std::error::Error for BuildError {}

// ============= Helper Functions for DSL =============
pub fn col(name: &str) -> Expr {
    Expr::Column(name.to_string())
}

pub fn lit_str(s: &str) -> Expr {
    Expr::Literal(Value::String(s.to_string()))
}

pub fn lit_int(i: i64) -> Expr {
    Expr::Literal(Value::Integer(i))
}

pub fn eq(left: Expr, right: Expr) -> Expr {
    Expr::BinOp(Box::new(left), BinOp::Eq, Box::new(right))
}

pub fn and(left: Expr, right: Expr) -> Expr {
    Expr::BinOp(Box::new(left), BinOp::And, Box::new(right))
}

pub fn count(expr: Expr) -> Expr {
    Expr::Function("COUNT".to_string(), vec![expr])
}

// ============= Example Usage =============
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Using fluent builder API
    let query = QueryBuilder::new()
        .select_col("id")
        .select_col("name")
        .from("users")
        .where_clause(eq(col("age"), lit_int(25)))
        .limit(10)
        .build()?;

    println!("Query 1:\n{}\n", query.to_sql());

    // More complex query with functions and conditions
    let query2 = QueryBuilder::new()
        .select(col("id"))
        .select(count(col("*")))
        .from("orders")
        .where_clause(and(
            eq(col("status"), lit_str("completed")),
            eq(col("year"), lit_int(2024)),
        ))
        .limit(100)
        .build()?;

    println!("Query 2:\n{}\n", query2.to_sql());

    // Error handling
    let result = QueryBuilder::new().from("users").build();
    match result {
        Err(e) => println!("Build error: {}", e),
        _ => {}
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_query() {
        let query = QueryBuilder::new()
            .select_col("id")
            .from("users")
            .build()
            .unwrap();

        assert_eq!(query.to_sql(), "SELECT id FROM users");
    }

    #[test]
    fn test_query_with_where() {
        let query = QueryBuilder::new()
            .select_col("name")
            .from("users")
            .where_clause(eq(col("age"), lit_int(30)))
            .build()
            .unwrap();

        let sql = query.to_sql();
        assert!(sql.contains("WHERE"));
        assert!(sql.contains("age"));
    }

    #[test]
    fn test_missing_select() {
        let result = QueryBuilder::new().from("users").build();
        assert!(result.is_err());
    }
}
```

I've created a comprehensive example of a best-practice custom DSL in Rust. Here are the key patterns demonstrated:

**Core Components:**

1. **AST (Abstract Syntax Tree)** - Defines your DSL's data model with enums for expressions, values, and operations. This is the foundation of any DSL.

2. **Fluent Builder API** - Uses method chaining for an ergonomic, readable interface. Each method returns `self` to enable chaining.

3. **Strong Type Safety** - Leverages Rust's type system to prevent invalid states (you can't build a query without SELECT/FROM).

4. **Error Handling** - Proper error types implementing the `Error` trait, with validation at build time.

5. **Code Generation** - The `to_sql()` method demonstrates converting your DSL into output (here, SQL).

6. **Helper Functions** - Convenience functions like `col()`, `lit_int()`, `eq()` reduce boilerplate and improve readability.

7. **Testing** - Includes unit tests to verify DSL behavior.

**Key Best Practices:**

- Keep the AST simple and composable
- Use builders for construction with validation
- Leverage Rust's type system for compile-time guarantees
- Provide helper functions to make the DSL ergonomic
- Include comprehensive error handling
- Write tests alongside the DSL
- Document with examples

You could extend this further with proc macros for even more ergonomic syntax, or add a proper parser if you need text-based input. Would you like me to show you how to add any of these features?

```rs
// Rust DSL with Parser and Effects
// This demonstrates: lexer, parser, and side effects execution

use std::fmt;
use std::collections::HashMap;

// ============= Lexer (Tokenization) =============
#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Select,
    From,
    Where,
    And,
    Or,
    Limit,
    Eq,
    Gt,
    Lt,
    Ident(String),
    Number(i64),
    String(String),
    Comma,
    LeftParen,
    RightParen,
    Star,
    Eof,
}

pub struct Lexer {
    input: Vec<char>,
    pos: usize,
}

impl Lexer {
    pub fn new(input: &str) -> Self {
        Self {
            input: input.chars().collect(),
            pos: 0,
        }
    }

    fn current(&self) -> Option<char> {
        if self.pos < self.input.len() {
            Some(self.input[self.pos])
        } else {
            None
        }
    }

    fn peek(&self, offset: usize) -> Option<char> {
        if self.pos + offset < self.input.len() {
            Some(self.input[self.pos + offset])
        } else {
            None
        }
    }

    fn advance(&mut self) {
        self.pos += 1;
    }

    fn skip_whitespace(&mut self) {
        while let Some(ch) = self.current() {
            if ch.is_whitespace() {
                self.advance();
            } else {
                break;
            }
        }
    }

    fn read_ident(&mut self) -> String {
        let mut ident = String::new();
        while let Some(ch) = self.current() {
            if ch.is_alphanumeric() || ch == '_' {
                ident.push(ch);
                self.advance();
            } else {
                break;
            }
        }
        ident
    }

    fn read_number(&mut self) -> i64 {
        let mut num = String::new();
        while let Some(ch) = self.current() {
            if ch.is_numeric() {
                num.push(ch);
                self.advance();
            } else {
                break;
            }
        }
        num.parse().unwrap_or(0)
    }

    fn read_string(&mut self, quote: char) -> String {
        let mut s = String::new();
        self.advance(); // skip opening quote
        while let Some(ch) = self.current() {
            if ch == quote {
                self.advance();
                break;
            }
            s.push(ch);
            self.advance();
        }
        s
    }

    pub fn next_token(&mut self) -> Token {
        self.skip_whitespace();

        match self.current() {
            None => Token::Eof,
            Some('*') => {
                self.advance();
                Token::Star
            }
            Some(',') => {
                self.advance();
                Token::Comma
            }
            Some('(') => {
                self.advance();
                Token::LeftParen
            }
            Some(')') => {
                self.advance();
                Token::RightParen
            }
            Some('=') => {
                self.advance();
                Token::Eq
            }
            Some('>') => {
                self.advance();
                Token::Gt
            }
            Some('<') => {
                self.advance();
                Token::Lt
            }
            Some('"') => Token::String(self.read_string('"')),
            Some('\'') => Token::String(self.read_string('\'')),
            Some(ch) if ch.is_numeric() => Token::Number(self.read_number()),
            Some(ch) if ch.is_alphabetic() => {
                let ident = self.read_ident();
                match ident.to_uppercase().as_str() {
                    "SELECT" => Token::Select,
                    "FROM" => Token::From,
                    "WHERE" => Token::Where,
                    "AND" => Token::And,
                    "OR" => Token::Or,
                    "LIMIT" => Token::Limit,
                    _ => Token::Ident(ident),
                }
            }
            Some(_ch) => {
                self.advance();
                self.next_token() // skip unknown chars
            }
        }
    }

    pub fn tokenize(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();
        loop {
            let token = self.next_token();
            let is_eof = token == Token::Eof;
            tokens.push(token);
            if is_eof {
                break;
            }
        }
        tokens
    }
}

// ============= AST =============
#[derive(Debug, Clone)]
pub enum Expr {
    Column(String),
    Literal(Value),
    BinOp(Box<Expr>, BinOp, Box<Expr>),
}

#[derive(Debug, Clone)]
pub enum Value {
    String(String),
    Integer(i64),
}

#[derive(Debug, Clone, Copy)]
pub enum BinOp {
    Eq,
    Gt,
    Lt,
    And,
    Or,
}

#[derive(Debug, Clone)]
pub struct Query {
    pub select: Vec<Expr>,
    pub from: String,
    pub where_clause: Option<Expr>,
    pub limit: Option<usize>,
}

// ============= Parser =============
pub struct Parser {
    tokens: Vec<Token>,
    pos: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn current(&self) -> &Token {
        self.tokens.get(self.pos).unwrap_or(&Token::Eof)
    }

    fn advance(&mut self) {
        self.pos += 1;
    }

    fn expect(&mut self, expected: Token) -> Result<(), ParseError> {
        if std::mem::discriminant(self.current()) == std::mem::discriminant(&expected) {
            self.advance();
            Ok(())
        } else {
            Err(ParseError::UnexpectedToken(
                format!("{:?}", self.current()),
                format!("{:?}", expected),
            ))
        }
    }

    pub fn parse(&mut self) -> Result<Query, ParseError> {
        self.expect(Token::Select)?;

        let mut select = Vec::new();
        loop {
            if let Token::Star = self.current() {
                self.advance();
                select.push(Expr::Column("*".to_string()));
            } else if let Token::Ident(name) = self.current() {
                select.push(Expr::Column(name.clone()));
                self.advance();
            } else {
                return Err(ParseError::InvalidSelectExpr);
            }

            if let Token::Comma = self.current() {
                self.advance();
            } else {
                break;
            }
        }

        self.expect(Token::From)?;

        let from = if let Token::Ident(name) = self.current() {
            let table = name.clone();
            self.advance();
            table
        } else {
            return Err(ParseError::InvalidFromClause);
        };

        let where_clause = if let Token::Where = self.current() {
            self.advance();
            Some(self.parse_expr()?)
        } else {
            None
        };

        let limit = if let Token::Limit = self.current() {
            self.advance();
            if let Token::Number(n) = self.current() {
                let l = *n as usize;
                self.advance();
                Some(l)
            } else {
                return Err(ParseError::InvalidLimitValue);
            }
        } else {
            None
        };

        Ok(Query {
            select,
            from,
            where_clause,
            limit,
        })
    }

    fn parse_expr(&mut self) -> Result<Expr, ParseError> {
        let mut left = self.parse_primary()?;

        loop {
            let op = match self.current() {
                Token::Eq => BinOp::Eq,
                Token::Gt => BinOp::Gt,
                Token::Lt => BinOp::Lt,
                Token::And => BinOp::And,
                Token::Or => BinOp::Or,
                _ => break,
            };
            self.advance();
            let right = self.parse_primary()?;
            left = Expr::BinOp(Box::new(left), op, Box::new(right));
        }

        Ok(left)
    }

    fn parse_primary(&mut self) -> Result<Expr, ParseError> {
        match self.current() {
            Token::Ident(name) => {
                let col = name.clone();
                self.advance();
                Ok(Expr::Column(col))
            }
            Token::Number(n) => {
                let val = *n;
                self.advance();
                Ok(Expr::Literal(Value::Integer(val)))
            }
            Token::String(s) => {
                let val = s.clone();
                self.advance();
                Ok(Expr::Literal(Value::String(val)))
            }
            _ => Err(ParseError::InvalidExpression),
        }
    }
}

#[derive(Debug)]
pub enum ParseError {
    UnexpectedToken(String, String),
    InvalidSelectExpr,
    InvalidFromClause,
    InvalidLimitValue,
    InvalidExpression,
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::UnexpectedToken(got, expected) => {
                write!(f, "Expected {}, got {}", expected, got)
            }
            Self::InvalidSelectExpr => write!(f, "Invalid SELECT expression"),
            Self::InvalidFromClause => write!(f, "Invalid FROM clause"),
            Self::InvalidLimitValue => write!(f, "Invalid LIMIT value"),
            Self::InvalidExpression => write!(f, "Invalid expression"),
        }
    }
}

impl std::error::Error for ParseError {}

// ============= Effects & Execution =============
pub trait Effect {
    fn execute(&self) -> Result<String, String>;
}

pub struct PrintEffect {
    pub query: Query,
}

impl Effect for PrintEffect {
    fn execute(&self) -> Result<String, String> {
        let sql = format_query(&self.query);
        println!("{}", sql);
        Ok(sql)
    }
}

pub struct CountColumnsEffect {
    pub query: Query,
}

impl Effect for CountColumnsEffect {
    fn execute(&self) -> Result<String, String> {
        let count = self.query.select.len();
        let msg = format!("Query selects {} columns", count);
        println!("{}", msg);
        Ok(msg)
    }
}

pub struct ValidateEffect {
    pub query: Query,
}

impl Effect for ValidateEffect {
    fn execute(&self) -> Result<String, String> {
        if self.query.select.is_empty() {
            return Err("No columns selected".to_string());
        }
        if self.query.from.is_empty() {
            return Err("No table specified".to_string());
        }
        Ok("Query validation passed".to_string())
    }
}

pub struct MockExecuteEffect {
    pub query: Query,
}

impl Effect for MockExecuteEffect {
    fn execute(&self) -> Result<String, String> {
        let msg = format!(
            "Executing: SELECT {} FROM {}",
            self.query
                .select
                .iter()
                .map(|e| format!("{:?}", e))
                .collect::<Vec<_>>()
                .join(", "),
            self.query.from
        );
        println!("{}", msg);
        
        // Simulate returning mock data
        Ok(format!("Returned 5 rows from {}", self.query.from))
    }
}

pub struct StatsEffect {
    pub query: Query,
}

impl Effect for StatsEffect {
    fn execute(&self) -> Result<String, String> {
        let mut stats = HashMap::new();
        stats.insert("columns", self.query.select.len());
        stats.insert("has_where", if self.query.where_clause.is_some() { 1 } else { 0 });
        stats.insert("has_limit", if self.query.limit.is_some() { 1 } else { 0 });
        stats.insert("limit_value", self.query.limit.unwrap_or(0));

        let msg = format!("Query Stats: {:?}", stats);
        println!("{}", msg);
        Ok(msg)
    }
}

// ============= Utilities =============
fn format_query(query: &Query) -> String {
    let mut sql = String::from("SELECT ");
    sql.push_str(
        &query
            .select
            .iter()
            .map(format_expr)
            .collect::<Vec<_>>()
            .join(", "),
    );
    sql.push_str(&format!(" FROM {}", query.from));

    if let Some(ref where_expr) = query.where_clause {
        sql.push_str(&format!(" WHERE {}", format_expr(where_expr)));
    }

    if let Some(limit) = query.limit {
        sql.push_str(&format!(" LIMIT {}", limit));
    }

    sql
}

fn format_expr(expr: &Expr) -> String {
    match expr {
        Expr::Column(name) => name.clone(),
        Expr::Literal(Value::String(s)) => format!("'{}'", s),
        Expr::Literal(Value::Integer(i)) => i.to_string(),
        Expr::BinOp(left, op, right) => {
            format!("({} {} {})", format_expr(left), format_binop(*op), format_expr(right))
        }
    }
}

fn format_binop(op: BinOp) -> &'static str {
    match op {
        BinOp::Eq => "=",
        BinOp::Gt => ">",
        BinOp::Lt => "<",
        BinOp::And => "AND",
        BinOp::Or => "OR",
    }
}

// ============= Example Usage =============
fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== DSL Parser & Effects Example ===\n");

    // Parse DSL input
    let input = "SELECT id, name FROM users WHERE age > 25 LIMIT 10";
    println!("Input: {}\n", input);

    let mut lexer = Lexer::new(input);
    let tokens = lexer.tokenize();
    println!("Tokens: {:?}\n", tokens);

    let mut parser = Parser::new(tokens);
    let query = parser.parse()?;
    println!("Parsed Query: {:#?}\n", query);

    // Execute various effects
    println!("--- Effects ---\n");

    let effects: Vec<Box<dyn Effect>> = vec![
        Box::new(PrintEffect { query: query.clone() }),
        Box::new(ValidateEffect { query: query.clone() }),
        Box::new(CountColumnsEffect { query: query.clone() }),
        Box::new(StatsEffect { query: query.clone() }),
        Box::new(MockExecuteEffect { query: query.clone() }),
    ];

    for effect in effects {
        match effect.execute() {
            Ok(result) => println!("✓ {}\n", result),
            Err(e) => println!("✗ Error: {}\n", e),
        }
    }

    // Second example
    println!("\n=== Complex Query ===\n");
    let input2 = "SELECT * FROM orders WHERE status = 'completed' AND year > 2023 LIMIT 100";
    println!("Input: {}\n", input2);

    let mut lexer2 = Lexer::new(input2);
    let tokens2 = lexer2.tokenize();
    let mut parser2 = Parser::new(tokens2);
    let query2 = parser2.parse()?;

    let effect = Box::new(PrintEffect { query: query2 }) as Box<dyn Effect>;
    effect.execute()?;

    Ok(())
}
```


Perfect! I've updated the example to include a complete lexer, parser, and effects system. Here's what's new:

**Lexer** - Tokenizes your DSL input string into a sequence of tokens. Handles identifiers, keywords, numbers, strings, and operators.

**Parser** - Converts tokens into an AST (Abstract Syntax Tree). Uses recursive descent parsing with proper error handling. Validates structure as it parses.

**Effects System** - A trait-based design where different effects can run on the parsed query:
- **PrintEffect** - Formats and prints the query as SQL
- **ValidateEffect** - Validates the query structure
- **CountColumnsEffect** - Analyzes how many columns are selected
- **StatsEffect** - Gathers metrics about the query
- **MockExecuteEffect** - Simulates query execution and returns mock data

**How It Works:**

1. Parse a string DSL query like `"SELECT id, name FROM users WHERE age > 25 LIMIT 10"`
2. Lexer converts it into tokens
3. Parser builds an AST from tokens
4. Multiple effects can run on the parsed query, each with different behavior
5. Effects are composable - you can chain or run them in any order

The output shows the full pipeline from input string through parsing to various side effects. You can easily add more effects (logging, caching, optimization, etc.) without modifying the parser.

Want me to add anything else, like error recovery, custom effect chaining, or macro-based syntax?





```rs
// Rust DSL with Macros for Ergonomic Syntax
// This demonstrates: declarative macros for DSL syntax

use std::fmt;
use std::collections::HashMap;

// ============= AST =============
#[derive(Debug, Clone)]
pub enum Expr {
    Column(String),
    Literal(Value),
    BinOp(Box<Expr>, BinOp, Box<Expr>),
    Function(String, Vec<Expr>),
}

#[derive(Debug, Clone)]
pub enum Value {
    String(String),
    Integer(i64),
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum BinOp {
    Eq,
    Gt,
    Lt,
    And,
    Or,
}

#[derive(Debug, Clone)]
pub struct Query {
    pub select: Vec<Expr>,
    pub from: String,
    pub where_clause: Option<Expr>,
    pub limit: Option<usize>,
}

// ============= DSL Macros =============

/// Create a column reference: col!(name)
#[macro_export]
macro_rules! col {
    ($name:expr) => {
        Expr::Column($name.to_string())
    };
}

/// Create a string literal: lit!("value")
#[macro_export]
macro_rules! lit {
    ($val:expr) => {
        {
            let v = $val;
            if let Ok(i) = std::string::String::from(v).parse::<i64>() {
                Expr::Literal(Value::Integer(i))
            } else {
                Expr::Literal(Value::String(v.to_string()))
            }
        }
    };
}

/// Simple equality: eq!(col1, value)
#[macro_export]
macro_rules! eq {
    ($left:expr, $right:expr) => {
        Expr::BinOp(Box::new($left), BinOp::Eq, Box::new($right))
    };
}

/// Greater than: gt!(col, value)
#[macro_export]
macro_rules! gt {
    ($left:expr, $right:expr) => {
        Expr::BinOp(Box::new($left), BinOp::Gt, Box::new($right))
    };
}

/// Less than: lt!(col, value)
#[macro_export]
macro_rules! lt {
    ($left:expr, $right:expr) => {
        Expr::BinOp(Box::new($left), BinOp::Lt, Box::new($right))
    };
}

/// Logical AND: and!(cond1, cond2)
#[macro_export]
macro_rules! and {
    ($left:expr, $right:expr) => {
        Expr::BinOp(Box::new($left), BinOp::And, Box::new($right))
    };
}

/// Logical OR: or!(cond1, cond2)
#[macro_export]
macro_rules! or {
    ($left:expr, $right:expr) => {
        Expr::BinOp(Box::new($left), BinOp::Or, Box::new($right))
    };
}

/// Function call: func!("COUNT", col!("id"))
#[macro_export]
macro_rules! func {
    ($name:expr, $($arg:expr),*) => {
        {
            let mut args = Vec::new();
            $(
                args.push($arg);
            )*
            Expr::Function($name.to_string(), args)
        }
    };
}

/// Build a query: query! { select: [col1, col2], from: "table", where: cond, limit: 10 }
#[macro_export]
macro_rules! query {
    (
        select: [$($col:expr),*],
        from: $table:expr
        $(, where: $cond:expr)?
        $(, limit: $lim:expr)?
    ) => {
        {
            let mut cols = Vec::new();
            $(
                cols.push($col);
            )*
            Query {
                select: cols,
                from: $table.to_string(),
                where_clause: None$(.or(Some($cond)))?,
                limit: None$(.or(Some($lim)))?,
            }
        }
    };
}

/// Builder-style query macro with method chaining
#[macro_export]
macro_rules! build_query {
    () => {
        QueryBuilder::new()
    };
}

// ============= Query Builder =============
pub struct QueryBuilder {
    select: Vec<Expr>,
    from: Option<String>,
    where_clause: Option<Expr>,
    limit: Option<usize>,
}

impl QueryBuilder {
    pub fn new() -> Self {
        Self {
            select: Vec::new(),
            from: None,
            where_clause: None,
            limit: None,
        }
    }

    pub fn select(mut self, expr: Expr) -> Self {
        self.select.push(expr);
        self
    }

    pub fn select_cols(mut self, exprs: Vec<Expr>) -> Self {
        self.select.extend(exprs);
        self
    }

    pub fn from(mut self, table: &str) -> Self {
        self.from = Some(table.to_string());
        self
    }

    pub fn where_clause(mut self, expr: Expr) -> Self {
        self.where_clause = Some(expr);
        self
    }

    pub fn limit(mut self, n: usize) -> Self {
        self.limit = Some(n);
        self
    }

    pub fn build(self) -> Result<Query, String> {
        if self.select.is_empty() {
            return Err("Missing SELECT columns".to_string());
        }
        if self.from.is_none() {
            return Err("Missing FROM table".to_string());
        }

        Ok(Query {
            select: self.select,
            from: self.from.unwrap(),
            where_clause: self.where_clause,
            limit: self.limit,
        })
    }
}

impl Default for QueryBuilder {
    fn default() -> Self {
        Self::new()
    }
}

// ============= Effects & Execution =============
pub trait Effect {
    fn execute(&self) -> Result<String, String>;
}

pub struct PrintEffect {
    pub query: Query,
}

impl Effect for PrintEffect {
    fn execute(&self) -> Result<String, String> {
        let sql = format_query(&self.query);
        println!("{}", sql);
        Ok(sql)
    }
}

pub struct ValidateEffect {
    pub query: Query,
}

impl Effect for ValidateEffect {
    fn execute(&self) -> Result<String, String> {
        if self.query.select.is_empty() {
            return Err("No columns selected".to_string());
        }
        if self.query.from.is_empty() {
            return Err("No table specified".to_string());
        }
        Ok("✓ Query validation passed".to_string())
    }
}

pub struct CountColumnsEffect {
    pub query: Query,
}

impl Effect for CountColumnsEffect {
    fn execute(&self) -> Result<String, String> {
        let count = self.query.select.len();
        Ok(format!("✓ Query selects {} columns", count))
    }
}

pub struct StatsEffect {
    pub query: Query,
}

impl Effect for StatsEffect {
    fn execute(&self) -> Result<String, String> {
        let mut stats = HashMap::new();
        stats.insert("columns", self.query.select.len());
        stats.insert("has_where", if self.query.where_clause.is_some() { 1 } else { 0 });
        stats.insert("has_limit", if self.query.limit.is_some() { 1 } else { 0 });

        let msg = format!("✓ Query Stats: {:?}", stats);
        Ok(msg)
    }
}

pub struct MockExecuteEffect {
    pub query: Query,
}

impl Effect for MockExecuteEffect {
    fn execute(&self) -> Result<String, String> {
        let msg = format!("✓ Executing query on {}", self.query.from);
        Ok(msg)
    }
}

// ============= Utilities =============
fn format_query(query: &Query) -> String {
    let mut sql = String::from("SELECT ");
    sql.push_str(
        &query
            .select
            .iter()
            .map(format_expr)
            .collect::<Vec<_>>()
            .join(", "),
    );
    sql.push_str(&format!(" FROM {}", query.from));

    if let Some(ref where_expr) = query.where_clause {
        sql.push_str(&format!(" WHERE {}", format_expr(where_expr)));
    }

    if let Some(limit) = query.limit {
        sql.push_str(&format!(" LIMIT {}", limit));
    }

    sql
}

fn format_expr(expr: &Expr) -> String {
    match expr {
        Expr::Column(name) => name.clone(),
        Expr::Literal(Value::String(s)) => format!("'{}'", s),
        Expr::Literal(Value::Integer(i)) => i.to_string(),
        Expr::BinOp(left, op, right) => {
            format!("({} {} {})", format_expr(left), format_binop(*op), format_expr(right))
        }
        Expr::Function(name, args) => {
            let args_str = args
                .iter()
                .map(format_expr)
                .collect::<Vec<_>>()
                .join(", ");
            format!("{}({})", name, args_str)
        }
    }
}

fn format_binop(op: BinOp) -> &'static str {
    match op {
        BinOp::Eq => "=",
        BinOp::Gt => ">",
        BinOp::Lt => "<",
        BinOp::And => "AND",
        BinOp::Or => "OR",
    }
}

// ============= Example Usage =============
fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Macro-Based DSL Syntax ===\n");

    // Example 1: Simple query with macros
    println!("--- Example 1: Basic Macro Syntax ---");
    let q1 = query! {
        select: [col!("id"), col!("name")],
        from: "users",
        where: eq!(col!("age"), lit!("25")),
        limit: 10
    };

    println!("Query: {}\n", format_query(&q1));
    PrintEffect { query: q1.clone() }.execute()?;
    ValidateEffect { query: q1 }.execute()?;

    // Example 2: Complex conditions with macros
    println!("\n--- Example 2: Complex Conditions ---");
    let q2 = query! {
        select: [col!("id"), col!("product"), col!("amount")],
        from: "orders",
        where: and!(
            eq!(col!("status"), lit!("completed")),
            gt!(col!("amount"), lit!("100"))
        ),
        limit: 50
    };

    println!("Query: {}\n", format_query(&q2));
    PrintEffect { query: q2.clone() }.execute()?;
    CountColumnsEffect { query: q2 }.execute()?;

    // Example 3: Using functions with macros
    println!("\n--- Example 3: With Functions ---");
    let q3 = query! {
        select: [func!("COUNT", col!("id")), col!("category")],
        from: "products",
        where: gt!(col!("price"), lit!("50")),
        limit: 100
    };

    println!("Query: {}\n", format_query(&q3));
    PrintEffect { query: q3.clone() }.execute()?;
    StatsEffect { query: q3 }.execute()?;

    // Example 4: Builder pattern with macros
    println!("\n--- Example 4: Builder Pattern ---");
    let q4 = QueryBuilder::new()
        .select_cols(vec![col!("username"), col!("email")])
        .from("users")
        .where_clause(or!(
            eq!(col!("role"), lit!("admin")),
            eq!(col!("role"), lit!("moderator"))
        ))
        .limit(20)
        .build()?;

    println!("Query: {}\n", format_query(&q4));
    PrintEffect { query: q4.clone() }.execute()?;
    ValidateEffect { query: q4 }.execute()?;

    // Example 5: Multiple conditions
    println!("\n--- Example 5: Chained Conditions ---");
    let q5 = query! {
        select: [col!("*")],
        from: "orders",
        where: and!(
            and!(
                gt!(col!("year"), lit!("2023")),
                lt!(col!("year"), lit!("2026"))
            ),
            eq!(col!("status"), lit!("active"))
        ),
        limit: 1000
    };

    println!("Query: {}\n", format_query(&q5));
    PrintEffect { query: q5.clone() }.execute()?;
    MockExecuteEffect { query: q5 }.execute()?;

    // Example 6: Execute multiple effects
    println!("\n--- Example 6: Chain Effects ---");
    let q6 = query! {
        select: [col!("id"), col!("name"), col!("email")],
        from: "customers"
    };

    let effects: Vec<Box<dyn Effect>> = vec![
        Box::new(PrintEffect { query: q6.clone() }),
        Box::new(ValidateEffect { query: q6.clone() }),
        Box::new(CountColumnsEffect { query: q6.clone() }),
        Box::new(StatsEffect { query: q6 }),
    ];

    for effect in effects {
        println!("{}", effect.execute()?);
    }

    println!("\n=== All Examples Completed ===");
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_col_macro() {
        let c = col!("name");
        match c {
            Expr::Column(name) => assert_eq!(name, "name"),
            _ => panic!("Expected Column"),
        }
    }

    #[test]
    fn test_eq_macro() {
        let expr = eq!(col!("age"), lit!("25"));
        match expr {
            Expr::BinOp(_, op, _) => assert_eq!(op, BinOp::Eq),
            _ => panic!("Expected BinOp"),
        }
    }

    #[test]
    fn test_query_macro() {
        let q = query! {
            select: [col!("id")],
            from: "users"
        };
        assert_eq!(q.select.len(), 1);
        assert_eq!(q.from, "users");
    }

    #[test]
    fn test_and_macro() {
        let expr = and!(
            eq!(col!("a"), lit!("1")),
            eq!(col!("b"), lit!("2"))
        );
        match expr {
            Expr::BinOp(_, op, _) => assert_eq!(op, BinOp::And),
            _ => panic!("Expected BinOp"),
        }
    }
}
```

Perfect! I've added comprehensive macro-based syntax to make the DSL much more ergonomic. Here's what's new:

**Macro Suite:**

- `col!("name")` - Creates column references
- `lit!(value)` - Creates string/integer literals
- `eq!`, `gt!`, `lt!`, `and!`, `or!` - Comparison and logical operators
- `func!("COUNT", ...)` - Function calls with variable arguments
- `query! { select: [...], from: "...", where: ..., limit: ... }` - Full query construction

**Key Features:**

1. **Declarative Syntax** - The `query!` macro lets you write queries in a declarative style that's much more readable than nested function calls.

2. **Composable Conditions** - Build complex WHERE clauses by nesting macros: `and!(eq!(...), gt!(...))`

3. **Type-Safe** - Still gets all the benefits of Rust's type system and compile-time checking.

4. **Optional Clauses** - The `query!` macro supports optional `where` and `limit` using Rust's optional pattern syntax.

5. **Tests Included** - Unit tests demonstrate macro usage and correctness.

**Examples show:**
- Basic queries with simple conditions
- Complex nested conditions using AND/OR
- Function aggregations (COUNT, etc.)
- Builder pattern still works alongside macros
- Chaining multiple effects

The macros make the DSL feel much more like writing actual SQL while maintaining Rust's safety guarantees!
