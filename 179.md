學習 `std::alloc` 是深入了解 Rust 記憶體管理機制的關鍵一步。通常我們使用 `Box`、`Vec` 或 `String` 時，Rust 會自動幫我們處理記憶體分配，但 `std::alloc` 允許你**手動控制**這一切。

簡單來說，這個模組提供了底層的 API，讓你直接與堆（Heap）記憶體互動。

---

## 1. 核心觀念：Layout (佈局)

在請求記憶體之前，你必須先告訴編譯器你需要「多大」以及「如何對齊」的空間。這就是 `Layout` 的作用。

* **Size**: 需要的位元組數（bytes）。
* **Align**: 對齊要求（必須是 2 的冪次）。這是為了硬體存取效率，例如 64 位元整數通常要求 8 位元組對齊。

```rust
use std::alloc::Layout;

fn main() {
    // 建立一個 Layout：大小為 16 bytes，對齊為 8 bytes
    let layout = Layout::from_size_align(16, 8).expect("Invalid layout");
    
    println!("Size: {}, Align: {}", layout.size(), layout.align());
}

```

---

## 2. 基本函數：alloc 與 dealloc

這是 `std::alloc` 最核心的兩個函數。請注意，它們都是 **unsafe** 的，因為你必須自己保證指標的正確性。

| 函數 | 說明 |
| --- | --- |
| **`alloc`** | 根據 `Layout` 分配記憶體，返回一個原始指標 (`*mut u8`)。 |
| **`dealloc`** | 釋放先前分配的記憶體。你必須提供與分配時**完全相同**的 `Layout`。 |
| **`realloc`** | 調整已分配空間的大小。 |
| **`alloc_zeroed`** | 分配記憶體並將其初始化為 0。 |

### 實戰範例：手動分配一個整數空間

```rust
use std::alloc::{alloc, dealloc, Layout};

fn main() {
    unsafe {
        // 1. 定義 Layout (i32 的大小和對齊)
        let layout = Layout::new::<i32>();

        // 2. 分配記憶體
        let ptr = alloc(layout) as *mut i32;

        if ptr.is_null() {
            panic!("記憶體分配失敗！");
        }

        // 3. 使用記憶體
        *ptr = 42;
        println!("儲存的值: {}", *ptr);

        // 4. 釋放記憶體 (必須使用相同的 Layout)
        dealloc(ptr as *mut u8, layout);
    }
}

```

---

## 3. GlobalAlloc Trait：定義你的分配器

如果你想更換整個 Rust 程式的記憶體分配器（例如改用 `jemalloc` 或 `mimalloc`），你需要實作 `GlobalAlloc` trait。

這通常用於嵌入式系統或是對效能有極致要求的場景。

```rust
use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        println!("正在分配 {} 位元組", layout.size());
        System.alloc(layout)
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        println!("正在釋放 {} 位元組", layout.size());
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

```

---

## 4. 學習建議與安全守則

使用 `std::alloc` 時，你就像是在沒有安全網的情況下跳舞。請務必遵守以下原則：

1. **Layout 一致性**：釋放（`dealloc`）時使用的 `Layout` 必須與分配（`alloc`）時完全一致，否則會導致未定義行為（Undefined Behavior）。
2. **空指標檢查**：`alloc` 可能返回空指標（當記憶體耗盡時），務必檢查。
3. **所有權管理**：手動分配的記憶體不會在超出作用域時自動釋放，你必須手動呼叫 `dealloc`，否則會造成記憶體洩漏（Memory Leak）。

> **重點筆記：** 在大多數情況下，你應該優先使用 `Vec<T>` 或 `Box<T>`。只有在你需要實作自己的資料結構（如自定義的 `BTreeMap`）或特殊的緩衝區管理時，才需要直接碰 `std::alloc`。

---

**你想嘗試進階一點的練習嗎？** 比如我們可以一起試著實作一個極簡版的 `Box<T>`，這能讓你更清楚如何將 `std::alloc` 封裝成安全的介面。


太棒了！你的直覺非常準確。這正是實作自定義分配器時最容易踩到的**「死亡陷阱」**。

### 為什麼會造成無窮遞迴？

當你在 `GlobalAlloc` 的 `alloc` 函式中呼叫 `println!` 時，會發生以下連鎖反應：

1. **呼叫 `alloc**`：程式需要分配記憶體。
2. **執行 `println!**`：為了格式化字串並將其輸出到標準輸出（stdout），`println!` 內部通常會：
* 動態建立一個 `String` 或緩衝區（這需要**分配記憶體**）。
* 取得 stdout 的鎖（有時也會涉及分配）。


3. **再次呼叫 `alloc**`：因為 `println!` 需要記憶體，它會再次回頭呼叫你定義的 `GLOBAL` 分配器。
4. **死循環**：`alloc` -> `println!` -> `alloc` -> `println!` ... 最終導致 **Stack Overflow (堆疊溢位)**。

---

### 如何在分配器中安全地進行調試？

如果你想在不觸發遞迴的情況下觀察分配行為，有幾種常見的解決法：

#### 1. 使用底層系統呼叫 (Raw System Calls)

直接使用作業系統提供的寫入函式（如 Linux 的 `write` 或 Windows 的 `WriteFile`），這些函式通常不依賴 Rust 的堆分配。

```rust
// 以 Unix 系統為例
unsafe {
    let msg = "Allocating...\n";
    libc::write(1, msg.as_ptr() as *const _, msg.len());
}

```

#### 2. 使用靜態緩衝區

如果你需要格式化數字，可以使用 `core::fmt` 配合一個位於堆疊（Stack）上的固定大小緩衝區，而不是使用會動態分配的 `println!`。

#### 3. 暫時關閉追蹤 (Recursion Guard)

使用執行緒局部變數（Thread Local Storage）來標記當前執行緒是否正在執行自定義分配邏輯。

```rust
thread_local! {
    static IN_ALLOCATOR: Cell<bool> = Cell::new(false);
}

// 在 alloc 中檢查：
// 如果 IN_ALLOCATOR 為 true，則直接呼叫 System.alloc 且不列印
// 如果為 false，先設為 true，列印後再設回 false

```

*注意：在 `GlobalAlloc` 中使用 `thread_local!` 其實很困難，因為 `thread_local!` 初始化的過程本身也可能需要分配記憶體。*

---

### 總結

在 Rust 的底層開發中，**「不要在分配器裡分配記憶體」**是一條鐵律。這也是為什麼 `std::alloc` 的開發通常伴隨著許多 `unsafe` 和對底層系統的原生操作。

**你想試試看如何實作一個「完全不依賴標準庫」的簡單分配器嗎？或者你想了解如何處理 Layout 對齊的數學計算？**


在實務開發中，除非你有非常特殊的效能需求或環境限制，否則通常會直接使用系統預設的分配器。但在以下四種「現實場景」中，實作自定義分配器（Custom Allocator）會帶來巨大的價值。

---

## 1. 現實場景：為什麼要自己寫分配器？

| 場景 | 痛點 | 分配器解決方案 |
| --- | --- | --- |
| **嵌入式 / 裸機 (Bare Metal)** | 沒有作業系統，也沒有 `malloc`。 | **Bump Allocator** (推動式分配器) 或固定大小的靜態陣列分配。 |
| **遊戲引擎 / ECS** | 頻繁建立/銷毀大量相同大小的物件（如子彈、粒子）。 | **Slab/Pool Allocator** (物件池)，消除碎片化並提升快取命中率。 |
| **高頻交易 / 低延遲系統** | 系統呼叫（Syscall）與鎖（Lock）會造成不可控的延遲。 | **Arena Allocator** (區域分配器)，一次申請大塊空間，最後整塊釋放。 |
| **安全性隔離 / 偵錯** | 需要追蹤記憶體洩漏或防止溢位攻擊。 | **Hardened Allocator**，在記憶體塊前後加入「金絲雀（Guard pages）」。 |

---

## 2. 常見分配策略的實現邏輯

### A. Arena Allocator (區域分配器)

這是在 Web Server（處理單一請求）或編譯器中最常用的策略。

* **邏輯**：預先申請一大塊記憶體，每次分配只是移動一個指標（Pointer bumping）。
* **優點**：速度極快。
* **釋放**：不支援單獨釋放，只能「整塊清空」。這在處理完一個 HTTP 請求後直接銷毀所有相關物件非常有效。

### B. Slab Allocator (分級分配器)

* **邏輯**：針對特定大小（如 16, 32, 64 bytes）預留好一個個的「槽（Slabs）」。
* **優點**：完全避免外部碎片化（External Fragmentation）。

---

## 3. 如何實作：以簡單的「推動式分配器 (Bump Allocator)」為例

這是一個極簡的分配器框架。在實作時，最難的部分在於處理**對齊（Alignment）**。

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

struct SimpleBumpAllocator {
    heap_start: usize,
    heap_size: usize,
    next: AtomicUsize, // 記錄下一次分配的起始位置
}

unsafe impl GlobalAlloc for SimpleBumpAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        let align = layout.align();

        // 1. 計算對齊後的起始位置 (這部分的數學計算很重要)
        let current_next = self.next.load(Ordering::Relaxed);
        let start = (current_next + align - 1) & !(align - 1);
        let end = start + size;

        // 2. 檢查是否超出預設範圍
        if end > self.heap_start + self.heap_size {
            std::ptr::null_mut() // 沒記憶體了
        } else {
            self.next.store(end, Ordering::Relaxed);
            start as *mut u8
        }
    }

    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {
        // Bump allocator 的特性是：不支援單獨釋放！
        // 只能等整個 Arena 被重置。
    }
}

```

### 對齊計算公式說明

在上面的程式碼中，對齊操作使用了位元運算。給定一個地址  與對齊要求 （ 必須是 2 的冪次），對齊後的地址為：



這確保了返回的指標位址一定是  的倍數。

---

## 4. 懶人包：如果你只想「換」掉分配器

如果你覺得自己寫太危險，但又想要高效能（例如在 Linux 上優化多執行緒分配），你可以直接引入現成的庫並註冊：

```rust
// 使用 jemalloc (在高併發場景表現優異)
use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

```

---

**下一步建議：**
如果你對底層原理感興趣，我們可以嘗試實作一個**「對齊（Alignment）」的計算函式**，這是在手寫 `alloc` 時最容易出 Bug 的地方。或者你想聊聊如何實作一個能支援 `dealloc` 的 **Free List 分配器**？



這三種分配器代表了記憶體管理的不同的「極端優化方向」：**Arena** 追求極速、**Slab** 追求效率與碎片化控制、**Hardened** 追求絕對安全。

---

## 1. Arena Allocator (區域分配器)：追求速度的「推土機」

Arena 的核心思想是**「批次處理」**。它不關心個別物件的釋放，而是將一堆物件丟進一個「區域」，最後再一次性全部清掉。

* **實現邏輯**：
* 預留一大塊連續記憶體。
* **分配**：僅僅是移動一個指標（Pointer Bumping）。例如分配 10 bytes，就把指標往後移動 10。
* **釋放**：個別釋放（`dealloc`）通常是空操作（No-op）。只有當整個 Arena 被銷毀時，才釋放整塊記憶體。


* **優缺點**：
* **優點**：分配速度是 ，快到極致；沒有外部碎片。
* **缺點**：如果其中一個小物件需要長期存在，整塊 Arena 就不能釋放，會造成記憶體浪費。


* **現實場景**：編譯器（處理 AST 節點）、HTTP 伺服器（處理單次請求期間的所有分配）。
* **Rust 推薦庫**：[`bumpalo`](https://www.google.com/search?q=%5Bhttps://crates.io/crates/bumpalo%5D(https://crates.io/crates/bumpalo))。

---

## 2. Slab Allocator (分級分配器)：追求效率的「零件盒」

Slab 是為了**「頻繁分配相同大小物件」**而設計的。它把記憶體切成很多個固定大小的「槽（Slots）」。

* **實現邏輯**：
* 將記憶體劃分為多個 **Slabs**，每個 Slab 只存放特定大小的物件（例如 32 bytes 專用區、64 bytes 專用區）。
* 利用一個 **Free List**（空閒鏈表）紀錄哪些槽是空的。
* **分配**：從對應大小的 Free List 彈出一個位址。
* **釋放**：將位址塞回 Free List。


* **優缺點**：
* **優點**：完全消除外部碎片；對於核心資料結構（如進程描述符）極其高效。
* **缺點**：如果物件大小與槽位不匹配，會產生內部碎片。


* **現實場景**：作業系統內核（Linux 的 `kmalloc` 基礎）、資料庫連線池。
* **Rust 推薦庫**：[`slab`](https://www.google.com/search?q=%5Bhttps://crates.io/crates/slab%5D(https://crates.io/crates/slab))。

---

## 3. Hardened Allocator (強化分配器)：追求安全的「保險箱」

這類分配器（如 `Scudo` 或 `hardened_malloc`）犧牲效能來換取安全性，防止黑客利用記憶體漏洞。

* **實現邏輯**：
1. **Guard Pages (保護頁)**：在分配的記憶體前後放置不可存取的「地雷區」，一旦溢位觸碰就會立即崩潰（SIGSEGV），防止緩衝區溢位攻擊。
2. **Canaries (金絲雀值)**：在資料末尾寫入隨機數，釋放時檢查是否被改動。
3. **Randomization (隨機化)**：不連續分配，而是隨機挑選空位，讓攻擊者難以預測物件位址。
4. **Quarantine (隔離區)**：被釋放的記憶體不會立刻重用，而是先關進「隔離區」一陣子，防止 Use-After-Free (UAF) 攻擊。


* **現實場景**：瀏覽器（Chrome 的 PartitionAlloc）、高安全性作業系統（GrapheneOS）。
* **Rust 相關專案**：[`hardened_malloc-rs`](https://www.google.com/search?q=%5Bhttps://crates.io/crates/hardened_malloc-rs%5D(https://crates.io/crates/hardened_malloc-rs))。

---

## 三者對比表

| 特性 | Arena | Slab | Hardened |
| --- | --- | --- | --- |
| **主要目標** | 輸送量與極低延遲 | 物件重用與消除碎片 | 防止惡意攻擊與漏洞利用 |
| **分配時間** | 極快 () | 快 (Free List 操作) | 較慢 (多種安全檢查) |
| **釋放機制** | 批次重置 | 個別回收至 Free List | 延遲回收並清理(Zeroing) |
| **碎片問題** | 內部碎片多，外部碎片無 | 內部碎片中，外部碎片無 | 碎片化嚴重 (因隨機化佈局) |

### 你該如何選擇？

1. 如果你是在寫**短暫生命週期**的任務（如處理一幀遊戲邏輯），選 **Arena**。
2. 如果你的應用程式會**頻繁建立/刪除數萬個同類型物件**，選 **Slab**。
3. 如果你在編寫**暴露於網路環境**且安全性至關重要的 C/C++ 綁定層，選 **Hardened**。

**你想深入看看其中哪一種分配器的具體程式碼實作細節嗎？例如 Slab 的 Free List 是如何用陣列模擬的？**

---

[Learn more about memory allocation in Rust](https://www.youtube.com/watch?v=UG14tozynN0)
這段影片展示了如何在不使用標準庫（no_std）的情況下，在 Rust 中手動實作一個具備 Free List 機制的 Slab 分配器。
