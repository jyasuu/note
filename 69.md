Yes, game engines use a wide variety of algorithms to handle graphics rendering, physics simulation, AI behavior, audio processing, and more. Here are some key algorithms commonly used in game engines:

---

### 🎮 **Graphics & Rendering Algorithms**
1. **Rasterization** – Converts 3D models into 2D images by mapping pixels.
2. **Ray Tracing** – Simulates light rays for realistic lighting and shadows.
3. **Z-Buffering** – Determines which objects are visible based on depth.
4. **Level of Detail (LOD)** – Reduces complexity of distant objects to improve performance.
5. **Shadow Mapping** – Creates shadows by rendering from the light’s perspective.

---

### 🧠 **AI & Pathfinding Algorithms**
1. **A\*** (A-Star) – Finds the shortest path between two points, widely used in navigation.
2. **Behavior Trees** – Models decision-making for NPCs.
3. **Finite State Machines (FSM)** – Manages different states of game entities.
4. **NavMesh (Navigation Mesh)** – Represents walkable areas for pathfinding.

---

### ⚙️ **Physics & Simulation Algorithms**
1. **Collision Detection** – Algorithms like Bounding Box, Bounding Sphere, and Separating Axis Theorem (SAT).
2. **Rigid Body Dynamics** – Simulates movement and interaction of solid objects.
3. **Soft Body Physics** – Simulates deformable objects like cloth or jelly.
4. **Particle Systems** – Used for effects like fire, smoke, and explosions.

---

### 🔊 **Audio Algorithms**
1. **3D Audio Spatialization** – Positions sound in 3D space.
2. **Reverb & Echo Simulation** – Adds realism to sound environments.
3. **Sound Occlusion** – Simulates how sound is blocked or muffled by obstacles.

---

### 🧩 **Game Logic & Scripting**
1. **Event Systems** – Manages game events and triggers.
2. **Entity Component System (ECS)** – Organizes game objects for performance and flexibility.

---

Would you like to dive deeper into any specific category or algorithm? I can also show code examples or explain how they’re implemented in engines like Unity or Unreal.


Great question! The **Boids algorithm** is a classic example of emergent behavior used in game engines and simulations to model flocking behavior—like birds flying together or fish swimming in schools.

---

### 🧠 **What Is the Boids Algorithm?**
Developed by **Craig Reynolds in 1986**, Boids simulates the collective movement of agents (called "boids") using three simple rules:

1. **Separation** – Avoid crowding neighbors (steer to avoid collisions).
2. **Alignment** – Steer towards the average heading of neighbors.
3. **Cohesion** – Steer to move toward the average position of neighbors.

These rules are applied locally, meaning each boid only considers nearby boids, which leads to realistic group movement without centralized control.

---

### 🔧 **Use in Game Engines**
Boids are used in:
- **Crowd simulation** (e.g., NPCs moving in groups)
- **Animal behavior** (e.g., flocks of birds, schools of fish)
- **Particle systems** (e.g., swarming effects)
- **AI** for autonomous agents

Game engines like **Unity** and **Unreal Engine** often implement Boids using either custom scripts or built-in AI systems.

---

### 🧪 Want to See a Demo?
I can generate a simple Python simulation or visualization of Boids in action if you're interested. Would you like to see how it works with code or a visual example?




Absolutely! **Particle systems** are a powerful and flexible technique used in game engines and simulations to create dynamic visual effects. Here's a deeper dive into their **patterns**, **architecture**, and **key concepts**:

---

## 🌟 What Is a Particle System?

A **particle system** is a technique for simulating fuzzy phenomena—like fire, smoke, rain, explosions, magic effects, or swarms—by using a large number of small, simple particles that behave collectively.

Each particle typically has:
- **Position**
- **Velocity**
- **Acceleration**
- **Lifetime**
- **Color**
- **Size**
- **Rotation**

---

## 🧱 Core Components of a Particle System

1. **Emitter**
   - Defines where and how particles are spawned.
   - Types: point, sphere, box, mesh surface, etc.
   - Controls emission rate, direction, and initial velocity.

2. **Particles**
   - Individual entities with properties that evolve over time.
   - Often updated every frame based on physics or custom rules.

3. **Updater**
   - Applies forces like gravity, wind, turbulence.
   - Handles aging, fading, shrinking, or color transitions.

4. **Renderer**
   - Draws particles using sprites, meshes, or shaders.
   - Can use additive blending for glowing effects.

---

## 🎨 Common Particle Patterns

Here are some typical patterns and effects created using particle systems:

### 🔥 Fire & Smoke
- Particles rise with upward velocity.
- Fade out and change color from orange to gray.
- Use turbulence or noise for realism.

### 💥 Explosions
- Emit particles in all directions with high initial velocity.
- Short lifespan, often with color and size transitions.
- May include shockwave rings or debris.

### 🌧️ Rain & Snow
- Particles fall vertically with gravity.
- May include collision detection with ground.
- Snow can accumulate or melt over time.

### ✨ Magic & Energy Effects
- Use spiraling or orbiting motion.
- Color transitions, glow, and trails.
- Often combined with shaders for distortion or bloom.

---

## 🧠 Advanced Techniques

- **GPU Particle Systems**: Use shaders for massive particle counts.
- **Collision Detection**: Particles can bounce, stick, or interact with surfaces.
- **Trail Systems**: Create streaks behind moving particles.
- **Sub-Emitters**: Emit new particles when a particle dies (e.g., sparks from an explosion).
- **Noise Fields**: Add randomness or swirling motion using Perlin or curl noise.

---

## 🛠️ Use in Game Engines

- **Unity**: Uses the **Shuriken** particle system.
- **Unreal Engine**: Uses **Niagara** and **Cascade** systems.
- **Godot**: Has built-in 2D and 3D particle systems.

---

Would you like to see a **visual demo**, a **code example**, or explore how to implement a specific effect like fire or rain? I can generate a simulation or help you build one!



```tsx
import React, { useEffect, useRef, useState } from 'react';

// Particle class
class Particle {
  constructor(x, y, config) {
    this.x = x;
    this.y = y;
    this.vx = config.vx || 0;
    this.vy = config.vy || 0;
    this.life = config.life || 1;
    this.maxLife = config.maxLife || 1;
    this.size = config.size || 3;
    this.color = config.color || 'rgba(255, 255, 255, 1)';
    this.gravity = config.gravity || 0;
    this.friction = config.friction || 1;
    this.fadeRate = config.fadeRate || 0.02;
    this.shrinkRate = config.shrinkRate || 0;
    this.colorTransition = config.colorTransition || [];
    this.angle = config.angle || 0;
    this.angularVelocity = config.angularVelocity || 0;
    this.trail = config.trail || [];
    this.type = config.type || 'circle';
  }

  update() {
    // Update position
    this.x += this.vx;
    this.y += this.vy;
    
    // Apply gravity
    this.vy += this.gravity;
    
    // Apply friction
    this.vx *= this.friction;
    this.vy *= this.friction;
    
    // Update angle
    this.angle += this.angularVelocity;
    
    // Update life
    this.life -= this.fadeRate;
    
    // Update size
    this.size -= this.shrinkRate;
    
    // Update color based on life
    if (this.colorTransition.length > 0) {
      const progress = 1 - (this.life / this.maxLife);
      const colorIndex = Math.floor(progress * (this.colorTransition.length - 1));
      const nextIndex = Math.min(colorIndex + 1, this.colorTransition.length - 1);
      
      if (colorIndex < this.colorTransition.length) {
        this.color = this.colorTransition[colorIndex];
      }
    }
    
    // Add to trail
    if (this.trail.length > 0) {
      this.trail.push({ x: this.x, y: this.y });
      if (this.trail.length > 10) {
        this.trail.shift();
      }
    }
    
    return this.life > 0 && this.size > 0;
  }

  draw(ctx) {
    const alpha = this.life / this.maxLife;
    
    // Draw trail
    if (this.trail.length > 1) {
      ctx.save();
      ctx.strokeStyle = this.color.replace(/[\d.]+\)$/g, `${alpha * 0.5})`);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(this.trail[0].x, this.trail[0].y);
      for (let i = 1; i < this.trail.length; i++) {
        ctx.lineTo(this.trail[i].x, this.trail[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }
    
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    if (this.type === 'circle') {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(0, 0, this.size, 0, Math.PI * 2);
      ctx.fill();
    } else if (this.type === 'spark') {
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-this.size, 0);
      ctx.lineTo(this.size, 0);
      ctx.moveTo(0, -this.size);
      ctx.lineTo(0, this.size);
      ctx.stroke();
    }
    
    ctx.restore();
  }
}

// Particle system configurations
const particleConfigs = {
  fire: {
    name: '🔥 Fire',
    emissionRate: 5,
    generator: (x, y) => new Particle(x + (Math.random() - 0.5) * 20, y, {
      vx: (Math.random() - 0.5) * 2,
      vy: -Math.random() * 3 - 2,
      life: 1,
      maxLife: 1,
      size: Math.random() * 8 + 3,
      gravity: -0.02,
      friction: 0.98,
      fadeRate: 0.015,
      shrinkRate: 0.1,
      colorTransition: [
        'rgba(255, 100, 0, 1)',
        'rgba(255, 200, 0, 1)',
        'rgba(255, 255, 100, 0.8)',
        'rgba(100, 100, 100, 0.4)',
        'rgba(50, 50, 50, 0.2)'
      ]
    })
  },
  
  explosion: {
    name: '💥 Explosion',
    emissionRate: 20,
    burst: true,
    generator: (x, y) => {
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 8 + 2;
      return new Particle(x, y, {
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        maxLife: 1,
        size: Math.random() * 6 + 2,
        gravity: 0.1,
        friction: 0.95,
        fadeRate: 0.02,
        shrinkRate: 0.05,
        colorTransition: [
          'rgba(255, 255, 255, 1)',
          'rgba(255, 200, 0, 1)',
          'rgba(255, 100, 0, 0.8)',
          'rgba(255, 0, 0, 0.4)',
          'rgba(100, 0, 0, 0.2)'
        ]
      });
    }
  },
  
  rain: {
    name: '🌧️ Rain',
    emissionRate: 8,
    generator: (x, y) => new Particle(Math.random() * 800, -10, {
      vx: -0.5,
      vy: Math.random() * 5 + 8,
      life: 1,
      maxLife: 1,
      size: Math.random() * 2 + 1,
      gravity: 0.1,
      friction: 0.999,
      fadeRate: 0.005,
      color: 'rgba(100, 150, 255, 0.7)',
      type: 'circle'
    })
  },
  
  snow: {
    name: '❄️ Snow',
    emissionRate: 3,
    generator: (x, y) => new Particle(Math.random() * 800, -10, {
      vx: (Math.random() - 0.5) * 0.5,
      vy: Math.random() * 2 + 1,
      life: 1,
      maxLife: 1,
      size: Math.random() * 4 + 2,
      gravity: 0.02,
      friction: 0.999,
      fadeRate: 0.002,
      color: 'rgba(255, 255, 255, 0.9)',
      angularVelocity: (Math.random() - 0.5) * 0.02
    })
  },
  
  magic: {
    name: '✨ Magic',
    emissionRate: 2,
    generator: (x, y) => {
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * 50 + 20;
      return new Particle(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius, {
        vx: Math.cos(angle + Math.PI/2) * 2,
        vy: Math.sin(angle + Math.PI/2) * 2,
        life: 1,
        maxLife: 1,
        size: Math.random() * 3 + 2,
        gravity: 0,
        friction: 0.99,
        fadeRate: 0.01,
        colorTransition: [
          'rgba(255, 0, 255, 1)',
          'rgba(0, 255, 255, 1)',
          'rgba(255, 255, 0, 0.8)',
          'rgba(255, 255, 255, 0.4)'
        ],
        angularVelocity: 0.05,
        trail: [],
        type: 'spark'
      });
    }
  },
  
  energy: {
    name: '⚡ Energy',
    emissionRate: 4,
    generator: (x, y) => {
      const t = Date.now() * 0.001;
      const spiralRadius = 30;
      const spiralAngle = Math.random() * Math.PI * 2;
      const spiralX = x + Math.cos(spiralAngle + t) * spiralRadius;
      const spiralY = y + Math.sin(spiralAngle + t) * spiralRadius;
      
      return new Particle(spiralX, spiralY, {
        vx: Math.cos(spiralAngle + t + Math.PI/2) * 1.5,
        vy: Math.sin(spiralAngle + t + Math.PI/2) * 1.5,
        life: 1,
        maxLife: 1,
        size: Math.random() * 4 + 2,
        gravity: 0,
        friction: 0.98,
        fadeRate: 0.015,
        colorTransition: [
          'rgba(0, 255, 255, 1)',
          'rgba(0, 150, 255, 1)',
          'rgba(100, 100, 255, 0.8)',
          'rgba(200, 200, 255, 0.4)'
        ],
        trail: [],
        type: 'circle'
      });
    }
  }
};

export default function ParticleSystem() {
  const canvasRef = useRef(null);
  const [particles, setParticles] = useState([]);
  const [currentEffect, setCurrentEffect] = useState('fire');
  const [isEmitting, setIsEmitting] = useState(false);
  const [mousePos, setMousePos] = useState({ x: 400, y: 300 });
  const animationRef = useRef();
  const emissionCounterRef = useRef(0);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    const animate = () => {
      // Clear canvas
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Update and draw particles
      setParticles(prevParticles => {
        const updatedParticles = prevParticles.filter(particle => {
          particle.update();
          particle.draw(ctx);
          return particle.life > 0 && particle.size > 0;
        });
        
        // Emit new particles
        if (isEmitting) {
          const config = particleConfigs[currentEffect];
          emissionCounterRef.current += config.emissionRate;
          
          if (config.burst && emissionCounterRef.current >= config.emissionRate) {
            // Burst emission
            for (let i = 0; i < config.emissionRate; i++) {
              updatedParticles.push(config.generator(mousePos.x, mousePos.y));
            }
            emissionCounterRef.current = 0;
          } else if (!config.burst && emissionCounterRef.current >= 1) {
            // Continuous emission
            const count = Math.floor(emissionCounterRef.current);
            for (let i = 0; i < count; i++) {
              updatedParticles.push(config.generator(mousePos.x, mousePos.y));
            }
            emissionCounterRef.current -= count;
          }
        }
        
        return updatedParticles;
      });
      
      animationRef.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isEmitting, currentEffect, mousePos]);

  const handleMouseMove = (e) => {
    const rect = canvasRef.current.getBoundingClientRect();
    setMousePos({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    });
  };

  const handleMouseDown = () => {
    setIsEmitting(true);
  };

  const handleMouseUp = () => {
    setIsEmitting(false);
    emissionCounterRef.current = 0;
  };

  const clearParticles = () => {
    setParticles([]);
  };

  return (
    <div className="flex flex-col items-center space-y-4 p-6 bg-gray-900 min-h-screen">
      <div className="text-center">
        <h1 className="text-3xl font-bold text-white mb-2">Particle System Demo</h1>
        <p className="text-gray-300">Click and drag to emit particles</p>
      </div>
      
      <div className="flex flex-wrap gap-2 justify-center">
        {Object.entries(particleConfigs).map(([key, config]) => (
          <button
            key={key}
            onClick={() => setCurrentEffect(key)}
            className={`px-4 py-2 rounded font-medium transition-colors ${
              currentEffect === key
                ? 'bg-blue-600 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            {config.name}
          </button>
        ))}
      </div>
      
      <div className="flex gap-4">
        <button
          onClick={clearParticles}
          className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
        >
          Clear Particles
        </button>
        <div className="text-white">
          Particles: {particles.length}
        </div>
      </div>
      
      <canvas
        ref={canvasRef}
        width={800}
        height={600}
        className="border border-gray-600 bg-black cursor-crosshair"
        onMouseMove={handleMouseMove}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      />
      
      <div className="text-gray-400 text-sm max-w-2xl text-center">
        <p className="mb-2">
          <strong>Current Effect:</strong> {particleConfigs[currentEffect].name}
        </p>
        <p>
          Move your mouse over the canvas and click to emit particles. 
          Each effect demonstrates different particle behaviors like gravity, 
          color transitions, trails, and physics.
        </p>
      </div>
    </div>
  );
}
```


```rs
use yew::prelude::*;
use web_sys::{CanvasRenderingContext2d, HtmlCanvasElement, MouseEvent};
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use std::rc::Rc;
use std::cell::RefCell;
use gloo_timers::callback::Interval;
use js_sys::Math;

#[derive(Clone, Debug, PartialEq)]
pub enum ParticleType {
    Fire,
    Explosion,
    Rain,
    Snow,
    Magic,
}

#[derive(Clone, Debug)]
pub struct Color {
    r: f64,
    g: f64,
    b: f64,
}

impl Color {
    fn new(r: f64, g: f64, b: f64) -> Self {
        Self { r, g, b }
    }
    
    fn to_rgb_string(&self) -> String {
        format!("rgb({}, {}, {})", self.r as u8, self.g as u8, self.b as u8)
    }
}

#[derive(Clone, Debug)]
pub struct Particle {
    x: f64,
    y: f64,
    vx: f64,
    vy: f64,
    life: f64,
    max_life: f64,
    size: f64,
    alpha: f64,
    color: Color,
    particle_type: ParticleType,
    // Magic-specific properties
    angle: f64,
    radius: f64,
    angle_speed: f64,
    radius_speed: f64,
    origin_x: f64,
    origin_y: f64,
}

impl Particle {
    pub fn new(x: f64, y: f64, particle_type: ParticleType) -> Self {
        let mut particle = Self {
            x,
            y,
            vx: 0.0,
            vy: 0.0,
            life: 1.0,
            max_life: 1.0,
            size: Math::random() * 6.0 + 2.0,
            alpha: 1.0,
            color: Color::new(255.0, 255.0, 255.0),
            particle_type: particle_type.clone(),
            angle: 0.0,
            radius: 0.0,
            angle_speed: 0.0,
            radius_speed: 0.0,
            origin_x: x,
            origin_y: y,
        };
        
        particle.initialize_by_type();
        particle
    }
    
    fn initialize_by_type(&mut self) {
        match self.particle_type {
            ParticleType::Fire => {
                self.vx = (Math::random() - 0.5) * 2.0;
                self.vy = -Math::random() * 3.0 - 1.0;
                self.max_life = Math::random() * 60.0 + 30.0;
                self.life = self.max_life;
                self.color = Color::new(255.0, 100.0, 0.0);
            }
            ParticleType::Explosion => {
                let angle = Math::random() * std::f64::consts::PI * 2.0;
                let speed = Math::random() * 8.0 + 2.0;
                self.vx = angle.cos() * speed;
                self.vy = angle.sin() * speed;
                self.max_life = Math::random() * 40.0 + 20.0;
                self.life = self.max_life;
                self.color = Color::new(255.0, 200.0, 0.0);
            }
            ParticleType::Rain => {
                self.vx = Math::random() * 2.0 - 1.0;
                self.vy = Math::random() * 8.0 + 4.0;
                self.max_life = 200.0;
                self.life = self.max_life;
                self.size = Math::random() * 2.0 + 1.0;
                self.color = Color::new(100.0, 150.0, 255.0);
            }
            ParticleType::Snow => {
                self.vx = (Math::random() - 0.5) * 2.0;
                self.vy = Math::random() * 2.0 + 1.0;
                self.max_life = 300.0;
                self.life = self.max_life;
                self.size = Math::random() * 4.0 + 2.0;
                self.color = Color::new(255.0, 255.0, 255.0);
            }
            ParticleType::Magic => {
                self.angle = Math::random() * std::f64::consts::PI * 2.0;
                self.radius = Math::random() * 50.0 + 20.0;
                self.angle_speed = (Math::random() - 0.5) * 0.2;
                self.radius_speed = (Math::random() - 0.5) * 0.5;
                self.max_life = Math::random() * 120.0 + 60.0;
                self.life = self.max_life;
                self.color = Color::new(255.0, 0.0, 255.0);
            }
        }
    }
    
    pub fn update(&mut self) -> bool {
        self.life -= 1.0;
        
        match self.particle_type {
            ParticleType::Fire => {
                self.x += self.vx + (self.life * 0.1).sin() * 0.5; // Turbulence
                self.y += self.vy;
                self.vy -= 0.05; // Upward acceleration
                self.vx *= 0.98; // Air resistance
                
                // Color transition: orange -> red -> gray
                let fire_progress = 1.0 - (self.life / self.max_life);
                if fire_progress < 0.5 {
                    self.color = Color::new(255.0, 100.0 + fire_progress * 100.0, 0.0);
                } else {
                    let gray_amount = (fire_progress - 0.5) * 2.0;
                    self.color = Color::new(
                        255.0 - gray_amount * 155.0,
                        200.0 - gray_amount * 100.0,
                        gray_amount * 100.0,
                    );
                }
            }
            ParticleType::Explosion => {
                self.x += self.vx;
                self.y += self.vy;
                self.vx *= 0.95;
                self.vy *= 0.95;
                
                // Color transition: yellow -> orange -> red
                let expl_progress = 1.0 - (self.life / self.max_life);
                self.color = Color::new(
                    255.0,
                    255.0 - expl_progress * 155.0,
                    expl_progress * 100.0,
                );
                self.size *= 1.0 - expl_progress * 0.02;
            }
            ParticleType::Rain => {
                self.x += self.vx;
                self.y += self.vy;
                self.vy += 0.1; // Gravity
            }
            ParticleType::Snow => {
                self.x += self.vx + (self.life * 0.05).sin() * 0.3; // Drift
                self.y += self.vy;
            }
            ParticleType::Magic => {
                self.angle += self.angle_speed;
                self.radius += self.radius_speed;
                
                // Spiral motion
                self.x = self.origin_x + self.angle.cos() * self.radius;
                self.y = self.origin_y + self.angle.sin() * self.radius;
                
                // Color cycling
                let magic_progress = self.life / self.max_life;
                let hue = (magic_progress * 360.0 + self.angle * 50.0) % 360.0;
                self.color = Self::hsl_to_rgb(hue, 100.0, 50.0);
            }
        }
        
        self.alpha = self.life / self.max_life;
        self.life > 0.0
    }
    
    fn hsl_to_rgb(h: f64, s: f64, l: f64) -> Color {
        let h = h / 360.0;
        let s = s / 100.0;
        let l = l / 100.0;
        
        let hue2rgb = |p: f64, q: f64, mut t: f64| {
            if t < 0.0 { t += 1.0; }
            if t > 1.0 { t -= 1.0; }
            if t < 1.0/6.0 { return p + (q - p) * 6.0 * t; }
            if t < 1.0/2.0 { return q; }
            if t < 2.0/3.0 { return p + (q - p) * (2.0/3.0 - t) * 6.0; }
            p
        };
        
        let q = if l < 0.5 { l * (1.0 + s) } else { l + s - l * s };
        let p = 2.0 * l - q;
        
        Color::new(
            (hue2rgb(p, q, h + 1.0/3.0) * 255.0).round(),
            (hue2rgb(p, q, h) * 255.0).round(),
            (hue2rgb(p, q, h - 1.0/3.0) * 255.0).round(),
        )
    }
    
    pub fn draw(&self, ctx: &CanvasRenderingContext2d) -> Result<(), JsValue> {
        ctx.save();
        ctx.set_global_alpha(self.alpha);
        
        // Add glow effect for magic particles
        if matches!(self.particle_type, ParticleType::Magic) {
            ctx.set_shadow_blur(20.0);
            ctx.set_shadow_color(&self.color.to_rgb_string());
        }
        
        ctx.set_fill_style(&JsValue::from_str(&self.color.to_rgb_string()));
        ctx.begin_path();
        ctx.arc(self.x, self.y, self.size, 0.0, std::f64::consts::PI * 2.0)?;
        ctx.fill();
        
        ctx.restore();
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Emitter {
    x: f64,
    y: f64,
    particle_type: ParticleType,
    rate: u32,
    timer: u32,
}

impl Emitter {
    pub fn new(x: f64, y: f64, particle_type: ParticleType, rate: u32) -> Self {
        Self {
            x,
            y,
            particle_type,
            rate,
            timer: 0,
        }
    }
}

#[derive(Clone, Debug)]
pub struct ParticleSystem {
    particles: Vec<Particle>,
    emitters: Vec<Emitter>,
}

impl ParticleSystem {
    pub fn new() -> Self {
        Self {
            particles: Vec::new(),
            emitters: Vec::new(),
        }
    }
    
    pub fn add_emitter(&mut self, x: f64, y: f64, particle_type: ParticleType, rate: u32) {
        self.emitters.push(Emitter::new(x, y, particle_type, rate));
    }
    
    pub fn remove_emitter(&mut self, index: usize) {
        if index < self.emitters.len() {
            self.emitters.remove(index);
        }
    }
    
    pub fn clear(&mut self) {
        self.particles.clear();
        self.emitters.clear();
    }
    
    pub fn update(&mut self) {
        // Update emitters
        for emitter in &mut self.emitters {
            emitter.timer += 1;
            if emitter.timer >= emitter.rate {
                emitter.timer = 0;
                let particle_count = match emitter.particle_type {
                    ParticleType::Explosion => 20,
                    _ => 2,
                };
                
                for _ in 0..particle_count {
                    self.particles.push(Particle::new(emitter.x, emitter.y, emitter.particle_type.clone()));
                }
            }
        }
        
        // Update particles
        self.particles.retain_mut(|particle| particle.update());
    }
    
    pub fn draw(&self, ctx: &CanvasRenderingContext2d) -> Result<(), JsValue> {
        for particle in &self.particles {
            particle.draw(ctx)?;
        }
        Ok(())
    }
}

#[function_component]
pub fn ParticleSystemDemo() -> Html {
    let canvas_ref = use_node_ref();
    let particle_system = use_state(|| Rc::new(RefCell::new(ParticleSystem::new())));
    let active_effect = use_state(|| ParticleType::Fire);
    let is_running = use_state(|| false);
    let animation_handle = use_state(|| None::<Interval>);
    
    let start_animation = {
        let canvas_ref = canvas_ref.clone();
        let particle_system = particle_system.clone();
        let is_running = is_running.clone();
        let animation_handle = animation_handle.clone();
        
        Callback::from(move |_| {
            if let Some(canvas) = canvas_ref.cast::<HtmlCanvasElement>() {
                let ctx = canvas
                    .get_context("2d")
                    .unwrap()
                    .unwrap()
                    .dyn_into::<CanvasRenderingContext2d>()
                    .unwrap();
                
                let particle_system_clone = particle_system.clone();
                let is_running_clone = is_running.clone();
                
                let interval = Interval::new(16, move || {
                    if *is_running_clone {
                        // Clear canvas with slight trail effect
                        ctx.set_fill_style(&JsValue::from_str("rgba(0, 0, 0, 0.1)"));
                        ctx.fill_rect(0.0, 0.0, canvas.width().into(), canvas.height().into());
                        
                        particle_system_clone.borrow_mut().update();
                        let _ = particle_system_clone.borrow().draw(&ctx);
                    }
                });
                
                animation_handle.set(Some(interval));
            }
        })
    };
    
    let start_effect = {
        let canvas_ref = canvas_ref.clone();
        let particle_system = particle_system.clone();
        let active_effect = active_effect.clone();
        let is_running = is_running.clone();
        let start_animation = start_animation.clone();
        
        Callback::from(move |effect: ParticleType| {
            active_effect.set(effect.clone());
            particle_system.borrow_mut().clear();
            
            if let Some(canvas) = canvas_ref.cast::<HtmlCanvasElement>() {
                let width = canvas.width() as f64;
                let height = canvas.height() as f64;
                let center_x = width / 2.0;
                let center_y = height / 2.0;
                
                match effect {
                    ParticleType::Fire => {
                        particle_system.borrow_mut().add_emitter(center_x, height - 50.0, ParticleType::Fire, 3);
                    }
                    ParticleType::Explosion => {
                        particle_system.borrow_mut().add_emitter(center_x, center_y, ParticleType::Explosion, 60);
                    }
                    ParticleType::Rain => {
                        for i in 0..8 {
                            let x = (i as f64) * width / 8.0;
                            particle_system.borrow_mut().add_emitter(x, -10.0, ParticleType::Rain, 4);
                        }
                    }
                    ParticleType::Snow => {
                        for i in 0..6 {
                            let x = (i as f64) * width / 6.0;
                            particle_system.borrow_mut().add_emitter(x, -10.0, ParticleType::Snow, 6);
                        }
                    }
                    ParticleType::Magic => {
                        particle_system.borrow_mut().add_emitter(center_x, center_y, ParticleType::Magic, 5);
                    }
                }
            }
            
            is_running.set(true);
            start_animation.emit(());
        })
    };
    
    let stop_effect = {
        let particle_system = particle_system.clone();
        let is_running = is_running.clone();
        let animation_handle = animation_handle.clone();
        let canvas_ref = canvas_ref.clone();
        
        Callback::from(move |_| {
            is_running.set(false);
            particle_system.borrow_mut().clear();
            
            if let Some(handle) = (*animation_handle).as_ref() {
                handle.cancel();
            }
            animation_handle.set(None);
            
            // Clear canvas
            if let Some(canvas) = canvas_ref.cast::<HtmlCanvasElement>() {
                let ctx = canvas
                    .get_context("2d")
                    .unwrap()
                    .unwrap()
                    .dyn_into::<CanvasRenderingContext2d>()
                    .unwrap();
                ctx.set_fill_style(&JsValue::from_str("black"));
                ctx.fill_rect(0.0, 0.0, canvas.width().into(), canvas.height().into());
            }
        })
    };
    
    let handle_canvas_click = {
        let canvas_ref = canvas_ref.clone();
        let particle_system = particle_system.clone();
        let active_effect = active_effect.clone();
        let is_running = is_running.clone();
        
        Callback::from(move |e: MouseEvent| {
            if !*is_running {
                return;
            }
            
            if let Some(canvas) = canvas_ref.cast::<HtmlCanvasElement>() {
                let rect = canvas.get_bounding_client_rect();
                let x = e.client_x() as f64 - rect.left();
                let y = e.client_y() as f64 - rect.top();
                
                if matches!(*active_effect, ParticleType::Explosion) {
                    particle_system.borrow_mut().add_emitter(x, y, ParticleType::Explosion, 60);
                }
            }
        })
    };
    
    // Initialize canvas
    use_effect_with_deps(
        {
            let canvas_ref = canvas_ref.clone();
            move |_| {
                if let Some(canvas) = canvas_ref.cast::<HtmlCanvasElement>() {
                    canvas.set_width(800);
                    canvas.set_height(600);
                    let ctx = canvas
                        .get_context("2d")
                        .unwrap()
                        .unwrap()
                        .dyn_into::<CanvasRenderingContext2d>()
                        .unwrap();
                    ctx.set_fill_style(&JsValue::from_str("black"));
                    ctx.fill_rect(0.0, 0.0, 800.0, 600.0);
                }
            }
        },
        (),
    );
    
    html! {
        <div class="max-w-4xl mx-auto p-6 bg-gray-900 text-white">
            <div class="text-center mb-8">
                <h1 class="text-4xl font-bold mb-4 bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
                    {"🎨 Rust Yew Particle System"}
                </h1>
                <p class="text-gray-300 text-lg">
                    {"Interactive particle effects: Fire, Explosions, Weather & Magic"}
                </p>
            </div>
            
            <div class="mb-6">
                <canvas
                    ref={canvas_ref}
                    onclick={handle_canvas_click}
                    class="border border-gray-600 rounded-lg shadow-2xl cursor-crosshair bg-black"
                    style="width: 100%; height: 400px;"
                />
            </div>
            
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6">
                <button
                    onclick={start_effect.reform(|_| ParticleType::Fire)}
                    class="bg-orange-600 hover:bg-orange-700 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
                >
                    {"🔥 Fire"}
                </button>
                <button
                    onclick={start_effect.reform(|_| ParticleType::Explosion)}
                    class="bg-yellow-600 hover:bg-yellow-700 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
                >
                    {"💥 Explosion"}
                </button>
                <button
                    onclick={start_effect.reform(|_| ParticleType::Rain)}
                    class="bg-blue-600 hover:bg-blue-700 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
                >
                    {"🌧️ Rain"}
                </button>
                <button
                    onclick={start_effect.reform(|_| ParticleType::Snow)}
                    class="bg-cyan-600 hover:bg-cyan-700 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
                >
                    {"❄️ Snow"}
                </button>
                <button
                    onclick={start_effect.reform(|_| ParticleType::Magic)}
                    class="bg-purple-600 hover:bg-purple-700 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
                >
                    {"✨ Magic"}
                </button>
                <button
                    onclick={stop_effect}
                    class="bg-red-600 hover:bg-red-700 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
                >
                    {"⏹️ Stop"}
                </button>
            </div>
            
            <div class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold mb-4 text-center">{"Effects Guide"}</h2>
                <div class="grid md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-lg font-semibold mb-2 text-orange-400">{"🔥 Fire & Smoke"}</h3>
                        <p class="text-sm text-gray-300 mb-4">
                            {"Particles rise with upward velocity, fade from orange to gray with turbulence for realism."}
                        </p>
                        
                        <h3 class="text-lg font-semibold mb-2 text-yellow-400">{"💥 Explosions"}</h3>
                        <p class="text-sm text-gray-300 mb-4">
                            {"Particles emit in all directions with high velocity and short lifespan. Click canvas for explosions!"}
                        </p>
                        
                        <h3 class="text-lg font-semibold mb-2 text-blue-400">{"🌧️ Rain & Snow"}</h3>
                        <p class="text-sm text-gray-300">
                            {"Rain falls with gravity, snow drifts with gentle motion patterns."}
                        </p>
                    </div>
                    
                    <div>
                        <h3 class="text-lg font-semibold mb-2 text-purple-400">{"✨ Magic & Energy"}</h3>
                        <p class="text-sm text-gray-300 mb-4">
                            {"Spiraling motion with color cycling, glow effects and orbital patterns."}
                        </p>
                        
                        <div class="bg-gray-700 rounded p-4">
                            <h4 class="font-semibold mb-2">{"Current Effect:"}</h4>
                            <p class="text-sm">
                                <span class="inline-block w-3 h-3 bg-green-500 rounded-full mr-2"></span>
                                {format!("{:?}", *active_effect)}
                                {if *is_running { " (Running)" } else { " (Stopped)" }}
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
}

// Main app component
#[function_component]
pub fn App() -> Html {
    html! {
        <ParticleSystemDemo />
    }
}

fn main() {
    yew::Renderer::<App>::new().render();
}

// Cargo.toml dependencies needed:
/*
[dependencies]
yew = { version = "0.20", features = ["csr"] }
web-sys = { version = "0.3", features = [
    "console",
    "CanvasRenderingContext2d",
    "HtmlCanvasElement",
    "MouseEvent",
    "DomRect",
] }
wasm-bindgen = "0.2"
js-sys = "0.3"
gloo-timers = "0.2"
*/
```


```rs
use yew::prelude::*;
use web_sys::{CanvasRenderingContext2d, HtmlCanvasElement, MouseEvent};
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use std::f64::consts::PI;
use gloo_timers::callback::Interval;
use rand::prelude::*;

#[derive(Debug, Clone, PartialEq)]
pub enum ParticleType {
    Circle,
    Spark,
}

#[derive(Debug, Clone, PartialEq)]
pub enum EffectType {
    Fire,
    Explosion,
    Rain,
    Snow,
    Magic,
    Energy,
}

impl std::fmt::Display for EffectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EffectType::Fire => write!(f, "🔥 Fire"),
            EffectType::Explosion => write!(f, "💥 Explosion"),
            EffectType::Rain => write!(f, "🌧️ Rain"),
            EffectType::Snow => write!(f, "❄️ Snow"),
            EffectType::Magic => write!(f, "✨ Magic"),
            EffectType::Energy => write!(f, "⚡ Energy"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Color {
    pub r: f64,
    pub g: f64,
    pub b: f64,
    pub a: f64,
}

impl Color {
    pub fn new(r: f64, g: f64, b: f64, a: f64) -> Self {
        Self { r, g, b, a }
    }
    
    pub fn to_css_string(&self) -> String {
        format!("rgba({}, {}, {}, {})", self.r, self.g, self.b, self.a)
    }
}

#[derive(Debug, Clone)]
pub struct Particle {
    pub x: f64,
    pub y: f64,
    pub vx: f64,
    pub vy: f64,
    pub life: f64,
    pub max_life: f64,
    pub size: f64,
    pub color: Color,
    pub gravity: f64,
    pub friction: f64,
    pub fade_rate: f64,
    pub shrink_rate: f64,
    pub angle: f64,
    pub angular_velocity: f64,
    pub particle_type: ParticleType,
    pub color_transitions: Vec<Color>,
    pub trail: Vec<(f64, f64)>,
}

impl Particle {
    pub fn new(x: f64, y: f64) -> Self {
        Self {
            x,
            y,
            vx: 0.0,
            vy: 0.0,
            life: 1.0,
            max_life: 1.0,
            size: 3.0,
            color: Color::new(255.0, 255.0, 255.0, 1.0),
            gravity: 0.0,
            friction: 1.0,
            fade_rate: 0.02,
            shrink_rate: 0.0,
            angle: 0.0,
            angular_velocity: 0.0,
            particle_type: ParticleType::Circle,
            color_transitions: Vec::new(),
            trail: Vec::new(),
        }
    }

    pub fn update(&mut self) -> bool {
        // Update position
        self.x += self.vx;
        self.y += self.vy;
        
        // Apply gravity
        self.vy += self.gravity;
        
        // Apply friction
        self.vx *= self.friction;
        self.vy *= self.friction;
        
        // Update angle
        self.angle += self.angular_velocity;
        
        // Update life
        self.life -= self.fade_rate;
        
        // Update size
        self.size -= self.shrink_rate;
        
        // Update color based on life
        if !self.color_transitions.is_empty() {
            let progress = 1.0 - (self.life / self.max_life);
            let color_index = (progress * (self.color_transitions.len() - 1) as f64).floor() as usize;
            if color_index < self.color_transitions.len() {
                self.color = self.color_transitions[color_index].clone();
            }
        }
        
        // Add to trail
        if self.trail.len() > 0 {
            self.trail.push((self.x, self.y));
            if self.trail.len() > 10 {
                self.trail.remove(0);
            }
        }
        
        self.life > 0.0 && self.size > 0.0
    }

    pub fn draw(&self, ctx: &CanvasRenderingContext2d) {
        let alpha = self.life / self.max_life;
        
        // Draw trail
        if self.trail.len() > 1 {
            ctx.save();
            let mut trail_color = self.color.clone();
            trail_color.a = alpha * 0.5;
            ctx.set_stroke_style(&JsValue::from_str(&trail_color.to_css_string()));
            ctx.set_line_width(1.0);
            ctx.begin_path();
            ctx.move_to(self.trail[0].0, self.trail[0].1);
            for i in 1..self.trail.len() {
                ctx.line_to(self.trail[i].0, self.trail[i].1);
            }
            let _ = ctx.stroke();
            ctx.restore();
        }
        
        ctx.save();
        ctx.set_global_alpha(alpha);
        let _ = ctx.translate(self.x, self.y);
        let _ = ctx.rotate(self.angle);
        
        match self.particle_type {
            ParticleType::Circle => {
                ctx.set_fill_style(&JsValue::from_str(&self.color.to_css_string()));
                ctx.begin_path();
                let _ = ctx.arc(0.0, 0.0, self.size, 0.0, 2.0 * PI);
                ctx.fill();
            }
            ParticleType::Spark => {
                ctx.set_stroke_style(&JsValue::from_str(&self.color.to_css_string()));
                ctx.set_line_width(2.0);
                ctx.begin_path();
                ctx.move_to(-self.size, 0.0);
                ctx.line_to(self.size, 0.0);
                ctx.move_to(0.0, -self.size);
                ctx.line_to(0.0, self.size);
                let _ = ctx.stroke();
            }
        }
        
        ctx.restore();
    }
}

pub struct ParticleConfig {
    pub emission_rate: f64,
    pub is_burst: bool,
    pub generator: fn(f64, f64) -> Particle,
}

impl ParticleConfig {
    pub fn get_config(effect_type: &EffectType) -> Self {
        match effect_type {
            EffectType::Fire => ParticleConfig {
                emission_rate: 5.0,
                is_burst: false,
                generator: |x, y| {
                    let mut rng = thread_rng();
                    let mut particle = Particle::new(x + (rng.gen::<f64>() - 0.5) * 20.0, y);
                    particle.vx = (rng.gen::<f64>() - 0.5) * 2.0;
                    particle.vy = -rng.gen::<f64>() * 3.0 - 2.0;
                    particle.size = rng.gen::<f64>() * 8.0 + 3.0;
                    particle.gravity = -0.02;
                    particle.friction = 0.98;
                    particle.fade_rate = 0.015;
                    particle.shrink_rate = 0.1;
                    particle.color_transitions = vec![
                        Color::new(255.0, 100.0, 0.0, 1.0),
                        Color::new(255.0, 200.0, 0.0, 1.0),
                        Color::new(255.0, 255.0, 100.0, 0.8),
                        Color::new(100.0, 100.0, 100.0, 0.4),
                        Color::new(50.0, 50.0, 50.0, 0.2),
                    ];
                    particle
                },
            },
            EffectType::Explosion => ParticleConfig {
                emission_rate: 20.0,
                is_burst: true,
                generator: |x, y| {
                    let mut rng = thread_rng();
                    let angle = rng.gen::<f64>() * 2.0 * PI;
                    let speed = rng.gen::<f64>() * 8.0 + 2.0;
                    let mut particle = Particle::new(x, y);
                    particle.vx = angle.cos() * speed;
                    particle.vy = angle.sin() * speed;
                    particle.size = rng.gen::<f64>() * 6.0 + 2.0;
                    particle.gravity = 0.1;
                    particle.friction = 0.95;
                    particle.fade_rate = 0.02;
                    particle.shrink_rate = 0.05;
                    particle.color_transitions = vec![
                        Color::new(255.0, 255.0, 255.0, 1.0),
                        Color::new(255.0, 200.0, 0.0, 1.0),
                        Color::new(255.0, 100.0, 0.0, 0.8),
                        Color::new(255.0, 0.0, 0.0, 0.4),
                        Color::new(100.0, 0.0, 0.0, 0.2),
                    ];
                    particle
                },
            },
            EffectType::Rain => ParticleConfig {
                emission_rate: 8.0,
                is_burst: false,
                generator: |_, _| {
                    let mut rng = thread_rng();
                    let mut particle = Particle::new(rng.gen::<f64>() * 800.0, -10.0);
                    particle.vx = -0.5;
                    particle.vy = rng.gen::<f64>() * 5.0 + 8.0;
                    particle.size = rng.gen::<f64>() * 2.0 + 1.0;
                    particle.gravity = 0.1;
                    particle.friction = 0.999;
                    particle.fade_rate = 0.005;
                    particle.color = Color::new(100.0, 150.0, 255.0, 0.7);
                    particle
                },
            },
            EffectType::Snow => ParticleConfig {
                emission_rate: 3.0,
                is_burst: false,
                generator: |_, _| {
                    let mut rng = thread_rng();
                    let mut particle = Particle::new(rng.gen::<f64>() * 800.0, -10.0);
                    particle.vx = (rng.gen::<f64>() - 0.5) * 0.5;
                    particle.vy = rng.gen::<f64>() * 2.0 + 1.0;
                    particle.size = rng.gen::<f64>() * 4.0 + 2.0;
                    particle.gravity = 0.02;
                    particle.friction = 0.999;
                    particle.fade_rate = 0.002;
                    particle.color = Color::new(255.0, 255.0, 255.0, 0.9);
                    particle.angular_velocity = (rng.gen::<f64>() - 0.5) * 0.02;
                    particle
                },
            },
            EffectType::Magic => ParticleConfig {
                emission_rate: 2.0,
                is_burst: false,
                generator: |x, y| {
                    let mut rng = thread_rng();
                    let angle = rng.gen::<f64>() * 2.0 * PI;
                    let radius = rng.gen::<f64>() * 50.0 + 20.0;
                    let mut particle = Particle::new(
                        x + angle.cos() * radius,
                        y + angle.sin() * radius,
                    );
                    particle.vx = (angle + PI / 2.0).cos() * 2.0;
                    particle.vy = (angle + PI / 2.0).sin() * 2.0;
                    particle.size = rng.gen::<f64>() * 3.0 + 2.0;
                    particle.friction = 0.99;
                    particle.fade_rate = 0.01;
                    particle.angular_velocity = 0.05;
                    particle.particle_type = ParticleType::Spark;
                    particle.color_transitions = vec![
                        Color::new(255.0, 0.0, 255.0, 1.0),
                        Color::new(0.0, 255.0, 255.0, 1.0),
                        Color::new(255.0, 255.0, 0.0, 0.8),
                        Color::new(255.0, 255.0, 255.0, 0.4),
                    ];
                    particle.trail = vec![];
                    particle
                },
            },
            EffectType::Energy => ParticleConfig {
                emission_rate: 4.0,
                is_burst: false,
                generator: |x, y| {
                    let mut rng = thread_rng();
                    let t = js_sys::Date::now() * 0.001;
                    let spiral_radius = 30.0;
                    let spiral_angle = rng.gen::<f64>() * 2.0 * PI;
                    let spiral_x = x + (spiral_angle + t).cos() * spiral_radius;
                    let spiral_y = y + (spiral_angle + t).sin() * spiral_radius;
                    
                    let mut particle = Particle::new(spiral_x, spiral_y);
                    particle.vx = (spiral_angle + t + PI / 2.0).cos() * 1.5;
                    particle.vy = (spiral_angle + t + PI / 2.0).sin() * 1.5;
                    particle.size = rng.gen::<f64>() * 4.0 + 2.0;
                    particle.friction = 0.98;
                    particle.fade_rate = 0.015;
                    particle.color_transitions = vec![
                        Color::new(0.0, 255.0, 255.0, 1.0),
                        Color::new(0.0, 150.0, 255.0, 1.0),
                        Color::new(100.0, 100.0, 255.0, 0.8),
                        Color::new(200.0, 200.0, 255.0, 0.4),
                    ];
                    particle.trail = vec![];
                    particle
                },
            },
        }
    }
}

#[derive(Properties, PartialEq)]
pub struct Props {}

pub struct ParticleSystem {
    canvas_ref: NodeRef,
    particles: Vec<Particle>,
    current_effect: EffectType,
    is_emitting: bool,
    mouse_pos: (f64, f64),
    emission_counter: f64,
    _interval: Option<Interval>,
}

pub enum Msg {
    Tick,
    ChangeEffect(EffectType),
    MouseMove(f64, f64),
    MouseDown,
    MouseUp,
    ClearParticles,
}

impl Component for ParticleSystem {
    type Message = Msg;
    type Properties = Props;

    fn create(_ctx: &Context<Self>) -> Self {
        Self {
            canvas_ref: NodeRef::default(),
            particles: Vec::new(),
            current_effect: EffectType::Fire,
            is_emitting: false,
            mouse_pos: (400.0, 300.0),
            emission_counter: 0.0,
            _interval: None,
        }
    }

    fn rendered(&mut self, ctx: &Context<Self>, first_render: bool) {
        if first_render {
            let link = ctx.link().clone();
            let interval = Interval::new(16, move || {
                link.send_message(Msg::Tick);
            });
            self._interval = Some(interval);
        }
    }

    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {
        match msg {
            Msg::Tick => {
                self.animate();
                true
            }
            Msg::ChangeEffect(effect) => {
                self.current_effect = effect;
                true
            }
            Msg::MouseMove(x, y) => {
                self.mouse_pos = (x, y);
                false
            }
            Msg::MouseDown => {
                self.is_emitting = true;
                false
            }
            Msg::MouseUp => {
                self.is_emitting = false;
                self.emission_counter = 0.0;
                false
            }
            Msg::ClearParticles => {
                self.particles.clear();
                true
            }
        }
    }

    fn view(&self, ctx: &Context<Self>) -> Html {
        let effects = vec![
            EffectType::Fire,
            EffectType::Explosion,
            EffectType::Rain,
            EffectType::Snow,
            EffectType::Magic,
            EffectType::Energy,
        ];

        let onmousemove = ctx.link().callback(|e: MouseEvent| {
            let canvas = e.target_unchecked_into::<HtmlCanvasElement>();
            let rect = canvas.get_bounding_client_rect();
            Msg::MouseMove(
                e.client_x() as f64 - rect.x(),
                e.client_y() as f64 - rect.y(),
            )
        });

        let onmousedown = ctx.link().callback(|_| Msg::MouseDown);
        let onmouseup = ctx.link().callback(|_| Msg::MouseUp);
        let onmouseleave = ctx.link().callback(|_| Msg::MouseUp);

        html! {
            <div class="flex flex-col items-center space-y-4 p-6 bg-gray-900 min-h-screen">
                <div class="text-center">
                    <h1 class="text-3xl font-bold text-white mb-2">{"Particle System Demo"}</h1>
                    <p class="text-gray-300">{"Click and drag to emit particles"}</p>
                </div>
                
                <div class="flex flex-wrap gap-2 justify-center">
                    { for effects.iter().map(|effect| {
                        let effect_clone = effect.clone();
                        let is_active = *effect == self.current_effect;
                        let onclick = ctx.link().callback(move |_| Msg::ChangeEffect(effect_clone.clone()));
                        html! {
                            <button
                                {onclick}
                                class={format!("px-4 py-2 rounded font-medium transition-colors {}",
                                    if is_active {
                                        "bg-blue-600 text-white"
                                    } else {
                                        "bg-gray-700 text-gray-300 hover:bg-gray-600"
                                    }
                                )}
                            >
                                { effect.to_string() }
                            </button>
                        }
                    }) }
                </div>
                
                <div class="flex gap-4 items-center">
                    <button
                        onclick={ctx.link().callback(|_| Msg::ClearParticles)}
                        class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                    >
                        {"Clear Particles"}
                    </button>
                    <div class="text-white">
                        { format!("Particles: {}", self.particles.len()) }
                    </div>
                </div>
                
                <canvas
                    ref={self.canvas_ref.clone()}
                    width="800"
                    height="600"
                    class="border border-gray-600 bg-black cursor-crosshair"
                    {onmousemove}
                    {onmousedown}
                    {onmouseup}
                    {onmouseleave}
                />
                
                <div class="text-gray-400 text-sm max-w-2xl text-center">
                    <p class="mb-2">
                        <strong>{"Current Effect: "}</strong> { self.current_effect.to_string() }
                    </p>
                    <p>
                        {"Move your mouse over the canvas and click to emit particles. "}
                        {"Each effect demonstrates different particle behaviors like gravity, "}
                        {"color transitions, trails, and physics."}
                    </p>
                </div>
            </div>
        }
    }
}

impl ParticleSystem {
    fn animate(&mut self) {
        if let Some(canvas) = self.canvas_ref.cast::<HtmlCanvasElement>() {
            if let Ok(ctx) = canvas.get_context("2d")
                .unwrap()
                .unwrap()
                .dyn_into::<CanvasRenderingContext2d>()
            {
                // Clear canvas with fade effect
                ctx.set_fill_style(&JsValue::from_str("rgba(0, 0, 0, 0.1)"));
                ctx.fill_rect(0.0, 0.0, 800.0, 600.0);
                
                // Update and draw particles
                self.particles.retain_mut(|particle| {
                    let alive = particle.update();
                    if alive {
                        particle.draw(&ctx);
                    }
                    alive
                });
                
                // Emit new particles
                if self.is_emitting {
                    let config = ParticleConfig::get_config(&self.current_effect);
                    self.emission_counter += config.emission_rate;
                    
                    if config.is_burst && self.emission_counter >= config.emission_rate {
                        // Burst emission
                        for _ in 0..(config.emission_rate as usize) {
                            let particle = (config.generator)(self.mouse_pos.0, self.mouse_pos.1);
                            self.particles.push(particle);
                        }
                        self.emission_counter = 0.0;
                    } else if !config.is_burst && self.emission_counter >= 1.0 {
                        // Continuous emission
                        let count = self.emission_counter.floor() as usize;
                        for _ in 0..count {
                            let particle = (config.generator)(self.mouse_pos.0, self.mouse_pos.1);
                            self.particles.push(particle);
                        }
                        self.emission_counter -= count as f64;
                    }
                }
            }
        }
    }
}

fn main() {
    yew::Renderer::<ParticleSystem>::new().render();
}

// Cargo.toml dependencies needed:
/*
[dependencies]
yew = { version = "0.21", features = ["csr"] }
web-sys = { version = "0.3", features = [
    "console",
    "CanvasRenderingContext2d",
    "HtmlCanvasElement",
    "MouseEvent",
    "DomRect",
] }
wasm-bindgen = "0.2"
js-sys = "0.3"
gloo-timers = "0.3"
rand = { version = "0.8", features = ["small_rng"] }
*/
```
