### Learning Spring Boot with and without Redisson

#### **1. Core Concepts**
- **Spring Boot**: Java framework simplifying standalone app creation with embedded servers.
- **Redisson**: Java client for Redis providing distributed objects (locks, maps, queues) and services.

#### **2. Key Differences: With vs. Without Redisson**

| **Feature**               | **Without Redisson**                          | **With Redisson**                              |
|---------------------------|-----------------------------------------------|------------------------------------------------|
| **Distributed Lock**      | Manual implementation (e.g., `SET key NX EX`) | Built-in `RLock` with auto-renewal, reentrancy |
| **Caching**               | Spring `@Cacheable` (simple key-value)        | Advanced `RMapCache` with TTL per entry        |
| **Pub/Sub**               | Basic `RedisTemplate` channels                | `RTopic` with reliable message delivery        |
| **Collections**           | Standard Redis collections                    | Distributed Java objects (`RList`, `RSet`)     |
| **Code Complexity**       | Higher (manual logic for locks, retries)      | Lower (pre-built thread-safe APIs)             |
| **Performance**           | Good for simple cases                         | Optimized for distributed scenarios            |
| **Reentrant Locks**       | Not supported natively                        | Native support                                 |
| **Lock Lease Renewal**    | Manual implementation                         | Automatic (watchdog)                           |

---

### **Without Redisson Example**
#### Distributed Lock using Spring Data Redis
```java
@Service
public class SimpleLockService {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public boolean acquireLock(String key, String value, long expireSeconds) {
        return redisTemplate.opsForValue()
            .setIfAbsent(key, value, Duration.ofSeconds(expireSeconds));
    }

    public void releaseLock(String key) {
        redisTemplate.delete(key);
    }
}

// Usage
public void processOrder(String orderId) {
    String lockKey = "lock:order:" + orderId;
    if (simpleLockService.acquireLock(lockKey, "locked", 30)) {
        try {
            // Business logic
        } finally {
            simpleLockService.releaseLock(lockKey);
        }
    }
}
```
**Limitations**: 
- No auto-renewal for long operations
- Risk of deadlocks if expiration isn't set
- Not reentrant

---

### **With Redisson Example**
#### Distributed Lock & Cached Map
```java
@Configuration
public class RedissonConfig {
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer().setAddress("redis://127.0.0.1:6379");
        return Redisson.create(config);
    }
}

@Service
public class OrderService {
    @Autowired
    private RedissonClient redissonClient;

    public void processOrder(String orderId) {
        RLock lock = redissonClient.getLock("lock:order:" + orderId);
        try {
            if (lock.tryLock(10, 60, TimeUnit.SECONDS)) {
                // Business logic (lock auto-renews)
            }
        } finally {
            if (lock.isLocked() && lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }

    // Advanced cache with per-entry TTL
    public void cacheProduct(Product product) {
        RMapCache<String, Product> cache = redissonClient.getMapCache("products");
        cache.put(product.getId(), product, 2, TimeUnit.HOURS); // TTL=2h
    }
}
```
**Advantages**:
- Automatic lock renewal (no expiry during operations)
- Reentrant locks (same thread can relock)
- Thread-safe distributed collections

---

### **When to Use Redisson**
1. **Distributed Locks**: Critical for cluster-safe operations (e.g., inventory deduction).
2. **Shared State**: Distributed queues (`RQueue`), maps (`RMap`), or rate limiters.
3. **Complex Caching**: TTL per entry, eviction listeners.
4. **High Reliability**: Pub/Sub with delivery guarantees.

### **When Spring Data Redis Suffices**
1. **Simple Caching**: Basic key-value stores.
2. **Non-Critical Locks**: Best-effort locking (e.g., cache warming).
3. **Minimal Dependencies**: Avoiding extra libraries.

---

### **Setup Guide**
#### **Dependencies (pom.xml)**
```xml
<!-- Without Redisson -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!-- With Redisson -->
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.23.2</version>
</dependency>
```

#### **application.properties**
```properties
# Both approaches
spring.redis.host=localhost
spring.redis.port=6379
```

---

### **Best Practices**
1. **Always set lock timeouts** (prevent deadlocks).
2. **Use `try-finally`** for lock release.
3. **Test failure scenarios**: Simulate Redis downtime.
4. **Monitor**: Track lock wait times and cache hit rates.

### **Final Recommendation**
- **Use Redisson** for distributed systems needing reliability (ecommerce, inventory).
- **Stick to Spring Data Redis** for simple caching or non-critical tasks.

Learn more:  
[Redisson Documentation](https://redisson.org/)  
[Spring Data Redis](https://spring.io/projects/spring-data-redis)

### Deep Dive: Distributed Locking in Spring Boot with vs. without Redisson

Distributed locks are critical in clustered environments to prevent race conditions (e.g., inventory overselling, duplicate processing). Below is a focused comparison:

---

#### **1. Lock Implementation Comparison**
| **Feature**               | **Without Redisson**                          | **With Redisson**                              |
|---------------------------|-----------------------------------------------|------------------------------------------------|
| **Lock Acquisition**      | Manual `SET key NX EX` commands               | Single `RLock.tryLock()` call                  |
| **Reentrancy**            | Not supported                                 | Native support (same thread relocks)           |
| **Lease Renewal**         | Manual TTL refresh required                   | Automatic (watchdog thread)                    |
| **Unlock Safety**         | Risk of releasing others' locks              | Thread ownership validation                    |
| **Fair Locking**          | Not possible                                  | Supported via `RFairLock`                      |
| **Wait Timeout**          | Manual polling/retry logic                    | Built-in `tryLock(waitTime, leaseTime)`        |
| **Deadlock Resilience**   | Low (expiry dependent on TTL accuracy)        | High (automatic release on app/node failure)   |

---

#### **2. Without Redisson: Manual Lock Implementation**
```java
@Service
public class ManualRedisLock {
    private final RedisTemplate<String, String> redisTemplate;
    
    // Acquire lock (NX = Only set if not exists)
    public boolean tryLock(String key, String clientId, long ttlSec) {
        return Boolean.TRUE.equals(
            redisTemplate.opsForValue()
                .setIfAbsent(key, clientId, Duration.ofSeconds(ttlSec))
        );
    }

    // Release lock (validate owner)
    public void unlock(String key, String clientId) {
        String script = 
            "if redis.call('get',KEYS[1]) == ARGV[1] then " +
            "   return redis.call('del',KEYS[1]) " +
            "else " +
            "   return 0 " +
            "end";
        
        redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key),
            clientId
        );
    }
}
```

**Pain Points:**
- **Lease Expiration Risk:**  
  If business logic exceeds TTL, other clients can acquire the lock.
- **No Reentrancy:**  
  Same thread can't re-enter locked code.
- **Complex Error Handling:**  
  Requires manual retries, backoffs, and lock state checks.
- **Atomicity Challenges:**  
  Unlock requires Lua scripts for safety.

---

#### **3. With Redisson: Production-Ready Locking**
```java
@Service
public class OrderService {
    private final RedissonClient redisson;

    public void processPayment(String orderId) {
        RLock lock = redisson.getLock("order:lock:" + orderId);
        try {
            // Wait max 5s, auto-release after 30s if unlocked
            if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {
                // Critical section
                paymentService.charge(orderId);
            }
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

**Advantages:**
- **Automatic Lease Renewal:**  
  Watchdog thread extends lock TTL during long operations.
- **Reentrancy:**  
  Same thread can call `lock.tryLock()` multiple times.
- **Lock Continuity:**  
  Survives Redis connection blips (retries internally).
- **Advanced Options:**  
  - Fair locks (`redisson.getFairLock()`)  
  - ReadWrite locks (`redisson.getReadWriteLock()`)  
  - MultiLock for across multiple keys

---

#### **4. Scenarios: When to Use Which?**

**Use Manual Locks When:**
- Lock duration is very short (< 100ms)
- Simple use cases (e.g., cache warming)
- Cannot add new dependencies
- Lock ownership checks aren't critical

**Use Redisson When:**
- Locking business logic > 1 second
- Reentrancy needed (e.g., nested service calls)
- High contention scenarios (many lock requests)
- Require fail-safe unlock (app crashes/network issues)
- Fair queuing for locks required

---

#### **5. Performance Considerations**
- **Redisson Overhead:**  
  ~5-10% higher latency due to watchdog/thread management.  
  *Worth it for correctness in distributed systems!*
  
- **Manual Lock Risks:**  
  - TTL too short â†’ Premature lock loss  
  - TTL too long â†’ Deadlock during failures  
  - Unlock collisions â†’ Data corruption

---

#### **Final Recommendation**
For mission-critical systems, **Redisson is superior** due to:
1. Automatic lease renewal
2. Battle-tested lock reliability
3. Reentrancy support
4. Simplified error handling

**Manual locking only for trivial/transient operations.** Use Redisson's `RLock` for inventory management, financial transactions, or any state-mutating operations.

> ğŸ’¡ **Pro Tip:** Combine with `@Transactional` for DB + lock consistency:  
> 1. Acquire lock  
> 2. Start DB transaction  
> 3. Commit DB transaction  
> 4. Release lock
>
> ### Why Use `isHeldByCurrentThread()` in Redisson Locks?

The `lock.isHeldByCurrentThread()` check ensures thread safety when releasing locks by:
1. **Preventing Illegal Unlock Attempts**  
   Avoids releasing locks owned by other threads (critical in high-concurrency scenarios).
2. **Handling Reentrant Locks**  
   Safely manages nested lock acquisitions (same thread locking multiple times).
3. **Exception Safety**  
   Guarantees cleanup code only releases locks actually held by the current thread.

---

### Mermaid Sequence Diagram: Lock Lifecycle with Redisson

```mermaid
sequenceDiagram
    participant App as Application Thread
    participant Redisson as Redisson RLock
    participant Redis as Redis Server

    App->>Redisson: tryLock(5s, 30s)
    Redisson->>Redis: SET lock:order:123 NX PX 30000
    Redis-->>Redisson: OK (lock acquired)
    Redisson-->>App: true
    
    loop Lease Renewal (Watchdog)
        Redisson->>Redis: PEXPIRE lock:order:123 30000
        Redis-->>Redisson: OK
        Redisson->>Redisson: Schedule next renewal
    end

    App->>App: Process critical section (e.g., charge payment)
    
    App->>Redisson: unlock()
    Redisson->>Redisson: isHeldByCurrentThread()? â†’ true
    Redisson->>Redis: DEL lock:order:123
    Redis-->>Redisson: OK
    Redisson-->>App: Lock released

    loop Watchdog Termination
        Redisson->>Redisson: Cancel lease renewal
    end
```

---

### Key Scenarios Explained

#### 1. **Successful Lock Acquisition & Release**
```mermaid
sequenceDiagram
    participant ThreadA
    participant RLock
    participant Redis
    
    ThreadA->>RLock: tryLock()
    RLock->>Redis: SETNX lock_key
    Redis-->>RLock: OK
    RLock-->>ThreadA: true
    
    ThreadA->>ThreadA: Critical section
    
    ThreadA->>RLock: unlock()
    RLock->>RLock: isHeldByCurrentThread() â†’ true
    RLock->>Redis: DEL lock_key
```

#### 2. **Preventing Wrong Thread Unlock**
```mermaid
sequenceDiagram
    participant ThreadA
    participant ThreadB
    participant RLock
    participant Redis
    
    ThreadA->>RLock: tryLock() â†’ true
    ThreadB->>RLock: unlock()  # Malicious/accidental unlock
    RLock->>RLock: isHeldByCurrentThread() â†’ false
    RLock-->>ThreadB: Ignore unlock (no action)
```

#### 3. **Reentrant Lock Handling**
```mermaid
sequenceDiagram
    participant ThreadA
    participant RLock
    participant Redis
    
    ThreadA->>RLock: tryLock() â†’ true (holdCount=1)
    ThreadA->>RLock: tryLock() â†’ true (holdCount=2)
    
    ThreadA->>RLock: unlock() (holdCount=1)
    RLock->>RLock: isHeldByCurrentThread() â†’ true
    RLock->>Redis: Not deleted (holdCount > 0)
    
    ThreadA->>RLock: unlock() (holdCount=0)
    RLock->>Redis: DEL lock_key
```

#### 4. **Exception During Operation**
```mermaid
sequenceDiagram
    participant ThreadA
    participant RLock
    participant Redis
    
    ThreadA->>RLock: tryLock() â†’ true
    ThreadA->>ThreadA: Critical section (crashes!)
    
    Note over ThreadA: Finally block triggers
    ThreadA->>RLock: isHeldByCurrentThread() â†’ true
    ThreadA->>RLock: unlock() â†’ forced release
```

---

### Why This Matters in Production

1. **Avoid Race Conditions**  
   Prevents Thread A from releasing Thread B's lock after network delays.
   
2. **Handle Application Failures**  
   Ensures locks are released even during unexpected errors (OOM, crashes).

3. **Support Complex Workflows**  
   Enables safe nested locking patterns:
   ```java
   public void nestedMethod() {
       if (lock.tryLock()) {
           try {
               // Can call other locked methods safely
               innerMethod();
           } finally {
               if (lock.isHeldByCurrentThread()) {
                   lock.unlock();
               }
           }
       }
   }
   
   public void innerMethod() {
       if (lock.tryLock()) {  // Reentrant acquisition
           try { /* ... */ } 
           finally { 
               if (lock.isHeldByCurrentThread()) lock.unlock();
           }
       }
   }
   ```

---

### Best Practice Always Include:
```java
finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```
This simple check prevents:
- `IllegalMonitorStateException`
- Accidental lock releases
- Deadlocks from orphaned locks
- Concurrency bugs in distributed systems

### Business Case: Why `lock.isHeldByCurrentThread()` Returns `false`

#### Scenario: **E-commerce Inventory Deduction**
Imagine a distributed system where:
1. **Service A** (Node 1) processes an order for the last item in stock
2. **Service B** (Node 2) tries to process the same item simultaneously

```mermaid
sequenceDiagram
    participant ServiceA
    participant Redis
    participant ServiceB

    Note over ServiceA: STEP 1: Acquires lock (Order #100)
    ServiceA->>Redis: SETNX inventory:lock:ITEM123 ServiceA:Thread1
    Redis-->>ServiceA: OK (Lock acquired)

    Note over ServiceA: STEP 2: Network delay/gc pause<br>(lock TTL expires)
    activate ServiceA
    ServiceA-->>ServiceA: â³ 15-sec GC pause (lock TTL=10s)
    deactivate ServiceA

    Note over Redis: Lock auto-expires after 10s

    Note over ServiceB: STEP 3: ServiceB acquires lock
    ServiceB->>Redis: SETNX inventory:lock:ITEM123 ServiceB:Thread1
    Redis-->>ServiceB: OK (New lock acquired)

    Note over ServiceA: STEP 4: ServiceA resumes execution
    ServiceA->>ServiceA: Completes inventory deduction
    ServiceA->>Redis: isHeldByCurrentThread? (inventory:lock:ITEM123)
    Redis-->>ServiceA: Owner = ServiceB:Thread1 â†’ false
```

### Critical Failure Sequence:
1. ServiceA acquires lock (`ServiceA:Thread1`)
2. ServiceA experiences 15-sec GC pause (lock TTL=10 sec)
3. Lock expires automatically in Redis
4. ServiceB acquires the same lock (`ServiceB:Thread1`)
5. ServiceA wakes up and tries to release lock in `finally` block:
   ```java
   if (lock.isHeldByCurrentThread()) { // â† RETURNS FALSE!
       lock.unlock(); // â† SKIPPED!
   }
   ```
6. **Result:** ServiceB's lock remains active â†’ **double inventory deduction**

---

### Why This Happens: The Race Condition
| Time | ServiceA (Node 1) | Redis State | ServiceB (Node 2) |
|------|-------------------|-------------|-------------------|
| t=0  | `lock.tryLock()` â†’ success | `inventory:lock:ITEM123 = ServiceA:Thread1 (TTL 10s)` | Waiting |
| t=9  | GC pause starts | â³ | `lock.tryLock()` â†’ waiting |
| t=10 | Still paused | **LOCK EXPIRED** | `lock.tryLock()` â†’ success! |
| t=11 | Still paused | `inventory:lock:ITEM123 = ServiceB:Thread1` | Processing order |
| t=15 | Resumes processing | Lock owned by ServiceB | Still processing |
| t=16 | Tries to unlock â†’ `isHeldByCurrentThread() = false` | âŒ Unlock skipped | Continues processing |

---

### Business Impact Without `isHeldByCurrentThread` Check
If you **didn't** use the check:
```java
// DANGEROUS CODE
try {
    lock.tryLock();
    // ...
} finally {
    lock.unlock(); // â† Would release ServiceB's lock!
}
```

**Consequences:**
1. ServiceA would forcibly delete ServiceB's lock
2. ServiceC could acquire the lock immediately
3. **Three services simultaneously deduct inventory:**
   - Physical inventory: 1 item
   - Orders processed: 3 â†’ **$20,000 overselling loss**
   - Angry customers, chargebacks, inventory reconciliation nightmare

---

### Real-World Prevention Cases
1. **Financial Transactions**  
   `isHeldByCurrentThread()` prevents double-spending when:
   - Payment service loses lock mid-transaction
   - Reconciliation process tries to "clean up"

2. **Inventory Management**  
   Catches locks lost during:
   - Cloud VM hibernation
   - Network partitioning
   - Long garbage collection pauses

3. **Distributed Batch Processing**  
   Prevents job duplication when workers time out

---

### Key Takeaway
`lock.isHeldByCurrentThread()` is your **safety net** against:
```mermaid
graph LR
    A[Lock Expiry] --> B[Another Service Acquires Lock]
    B --> C[Original Service Wakes Up]
    C --> D[Accidental Unlock Attempt]
    D --> E[Without Check] --> F[Release Others' Lock â†’ Data Corruption]
    D --> G[With Check] --> H[Safe Skip â†’ System Integrity]
```

Always use this check to:
1. Maintain lock ownership integrity
2. Prevent distributed heisenbugs
3. Avoid business logic catastrophes
4. Ensure only valid threads release locks



https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/Redisson.java
https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/RedissonLock.java
https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/RedissonBaseLock.java



åœ¨ Java ä¸­ï¼Œè™½ç„¶ `try-finally` æ˜¯é‡Šæ”¾é”çš„æ ‡å‡†åšæ³•ï¼Œä½†åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹ï¼Œè¿™ç§ç®€å•çš„å†™æ³•éšè—ç€å‡ ä¸ª**è‡´å‘½é™·é˜±**ã€‚

ä»¥ä¸‹æ˜¯ Java å®ç° Redis åˆ†å¸ƒå¼é”æ—¶æœ€å¸¸è§çš„å‘ä»¥åŠè§£å†³æ–¹æ¡ˆï¼š

---

### 1. é‡Šæ”¾äº†ä¸å±äºè‡ªå·±çš„é”ï¼ˆé”è¯¯åˆ ï¼‰

è¿™æ˜¯æœ€ç»å…¸çš„é—®é¢˜ã€‚

* **åœºæ™¯ï¼š**
1. çº¿ç¨‹ A è·å–äº†é”ï¼Œè®¾ç½®è¶…æ—¶æ—¶é—´ 10 ç§’ã€‚
2. çº¿ç¨‹ A é‡åˆ°äº†ä¸¥é‡çš„ **Full GC**ï¼ˆSTW åœé¡¿ï¼‰ï¼Œå¯¼è‡´å¤„ç†æ—¶é—´è¶…è¿‡äº† 10 ç§’ã€‚
3. Redis è‡ªåŠ¨åˆ é™¤äº†çº¿ç¨‹ A çš„é”ã€‚
4. çº¿ç¨‹ B ä¹˜è™šè€Œå…¥ï¼Œè·å–äº†åŒä¸€ä¸ªé”ã€‚
5. çº¿ç¨‹ A æ¢å¤è¿è¡Œï¼Œæ‰§è¡Œ `finally { unlock(); }`ï¼Œç»“æœæŠŠ**çº¿ç¨‹ B çš„é”**ç»™åˆ äº†ã€‚


* **è§£å†³æ–¹æ¡ˆï¼š** åœ¨ `unlock()` æ—¶å¿…é¡»æ ¡éªŒé”çš„ `Value`ã€‚åŠ é”æ—¶å­˜å…¥ä¸€ä¸ªå”¯ä¸€çš„ `UUID` æˆ– `ThreadID`ï¼Œé‡Šæ”¾æ—¶é€šè¿‡ **Lua è„šæœ¬**åŸå­æ€§åœ°â€œæ ¡éªŒå¹¶åˆ é™¤â€ã€‚

### 2. `finally` ä¸­çš„ç©ºæŒ‡é’ˆæˆ–éæ³•çŠ¶æ€

å¦‚æœä½ çš„ `lock()` æ–¹æ³•æŠ›å‡ºå¼‚å¸¸ï¼Œæˆ–è€… `tryLock()` è¿”å›äº† `false`ï¼Œè¿›å…¥ `finally` å—æ—¶ç›´æ¥è°ƒç”¨ `unlock()` ä¼šå¯¼è‡´é”™è¯¯ã€‚

* **åœºæ™¯ï¼š** æ²¡æ‹¿åˆ°é”ä¹Ÿå»æ‰§è¡Œé‡Šæ”¾é€»è¾‘ã€‚
* **è§£å†³æ–¹æ¡ˆï¼š**
```java
boolean isLocked = false;
try {
    isLocked = lock.tryLock(10, 30, TimeUnit.SECONDS);
    if (isLocked) {
        // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    }
} finally {
    // åªæœ‰è·å–é”æˆåŠŸæ‰é‡Šæ”¾ï¼Œä¸”éœ€åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦è¿˜æŒæœ‰é”
    if (isLocked && lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}

```



### 3. å¯é‡å…¥æ€§é—®é¢˜ (Reentrancy)

Java çš„ `ReentrantLock` æ˜¯å¯é‡å…¥çš„ï¼Œä½†ç®€å•çš„ Redis `SET NX` é”é€šå¸¸**ä¸å¯é‡å…¥**ã€‚

* **åœºæ™¯ï¼š** `MethodA` æ‹¿åˆ°äº†é”ï¼Œéšåè°ƒç”¨äº† `MethodB`ï¼Œè€Œ `MethodB` ä¹Ÿå°è¯•è·å–åŒä¸€ä¸ªé”ã€‚
* **åæœï¼š** çº¿ç¨‹ä¼šæŠŠè‡ªå·±é”æ­»ï¼ˆæ­»é”ï¼‰ã€‚
* **è§£å†³æ–¹æ¡ˆï¼š** ä½¿ç”¨ Redis çš„ **Hash ç»“æ„**æ¥å­˜å‚¨é”ï¼ŒKey æ˜¯é”åç§°ï¼ŒField æ˜¯ `ThreadID`ï¼ŒValue æ˜¯ `é‡å…¥æ¬¡æ•°`ã€‚

### 4. å®ˆæŠ¤çº¿ç¨‹ä¸é”ç»­æœŸ (Watchdog)

å¦‚æœä¸šåŠ¡é€»è¾‘æ‰§è¡Œæ—¶é—´ä¸ç¡®å®šï¼Œç»™é”è®¾ç½®å¤šé•¿çš„ TTLï¼ˆè¿‡æœŸæ—¶é—´ï¼‰éƒ½ä¸å®‰å…¨ã€‚

* **åœºæ™¯ï¼š** TTL å¤ªçŸ­ï¼Œä¸šåŠ¡æ²¡æ‰§è¡Œå®Œé”å°±ä¸¢äº†ï¼›TTL å¤ªé•¿ï¼Œå¦‚æœç¨‹åºå®•æœºï¼Œé”é•¿æ—¶é—´ä¸é‡Šæ”¾ã€‚
* **è§£å†³æ–¹æ¡ˆï¼š** å¼•å…¥**çœ‹é—¨ç‹— (Watchdog)** æœºåˆ¶ã€‚åœ¨é”å³å°†è¿‡æœŸæ—¶ï¼Œç”±ä¸€ä¸ªåå°çº¿ç¨‹è‡ªåŠ¨ç»™é”â€œç»­å‘½â€ã€‚

---

### 5. æœ€ä½³å®è·µï¼šä½¿ç”¨ Redisson

æ‰‹åŠ¨ç”¨ `Jedis` æˆ– `Lettuce` å†™å‡ºå®Œç¾çš„åˆ†å¸ƒå¼é”éå¸¸å›°éš¾ã€‚åœ¨ Java ç”Ÿæ€ä¸­ï¼Œ**Redisson** æ˜¯å…¬è®¤çš„å·¥ä¸šçº§æ ‡å‡†æ–¹æ¡ˆã€‚

å®ƒå®Œç¾è§£å†³äº†ä¸Šè¿°æ‰€æœ‰é—®é¢˜ï¼š

* **åŸå­æ€§ï¼š** å…¨éƒ¨åŸºäº Lua è„šæœ¬ã€‚
* **çœ‹é—¨ç‹—ï¼š** è‡ªåŠ¨ç»­æœŸï¼Œé˜²æ­¢ä¸šåŠ¡æ²¡è·‘å®Œé”è¿‡æœŸã€‚
* **å¯é‡å…¥ï¼š** æ”¯æŒåƒ `ReentrantLock` ä¸€æ ·çš„é‡å…¥é€»è¾‘ã€‚
* **å…¬å¹³æ€§ï¼š** æ”¯æŒå…¬å¹³é”ï¼ˆFair Lockï¼‰ã€‚

#### Redisson æ ‡å‡†å†™æ³•ç¤ºä¾‹ï¼š

```java
RLock lock = redissonClient.getLock("order_lock");
try {
    // 1. å°è¯•åŠ é”ï¼Œæœ€å¤šç­‰å¾… 10 ç§’ï¼Œä¸Šé”å 30 ç§’è‡ªåŠ¨è§£é”ï¼ˆå¦‚æœçœ‹é—¨ç‹—å¼€å¯åˆ™è‡ªåŠ¨ç»­æœŸï¼‰
    boolean isLocked = lock.tryLock(10, 30, TimeUnit.SECONDS);
    if (isLocked) {
        // 2. æ‰§è¡Œæ ¸å¿ƒä¸šåŠ¡é€»è¾‘
    }
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // å¤„ç†ä¸­æ–­
} finally {
    // 3. åªæœ‰æŒæœ‰é”çš„çº¿ç¨‹æ‰èƒ½é‡Šæ”¾é”
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}

```

---

### æ€»ç»“å»ºè®®

| ç»´åº¦ | æ™®é€š `SET NX` å®ç° | Redisson å®ç° |
| --- | --- | --- |
| **åŸå­æ€§** | éœ€æ‰‹åŠ¨å†™ Lua è„šæœ¬ | å†…ç½®æ”¯æŒ |
| **è¯¯åˆ é£é™©** | é«˜ï¼ˆéœ€æ‰‹åŠ¨æ¯”å¯¹ UUIDï¼‰ | ä½ï¼ˆå†…éƒ¨è‡ªåŠ¨å¤„ç†ï¼‰ |
| **å¯é‡å…¥æ€§** | ä¸æ”¯æŒï¼ˆéœ€è‡ªå·±æ”¹ Hash ç»“æ„ï¼‰ | åŸç”Ÿæ”¯æŒ |
| **ç»­æœŸæœºåˆ¶** | æ— ï¼ˆå®¹æ˜“å¯¼è‡´å¹¶å‘å†²çªï¼‰ | è‡ªåŠ¨çœ‹é—¨ç‹—æœºåˆ¶ |
| **å¤æ‚åœºæ™¯** | éš¾ä»¥å®ç°ï¼ˆçº¢é”ã€è¯»å†™é”ï¼‰ | ç°æˆç»„ä»¶ |

**æ‚¨ç›®å‰æ˜¯åœ¨ä½¿ç”¨åŸç”Ÿçš„ Jedis/Lettuce æ‰‹å†™é”é€»è¾‘ï¼Œè¿˜æ˜¯å·²ç»é›†æˆäº† Redisson æ¡†æ¶ï¼Ÿ** å¦‚æœéœ€è¦ï¼Œæˆ‘å¯ä»¥ä¸ºæ‚¨å±•ç¤ºå¦‚ä½•æ‰‹å†™é‚£ä¸ªç”¨äºå®‰å…¨é‡Šæ”¾é”çš„ **Lua è„šæœ¬**ã€‚
