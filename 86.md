Let's dive into practicing Phoenix Channels! I'll guide you through a practical example of building a real-time chat app. This will help you understand the core concepts of Channels.

### Step 1: Setup (Create a new Phoenix app)
```bash
mix phx.new chat_app --no-ecto
cd chat_app
```

### Step 2: Generate Channel
```bash
mix phx.gen.channel Room
```

### Step 3: Server-Side Implementation (Elixir)

**File: `lib/chat_app_web/channels/room_channel.ex`**
```elixir
defmodule ChatAppWeb.RoomChannel do
  use Phoenix.Channel

  # Join handler for "room:lobby" topic
  def join("room:lobby", _message, socket) do
    {:ok, socket}
  end

  # Handle incoming "new_message" events
  def handle_in("new_message", %{"body" => body}, socket) do
    # Broadcast message to all subscribers
    broadcast!(socket, "new_message", %{body: body})
    {:noreply, socket}
  end
end
```

**File: `lib/chat_app_web/channels/user_socket.ex`**
```elixir
defmodule ChatAppWeb.UserSocket do
  use Phoenix.Socket

  channel "room:*", ChatAppWeb.RoomChannel

  @impl true
  def connect(_params, socket, _connect_info) do
    {:ok, socket}
  end

  def id(_socket), do: nil
end
```

### Step 4: Client-Side Implementation (JavaScript)

**File: `assets/js/app.js`**
```javascript
import socket from "./socket"

let channel = socket.channel("room:lobby", {})
let messageInput = document.getElementById("message-input")
let messagesContainer = document.getElementById("messages")

// Join channel
channel.join()
  .receive("ok", resp => console.log("Joined lobby"))
  .receive("error", resp => console.log("Failed to join", resp))

// Listen for new messages
channel.on("new_message", payload => {
  let messageItem = document.createElement("li")
  messageItem.innerText = payload.body
  messagesContainer.appendChild(messageItem)
})

// Send message on form submit
document.getElementById("message-form").addEventListener("submit", event => {
  event.preventDefault()
  channel.push("new_message", {body: messageInput.value})
  messageInput.value = ""
})
```

**File: `assets/js/socket.js`**
```javascript
import {Socket} from "phoenix"

let socket = new Socket("/socket", {
  params: {token: window.userToken}
})

export default socket
```

### Step 5: HTML Interface

**File: `lib/chat_app_web/templates/page/index.html.heex`**
```html
<div class="container">
  <h1>Real-time Chat</h1>
  
  <div id="messages" style="height: 300px; overflow-y: scroll; border: 1px solid #ccc;"></div>
  
  <form id="message-form">
    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off">
    <button type="submit">Send</button>
  </form>
</div>
```

### Step 6: Start the Server
```bash
mix phx.server
```

Visit `http://localhost:4000` to test!

### Key Concepts to Practice:
1. **Channel Structure:**
   - Topic: "room:lobby"
   - Event: "new_message"

2. **Message Flow:**
   - Client sends: `push("new_message", {body: text})`
   - Server handles: `handle_in("new_message", payload, socket)`
   - Server broadcasts: `broadcast!(socket, "new_message", payload)`
   - Client receives: `channel.on("new_message", callback)`

3. **Pattern Matching:**
   ```elixir
   # Handle different message formats
   def handle_in("new_message", %{"body" => body, "user" => user}, socket) do
     broadcast!(socket, "new_message", %{user: user, body: body})
   end
   ```

4. **Presence Tracking (Bonus):**
   ```elixir
   # In mix.exs
   {:phoenix_presence, "~> 2.0"}
   
   # Track users when they join
   def join("room:" <> room_id, _params, socket) do
     send(self(), :after_join)
     {:ok, socket}
   end
   
   handle_info(:after_join, socket) do
     {:ok, _} = Presence.track(socket, socket.assigns.user_id, %{})
     push(socket, "presence_state", Presence.list(socket))
     {:noreply, socket}
   end
   ```

### Testing Tips:
1. Open multiple browser windows to see real-time updates
2. Use Chrome DevTools to:
   - Monitor WebSocket connections
   - See channel join/push events
   - Debug JavaScript handlers
3. Try broadcasting to specific topics:
   ```elixir
   # Broadcast to specific room
   ChatAppWeb.Endpoint.broadcast("room:" <> room_id, "new_message", payload)
   ```

### Common Gotchas:
1. **Channel Mismatch:** Ensure topic patterns match (server's `room:*` vs client's `room:lobby`)
2. **Event Name Typos:** "new_message" vs "new_message"
3. **Missing Socket Import:** Verify `assets/js/socket.js` is imported in app.js
4. **CSRF Protection:** Add CSRF token to socket params if using authentication

Want to extend this further? Try:
- Adding user authentication
- Implementing message history
- Adding typing indicators
- Creating private rooms

How would you like to proceed? Shall we:
1. Walk through adding a new feature?
2. Debug a specific issue?
3. Explore Presence for user tracking?
4. Try testing strategies for channels?




Let's build a Phoenix Channels-inspired real-time system in Rust using **Actix Web** and **WebSockets**. This will give you a similar pub/sub experience with Rust's performance and safety guarantees.

### Step 1: Setup New Project
```bash
cargo new rust_channels
cd rust_channels
```

### Step 2: Add Dependencies (`Cargo.toml`)
```toml
[package]
name = "rust_channels"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.4.0"
actix-web-actors = "4.2.0"
actix = "0.13.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["macros", "rt-multi-thread"] }
```

### Step 3: Implement Channel System

**File: `src/main.rs`**
```rust
use actix::prelude::*;
use actix_web::{web, App, Error, HttpRequest, HttpResponse, HttpServer};
use actix_web_actors::ws;
use serde::{Deserialize, Serialize};

// Message types (equivalent to Phoenix "events")
#[derive(Message, Serialize, Deserialize)]
#[rtype(result = "()")]
enum ChannelMessage {
    NewMessage { body: String },
    UserJoined { user_id: String },
}

// Channel Actor (represents a topic like "room:lobby")
struct ChannelActor {
    subscribers: Vec<Recipient<ChannelMessage>>,
}

impl Actor for ChannelActor {
    type Context = Context<Self>;
}

// Handle subscribe requests
#[derive(Message)]
#[rtype(result = "()")]
struct Subscribe(pub Recipient<ChannelMessage>);

impl Handler<Subscribe> for ChannelActor {
    type Result = ();

    fn handle(&mut self, msg: Subscribe, _: &mut Context<Self>) {
        self.subscribers.push(msg.0);
    }
}

// Handle broadcast messages
impl Handler<ChannelMessage> for ChannelActor {
    type Result = ();

    fn handle(&mut self, msg: ChannelMessage, _: &mut Context<Self>) {
        for sub in &self.subscribers {
            sub.do_send(msg.clone());
        }
    }
}

// WebSocket Connection Actor
struct WsConnection {
    channel_addr: Addr<ChannelActor>,
}

impl Actor for WsConnection {
    type Context = ws::WebsocketContext<Self>;
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WsConnection {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Text(text)) => {
                // Parse incoming JSON message
                if let Ok(msg) = serde_json::from_str::<ChannelMessage>(&text) {
                    self.channel_addr.do_send(msg);
                }
            }
            _ => (),
        }
    }
}

impl Handler<ChannelMessage> for WsConnection {
    type Result = ();

    fn handle(&mut self, msg: ChannelMessage, ctx: &mut Self::Context) {
        // Send message to client
        ctx.text(serde_json::to_string(&msg).unwrap());
    }
}

// WebSocket handler (equivalent to Phoenix socket)
async fn ws_handler(
    req: HttpRequest,
    stream: web::Payload,
    channel_addr: web::Data<Addr<ChannelActor>>,
) -> Result<HttpResponse, Error> {
    ws::start(
        WsConnection {
            channel_addr: channel_addr.get_ref().clone(),
        },
        &req,
        stream,
    )
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Start channel actor
    let channel = ChannelActor {
        subscribers: vec![],
    }
    .start();

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(channel.clone()))
            .route("/ws", web::get().to(ws_handler))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```

### Step 4: Client Implementation (JavaScript)

**File: `public/index.html`**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Rust Channels</title>
</head>
<body>
    <div id="messages"></div>
    <input type="text" id="message-input" />
    <button onclick="sendMessage()">Send</button>

    <script>
        const ws = new WebSocket("ws://localhost:8080/ws");
        const messagesDiv = document.getElementById('messages');
        
        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            switch (msg.NewMessage ? 'NewMessage' : msg.UserJoined ? 'UserJoined' : '') {
                case 'NewMessage':
                    messagesDiv.innerHTML += `<div>${msg.NewMessage.body}</div>`;
                    break;
                case 'UserJoined':
                    messagesDiv.innerHTML += `<div>User joined: ${msg.UserJoined.user_id}</div>`;
                    break;
            }
        };
        
        function sendMessage() {
            const input = document.getElementById('message-input');
            ws.send(JSON.stringify({
                NewMessage: { body: input.value }
            }));
            input.value = '';
        }
    </script>
</body>
</html>
```

### Step 5: Run the Server
```bash
cargo run
```

Visit `http://localhost:8080` to test with multiple clients!

### Key Concepts Explained:
1. **Channel Actor:**
   - Manages subscribers (connected clients)
   - Broadcasts messages to all subscribers
   - Equivalent to Phoenix Channel's process

2. **Message Types:**
   ```rust
   enum ChannelMessage {
       NewMessage { body: String },
       UserJoined { user_id: String },
   }
   ```
   - Similar to Phoenix events ("new_message", "user_joined")

3. **WebSocket Flow:**
   - Client connects via `/ws` endpoint
   - Server creates per-connection actor
   - Messages are serialized as JSON
   - Channel actor handles broadcasting

4. **Pattern Matching:**
   - Client-side JS uses switch on message type
   - Server-side uses enum pattern matching

### To Enhance This System:
1. Add multiple channels:
   ```rust
   struct ChannelRegistry {
       rooms: HashMap<String, Addr<ChannelActor>>,
   }
   ```

2. Implement Presence:
   ```rust
   struct Presence {
       users: HashMap<String, UserInfo>,
   }
   ```

3. Add Auth:
   ```rust
   async fn ws_handler(
       req: HttpRequest,
       // ...,
       user: AuthenticatedUser, // From middleware
   ) { ... }
   ```

4. Add Message History:
   ```rust
   struct ChannelActor {
       history: VecDeque<ChannelMessage>,
   }
   ```

### Comparison to Phoenix:
| Phoenix Concept       | Rust Equivalent               |
|-----------------------|-------------------------------|
| Channel Process       | ChannelActor                  |
| Socket Handler        | ws::start + WsConnection      |
| Events                | ChannelMessage enum variants  |
| Presence              | Presence struct in Actor      |
| Topic Pattern Matching| Hashmap of channels           |

### Testing with CLI Client:
```bash
# Install websocat
brew install websocat

# Connect to server
websocat ws://localhost:8080/ws

# Send message
{"NewMessage": {"body": "Hello Rust!"}}
```

This gives you a solid foundation for building Phoenix-like real-time systems in Rust. Want to dive deeper into any specific part?
