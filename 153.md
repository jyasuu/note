I'll help you understand best practices for using Yew hooks. Let me create a comprehensive guide covering each of these hooks with practical examples and patterns.I've created a comprehensive guide covering all 13 Yew hooks with best practices. Here are the key takeaways:

**Core Patterns:**
- **State hooks** (`use_state`, `use_state_eq`): For reactive UI state. Always clone handles before using in closures to avoid borrow issues.
- **Performance hooks** (`use_memo`, `use_callback`): Prevent unnecessary computations and child re-renders. Essential when dealing with lists or expensive operations.
- **Reference hooks** (`use_ref`, `use_mut_ref`, `use_node_ref`): For accessing DOM or tracking values without triggering re-renders. Prefer `use_node_ref` for DOM access.
- **Effect hooks** (`use_effect`, `use_effect_with`): Handle side effects. Always return a cleanup function if your effect subscribes to anything.
- **Complex state** (`use_reducer`, `use_reducer_eq`): When state updates are interdependent or you need logging/debugging.
- **Context** (`use_context`): Share data globally, but don't overuse as it can impact performance.
- **Force update**: Avoid this unless you have a genuinely non-reactive data source.

**Pro tip**: Clone handle-based state before using in callbacks/closures to avoid lifetime issues. Most performance problems come from missing `use_callback` or `use_memo` on frequently re-rendered components.

```rust
// Yew Hooks Best Practices - Complete Guide
// Using Yew 0.20+

use yew::prelude::*;
use yew::hooks::*;

// ============================================================================
// 1. USE_STATE - Managing simple reactive state
// ============================================================================
#[function_component]
fn CounterExample() -> Html {
    let counter = use_state(|| 0);
    
    let onclick = {
        let counter = counter.clone();
        Callback::from(move |_| {
            counter.set(*counter + 1);
        })
    };
    
    html! {
        <div>
            <p>{"Count: "}{*counter}</p>
            <button {onclick}>{"Increment"}</button>
        </div>
    }
}

// ============================================================================
// 2. USE_STATE_EQ - State with custom equality checking
// ============================================================================
#[derive(Clone, PartialEq, Eq)]
struct User {
    id: u32,
    name: String,
}

#[function_component]
fn UseStateEqExample() -> Html {
    // Only triggers re-render when User actually changes (not every time)
    let user = use_state_eq(|| User {
        id: 1,
        name: "Alice".to_string(),
    });
    
    html! {
        <div>
            <p>{format!("{}: {}", user.id, user.name)}</p>
        </div>
    }
}

// ============================================================================
// 3. USE_MEMO - Expensive computations, recompute only when deps change
// ============================================================================
#[function_component]
fn UseMemoExample(#[prop_default = 5] num: u32) -> Html {
    // Only recalculates when `num` changes
    let expensive_result = use_memo(|_| {
        // Simulate expensive calculation
        (0..1000000).sum::<u32>() + num
    }, num);
    
    html! {
        <div>
            <p>{"Result: "}{*expensive_result}</p>
        </div>
    }
}

// ============================================================================
// 4. USE_CALLBACK - Memoized callbacks, prevents unnecessary child re-renders
// ============================================================================
#[function_component]
fn UseCallbackExample() -> Html {
    let count = use_state(|| 0);
    
    // This callback is memoized and only changes when dependencies change
    let handle_click = use_callback(
        |_, count| {
            count.set(*count + 1);
        },
        count.clone(),
    );
    
    html! {
        <>
            <p>{"Count: "}{*count}</p>
            <ChildComponent {handle_click} />
        </>
    }
}

#[derive(Properties, PartialEq)]
struct ChildProps {
    handle_click: Callback<()>,
}

#[function_component]
fn ChildComponent(props: &ChildProps) -> Html {
    // Won't re-render unless handle_click changes
    let ChildProps { handle_click } = props;
    
    html! {
        <button onclick={handle_click.clone()}>{"Click Child"}</button>
    }
}

// ============================================================================
// 5. USE_REF - Access DOM elements directly (immutable reference)
// ============================================================================
#[function_component]
fn UseRefExample() -> Html {
    let input_ref = use_node_ref();
    
    let focus_input = {
        let input_ref = input_ref.clone();
        Callback::from(move |_| {
            if let Some(input) = input_ref.cast::<web_sys::HtmlInputElement>() {
                let _ = input.focus();
            }
        })
    };
    
    html! {
        <div>
            <input ref={input_ref} />
            <button onclick={focus_input}>{"Focus Input"}</button>
        </div>
    }
}

// ============================================================================
// 6. USE_MUT_REF - Mutable reference that persists across renders
// ============================================================================
#[function_component]
fn UseMutRefExample() -> Html {
    let render_count = use_mut_ref(|| 0);
    
    {
        let mut count = render_count.borrow_mut();
        *count += 1;
    }
    
    let current = *render_count.borrow();
    
    html! {
        <p>{"This component has rendered: "}{current}{" times"}</p>
    }
}

// ============================================================================
// 7. USE_NODE_REF - Typed DOM node reference (preferred over use_ref for DOM)
// ============================================================================
#[function_component]
fn UseNodeRefExample() -> Html {
    let div_ref = use_node_ref();
    
    let scroll_to_bottom = {
        let div_ref = div_ref.clone();
        Callback::from(move |_| {
            if let Some(element) = div_ref.cast::<web_sys::HtmlElement>() {
                element.set_scroll_top(element.scroll_height());
            }
        })
    };
    
    html! {
        <div ref={div_ref} style="height: 200px; overflow-y: auto;">
            <p>{"Scrollable content..."}</p>
            <button onclick={scroll_to_bottom}>{"Scroll to bottom"}</button>
        </div>
    }
}

// ============================================================================
// 8. USE_REDUCER - Complex state logic with actions
// ============================================================================
#[derive(Clone, Debug, PartialEq)]
enum CounterAction {
    Increment,
    Decrement,
    Reset,
}

fn counter_reducer(state: i32, action: CounterAction) -> i32 {
    match action {
        CounterAction::Increment => state + 1,
        CounterAction::Decrement => state - 1,
        CounterAction::Reset => 0,
    }
}

#[function_component]
fn UseReducerExample() -> Html {
    let state = use_reducer(|| 0, counter_reducer);
    
    html! {
        <div>
            <p>{"Counter: "}{*state}</p>
            <button onclick={Callback::from(move |_| state.dispatch(CounterAction::Increment))}>
                {"Increment"}
            </button>
            <button onclick={Callback::from(move |_| state.dispatch(CounterAction::Decrement))}>
                {"Decrement"}
            </button>
            <button onclick={Callback::from(move |_| state.dispatch(CounterAction::Reset))}>
                {"Reset"}
            </button>
        </div>
    }
}

// ============================================================================
// 9. USE_REDUCER_EQ - Reducer with custom equality
// ============================================================================
#[derive(Clone, Debug, PartialEq, Eq)]
struct AppState {
    counter: i32,
    name: String,
}

fn app_reducer(state: AppState, action: String) -> AppState {
    let mut new_state = state;
    // Process action
    new_state
}

#[function_component]
fn UseReducerEqExample() -> Html {
    let state = use_reducer_eq(
        || AppState {
            counter: 0,
            name: "App".to_string(),
        },
        app_reducer,
    );
    
    html! {
        <p>{&state.name}</p>
    }
}

// ============================================================================
// 10. USE_EFFECT - Side effects (API calls, subscriptions, DOM updates)
// ============================================================================
#[function_component]
fn UseEffectExample() -> Html {
    let count = use_state(|| 0);
    let loaded = use_state(|| false);
    
    {
        let loaded = loaded.clone();
        use_effect_with(
            move || {
                // This runs when component mounts
                log::info!("Component mounted!");
                
                // Cleanup function (runs on unmount)
                move || {
                    log::info!("Component unmounting!");
                }
            },
            (),
        );
    }
    
    html! {
        <div>
            <p>{"Count: "}{*count}</p>
            <p>{if *loaded { "Loaded!" } else { "Loading..." }}</p>
        </div>
    }
}

// ============================================================================
// 11. USE_EFFECT_WITH - Effect with dependencies
// ============================================================================
#[function_component]
fn UseEffectWithExample(#[prop_default = "Alice".to_string()] name: String) -> Html {
    let output = use_state(String::new);
    
    {
        let output = output.clone();
        let name = name.clone();
        use_effect_with(
            move || {
                output.set(format!("Hello, {}!", name));
                
                // Cleanup
                || {}
            },
            name,
        );
    }
    
    html! {
        <p>{(*output).clone()}</p>
    }
}

// ============================================================================
// 12. USE_CONTEXT - Access shared context values
// ============================================================================
#[derive(Clone, PartialEq)]
struct ThemeContext {
    dark_mode: bool,
}

#[function_component]
fn UseContextExample() -> Html {
    let theme = use_context::<ThemeContext>().expect("Theme context not found");
    
    html! {
        <div style={format!("background-color: {}", if theme.dark_mode { "black" } else { "white" })}>
            <p>{"Theme mode: "}{if theme.dark_mode { "Dark" } else { "Light" }}</p>
        </div>
    }
}

// ============================================================================
// 13. USE_FORCE_UPDATE - Manual re-render (use sparingly!)
// ============================================================================
#[function_component]
fn UseForceUpdateExample() -> Html {
    let force_update = use_force_update();
    
    let trigger_rerender = Callback::from(move |_| {
        force_update.force_update();
    });
    
    html! {
        <button onclick={trigger_rerender}>
            {"Force Re-render (avoid using this)"}
        </button>
    }
}

// ============================================================================
// BEST PRACTICES SUMMARY
// ============================================================================
/*
1. USE_STATE: Simple state management
   - Use for UI state (counters, form inputs, toggles)
   - Clone handle before using in closures
   
2. USE_STATE_EQ: Performance optimization
   - Use when type implements Eq/PartialEq
   - Prevents re-renders if value hasn't actually changed
   
3. USE_MEMO: Expensive computations
   - Memoize expensive calculations
   - Pass dependencies as second argument
   
4. USE_CALLBACK: Memoized callbacks
   - Prevents child re-renders (especially with PureComponent)
   - Important for optimization with large lists
   
5. USE_REF: DOM access (immutable)
   - Avoid mutating through RefCell
   - Good for read-only access
   
6. USE_MUT_REF: Persistent state without re-renders
   - Track data that shouldn't trigger renders
   - Use borrow_mut() carefully
   
7. USE_NODE_REF: Typed DOM references
   - Preferred over use_ref for DOM elements
   - Safer type casting
   
8. USE_REDUCER: Complex state logic
   - Use for state that depends on previous state
   - Easier to test than scattered use_state calls
   - Better for related state updates
   
9. USE_REDUCER_EQ: Reducer with equality checks
   - Same benefits as use_reducer + use_state_eq
   
10. USE_EFFECT: Side effects
    - Runs after every render by default
    - Return cleanup function if needed
    
11. USE_EFFECT_WITH: Conditional effects
    - Only runs when dependencies change
    - Avoid passing entire components as deps
    
12. USE_CONTEXT: Shared state
    - Use for global config, themes, auth
    - Avoid over-using (can hurt performance)
    
13. USE_FORCE_UPDATE: Emergency only
    - Avoid if possible - indicates design issue
    - Last resort for non-reactive updates
*/
```
